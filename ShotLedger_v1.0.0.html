
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>ShotLedger v1.5.15 (Release Gate — ShotMarker fix + UX polish + export validation)</title>
<style>
  :root{
    --bg0:#070b12; --bg1:#0b1220; --card: rgba(10,18,32,.72);
    --stroke: rgba(140,170,210,.18);
    --stroke2: rgba(140,170,210,.28);
    --txt:#e6eef8; --muted: rgba(230,238,248,.72);
    --pill:#0f1b2a; --pill2:#0c1625; --accent:#4da3ff;
    --good:#3ddc97; --warn:#f7c46a; --bad:#ff6b6b;
  }
  *{box-sizing:border-box}
  body{
    margin:0; color:var(--txt);
    font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial;
    background: radial-gradient(1200px 800px at 20% 0%, #102849 0%, transparent 60%),
                radial-gradient(1000px 700px at 80% 20%, #0b2a3f 0%, transparent 60%),
                linear-gradient(180deg, var(--bg1), var(--bg0));
    min-height:100vh;
  }
  .wrap{max-width:1320px; margin:0 auto; padding:18px 18px 28px;}
  h1{margin:0 0 4px; font-size:20px; letter-spacing:.2px;}
  .sub{color:var(--muted); margin:0 0 14px;}
  .card{
    background: var(--card);
    border: 1px solid var(--stroke);
    border-radius: 16px;
    box-shadow: 0 10px 40px rgba(0,0,0,.25);
    padding: 14px;
    backdrop-filter: blur(10px);
  }
  .topbar{display:flex; gap:12px; align-items:flex-start; justify-content:space-between;}
  .btn{
    background: linear-gradient(180deg, rgba(25,40,64,.92), rgba(15,27,42,.92));
    border:1px solid var(--stroke2);
    color:var(--txt);
    border-radius: 12px;
    padding: 10px 12px;
    cursor:pointer;
    font-weight:600;
  }
  .btn:active{transform: translateY(1px);}
  .btn.small{padding:8px 10px; border-radius:10px; font-weight:600}
  .btn.ghost{background: transparent;}
  .row{display:flex; flex-wrap:wrap; gap:10px; align-items:center;}
  .pill{
    display:inline-flex; align-items:center; gap:8px;
    padding: 8px 10px; border-radius: 999px;
    background: rgba(15,27,42,.65);
    border:1px solid var(--stroke);
    color: var(--muted);
    max-width:100%;
  }
  .pill b{color:var(--txt); font-weight:700}
  .grid{
    margin-top: 14px;
    display:grid;
    grid-template-columns: minmax(0, 1fr) 420px;
    gap: 14px;
    align-items:start;
  }
  @media (max-width: 1100px){
    .grid{grid-template-columns: 1fr;}
  }

  /* --- Phase 3 layout guardrails (prevent page-level horizontal overflow) --- */
  .grid, .leftCol, .rightCol, .tableCard, .tableWrap{min-width:0;}
  .tableWrap{width:100%; max-width:100%;}
  /* When Kestrel panel is hidden, let the left pane span full width */
  .grid.fullWidth{grid-template-columns: 1fr !important;}
  .grid.fullWidth .leftCol{grid-column: 1 / -1;}

  /* Phase 5.4.8: prevent left-column text from painting behind sticky Kestrel panel */
  .leftCol{overflow:hidden; position:relative; z-index:1;}
  .rightCol{position:relative; z-index:5;}


  .panelTitle{display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:10px;}
  .panelTitle h2{margin:0; font-size:16px;}
  .status{margin-top:10px; color:var(--muted); white-space:pre-line;}
  .status .good{color:var(--good)}
  .status .warn{color:var(--warn)}
  .status .bad{color:var(--bad)}
  label{display:block; color:var(--muted); font-size:12px; margin:8px 0 6px;}
  input, select{
    width:100%;
    background-color: var(--pill);
    color: var(--txt);
    border: 1px solid var(--stroke2);
    border-radius: 12px;
    padding: 10px 10px;
    font-size: 14px;
  }
  select{appearance:auto;}
  input:focus, select:focus{
    outline:none;
    border-color: rgba(77,163,255,.75);
    box-shadow: 0 0 0 2px rgba(77,163,255,.20);
  }
  .two{display:grid; grid-template-columns: 1fr 1fr; gap:10px;}
  @media (max-width: 520px){ .two{grid-template-columns: 1fr;} }
  .rollupHeader{
    display:flex; align-items:center; justify-content:space-between;
    cursor:pointer; user-select:none;
    padding:10px 12px; border-radius:12px;
    background: rgba(15,27,42,.55);
    border: 1px solid var(--stroke);
  }
  .rollupHeader .meta{color:var(--muted); font-size:12px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width:60%;}
  .rollupBody{padding:10px 2px 2px;}
  .hidden{display:none !important;}
  .tableCard{padding:0; overflow:hidden; margin-top:14px;}
  .tableHead{padding:14px 14px 10px; border-bottom:1px solid var(--stroke);}
  .tableWrap{
    padding: 0 0 10px;
    overflow:auto;
    -webkit-overflow-scrolling: touch;
    overscroll-behavior: contain;
    max-height: 560px;
  }
  table{
    border-collapse: collapse;
    width: 100%;
    min-width: 1400px;
    font-variant-numeric: tabular-nums;
  }
  th, td{
    padding: 10px 12px;
    border-bottom: 1px solid rgba(140,170,210,.12);
    white-space:nowrap;
  }
  th{
    position: sticky; top: 0;
    background: rgba(9,15,26,.92);
    z-index: 2;
    color: rgba(230,238,248,.9);
    font-weight: 700;
    text-align:left;
  }
  tr:hover td{background: rgba(77,163,255,.06);}
  .tagpill{
    display:inline-flex; padding:2px 8px; border-radius:999px;
    border:1px solid rgba(247,196,106,.35);
    background: rgba(247,196,106,.08);
    color: rgba(247,196,106,.95);
    font-size:12px;
  }
  .rightCol{position:relative;}
  .rightCol .card{position:sticky; top:14px;}
  @media (max-width:1100px){ .rightCol .card{position:relative; top:auto;} }
  .hint{color:var(--muted); font-size:12px;}
  .kbtns{display:flex; flex-wrap:wrap; gap:10px; margin-top:10px;}

  .joinpill{
    display:inline-flex; padding:2px 8px; border-radius:999px;
    border:1px solid rgba(140,170,210,.25);
    background: rgba(140,170,210,.08);
    color: rgba(230,238,248,.85);
    font-size:12px; font-weight:700;
  }
  .joinpill.ok{border-color: rgba(61,220,151,.35); background: rgba(61,220,151,.10); color: rgba(61,220,151,.95);}
  .joinpill.warn{border-color: rgba(247,196,106,.35); background: rgba(247,196,106,.10); color: rgba(247,196,106,.95);}
  .joinpill.bad{border-color: rgba(255,107,107,.40); background: rgba(255,107,107,.10); color: rgba(255,107,107,.95);}
  .joinpill.muted{border-color: rgba(140,170,210,.20); background: rgba(140,170,210,.06); color: rgba(230,238,248,.65);}


  /* Phase 3 (Step 1): shot state controls */
  .stateCtl{display:inline-flex; gap:6px; align-items:center;}
  .sbtn{
    width:26px; height:22px; padding:0;
    border-radius:8px;
    border:1px solid rgba(140,170,210,.25);
    background: rgba(15,27,42,.55);
    color: rgba(230,238,248,.85);
    cursor:pointer;
    font-weight:800;
    line-height:20px;
    display:inline-flex;
    align-items:center;
    justify-content:center;
  }
  .sbtn:hover{border-color: rgba(77,163,255,.55);}
  .sbtn.active{border-color: rgba(77,163,255,.95); box-shadow: 0 0 0 2px rgba(77,163,255,.18) inset;}
  .sbtn.rec.active{border-color: rgba(61,220,151,.75); box-shadow: 0 0 0 2px rgba(61,220,151,.18) inset;}
  .sbtn.sgt.active{border-color: rgba(247,196,106,.80); box-shadow: 0 0 0 2px rgba(247,196,106,.18) inset;}
  .sbtn.exc.active{border-color: rgba(255,107,107,.85); box-shadow: 0 0 0 2px rgba(255,107,107,.18) inset;}
  tr.row-sighter td{background: rgba(247,196,106,.06);}
  tr.row-exclude td{opacity:.42; background: rgba(255,107,107,.03);}

  /* Phase 5.4.5: Garmin coverage highlight */
  tr.row-garmiss td{background: rgba(247,196,106,.045);}
  /* Target (block) group headers in All view */
  tr.tGroupHeader td{
    background: rgba(12,22,36,.78);
    border-top: 1px solid rgba(255,255,255,.08);
    font-weight: 800;
    cursor: pointer;
    padding: 10px 12px;
  }
  tr.tGroupHeader:hover td{background: rgba(12,22,36,.90);}
  .tCaret{display:inline-block; width:18px; opacity:.9;}
  .tTitle{margin-right:10px;}
  .tMeta{color: rgba(230,238,248,.68); font-weight:600; font-size:12.5px;}
  tr.tGroupFooter td{background: rgba(12,22,36,.55);}
  tr.row-garmiss:hover td{background: rgba(247,196,106,.07);}
  tr.row-exclude-flag td{box-shadow: inset 3px 0 0 rgba(247,196,106,.55);}
  tr.row-exclude-manual td{box-shadow: inset 3px 0 0 rgba(255,107,107,.55);}


  /* Phase 3 (Step 2): block rollups */
  .blockList{display:flex; flex-direction:column; gap:8px;}

  /* Phase 5.4.2: make Blocks list scrollable without eating the whole page */
  #blocksCard .blockList{max-height:520px; overflow:auto; padding-right:4px;}
  #blocksCard .blockList::-webkit-scrollbar{height:10px;width:10px;}
  #blocksCard .blockList::-webkit-scrollbar-thumb{background: rgba(140,170,210,.20); border-radius:999px;}
  #blocksCard .blockList::-webkit-scrollbar-track{background: transparent;}

  /* Phase 5.4.1: distance source pill */
  .distSrc{
    display:inline-flex; align-items:center; justify-content:center;
    padding:3px 8px; border-radius:999px;
    border:1px solid rgba(140,170,210,.22);
    background: rgba(140,170,210,.06);
    color: rgba(230,238,248,.85);
    font-size:12px; font-weight:900;
  }
  .distSrc.sm{border-color: rgba(77,163,255,.38); background: rgba(77,163,255,.10); color: rgba(77,163,255,.98);}
  .distSrc.man{border-color: rgba(247,196,106,.38); background: rgba(247,196,106,.10); color: rgba(247,196,106,.98);}
  .distSrc.def{opacity:.75;}

  .blockRow{
    display:flex; align-items:center; justify-content:space-between; gap:10px;
    padding:14px 14px; border-radius:14px;
    background: rgba(15,27,42,.50);
    border: 1px solid rgba(140,170,210,.16);
    cursor:pointer;
  }
  .blockRow:hover{border-color: rgba(77,163,255,.45); background: rgba(77,163,255,.05);}
  .blockRow .l{min-width:0;}
  .blockRow .title{font-weight:800;}
    .blockRow .meta{color:var(--muted); font-size:12px; overflow:visible; white-space:normal; max-width:100%;}
  .blockRow .metaLine{margin-top:4px; line-height:1.35; display:block;}
  .blockRow .metaLine.metaCounts{opacity:.85;}
  .blockRow .metaLine.metaVel{opacity:.92;}
  .blockRow .metaLine.metaGeo{opacity:.92;}
  .blockRow .metaLine.metaWind{opacity:.92;}
  .blockRow .stats{display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end;}
  .bchip{display:inline-flex; gap:6px; align-items:center; padding:3px 8px; border-radius:999px;
         border:1px solid rgba(140,170,210,.22); background: rgba(140,170,210,.06); color: rgba(230,238,248,.85); font-size:12px; font-weight:800;}
  .bchip.rec{border-color: rgba(61,220,151,.28); background: rgba(61,220,151,.08); color: rgba(61,220,151,.95);}
  .bchip.sgt{border-color: rgba(247,196,106,.30); background: rgba(247,196,106,.08); color: rgba(247,196,106,.95);}
  .bchip.exc{border-color: rgba(255,107,107,.34); background: rgba(255,107,107,.08); color: rgba(255,107,107,.95);}
  .blockRow.active{border-color: rgba(77,163,255,.85); box-shadow: 0 0 0 2px rgba(77,163,255,.18) inset;}


  
  .warnChip{
    display:inline-flex; align-items:center; justify-content:center;
    padding:2px 7px; border-radius:999px;
    border:1px solid rgba(247,196,106,.35);
    background: rgba(247,196,106,.10);
    color: rgba(247,196,106,.95);
    font-size:12px; font-weight:900;
  }
  .windChip{
    display:inline-flex; align-items:center; justify-content:center;
    padding:2px 8px; border-radius:999px;
    border:1px solid rgba(140,170,210,.22);
    background: rgba(140,170,210,.06);
    color: rgba(230,238,248,.85);
    font-size:12px; font-weight:800;
  }
  .windChip.ok{border-color: rgba(61,220,151,.28); background: rgba(61,220,151,.08); color: rgba(61,220,151,.95);}
  .windChip.warn{border-color: rgba(247,196,106,.30); background: rgba(247,196,106,.08); color: rgba(247,196,106,.95);}
  .windChip.bad{border-color: rgba(255,107,107,.34); background: rgba(255,107,107,.08); color: rgba(255,107,107,.95);}
  .windChip.neutral{border-color: rgba(140,170,210,.22); background: rgba(140,170,210,.06);}
/* Phase 4 */
  .flagchip{
    display:inline-flex; align-items:center; gap:6px;
    padding:2px 8px; border-radius:999px;
    font-size:12px; font-weight:800;
    border:1px solid rgba(140,170,210,.25);
    background: rgba(140,170,210,.08);
    color: rgba(230,238,248,.85);
    cursor:pointer;
    user-select:none;
  }
  .flagchip.ok{border-color: rgba(61,220,151,.35); background: rgba(61,220,151,.10); color: rgba(61,220,151,.95);}
  .flagchip.warn{border-color: rgba(247,196,106,.40); background: rgba(247,196,106,.12); color: rgba(247,196,106,.98);}
  .flagchip.problem{border-color: rgba(247,196,106,.55); background: rgba(247,196,106,.16); color: rgba(247,196,106,.98);}
  .flagchip.bad{border-color: rgba(255,107,107,.45); background: rgba(255,107,107,.12); color: rgba(255,107,107,.98);}
  .flagchip.off{opacity:.55; cursor:default;}
  .miniBtns{display:flex; flex-wrap:wrap; gap:10px; margin-top:10px;}
  .miniBtns .btn{flex:1 1 auto;}
  .mapTable{width:100%; border-collapse:collapse; font-variant-numeric: tabular-nums; table-layout:fixed;}
  .mapTable th,.mapTable td{padding:8px 8px; border-bottom:1px solid rgba(140,170,210,.12); white-space:nowrap;}
  .mapTable th:nth-child(1), .mapTable td:nth-child(1){width:70%;}
  .mapTable th:nth-child(2), .mapTable td:nth-child(2){width:10%; text-align:right;}
  .mapTable th:nth-child(3), .mapTable td:nth-child(3){width:20%;}
  .mapTable td:nth-child(1){white-space:normal; overflow-wrap:anywhere;}

  .mapTable th{color: rgba(230,238,248,.9); font-size:12px; text-transform:none; position:sticky; top:0; background: rgba(9,15,26,.92); z-index:1;}
  .mapTable input{width:110px; padding:8px 10px; border-radius:10px;}


  .distInput{
    width:86px;
    padding:8px 10px;
    border-radius:12px;
    background-color: rgba(15,27,42,.65);
    border:1px solid var(--stroke2);
    color: var(--txt);
    font-weight:700;
    text-align:center;
  }
  .bchip.geo{border-color: rgba(77,163,255,.35); background: rgba(77,163,255,.10); color: rgba(77,163,255,.95);}


  /* Phase 5.4.4: table ergonomics */
  .tableWrap.dense th, .tableWrap.dense td{padding:6px 10px;}
  .tableWrap.dense{max-height: 620px;}
  th[data-sort]{cursor:pointer;}
  th[data-sort]::after{content:''; opacity:.55; margin-left:6px; font-weight:900;}
  th.sort-asc::after{content:'▲';}
  th.sort-desc::after{content:'▼';}

  /* Sticky left columns (#, Block, State) */
  th.sticky, td.sticky{
    position: sticky;
    background: rgba(9,15,26,.96);
    z-index: 3;
  }
  td.sticky{background: rgba(9,15,26,.70); z-index:1;}
  th.sticky.c0, td.sticky.c0{left:0; min-width:44px; max-width:44px;}
  th.sticky.c1, td.sticky.c1{left:44px; min-width:60px;}
  th.sticky.c2, td.sticky.c2{left:104px; min-width:220px; max-width:260px;}
  th.sticky.c3, td.sticky.c3{left:324px; min-width:110px;}


/* --- Suite unified header (NodeLab-style) --- */
.suiteHeader{
  display:flex; align-items:center; justify-content:space-between; gap:14px;
  padding: 12px 14px;
  border-radius: 22px;
  border: 1px solid var(--stroke);
  box-shadow: 0 10px 40px rgba(0,0,0,.25);
  background: linear-gradient(135deg, rgba(10,18,32,.78), rgba(15,27,42,.55));
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  margin: 0 0 14px;
}
.suiteHeader__left{min-width:0;}
.suiteHeader__topline{display:flex; align-items:baseline; gap:10px; flex-wrap:wrap;}
.suiteHeader__title{font-size: 28px; font-weight: 800; letter-spacing: .2px;}
.suiteHeader__pill{
  font-size: 13px; padding: 4px 10px; border-radius: 999px;
  border: 1px solid rgba(140,170,210,.18);
  background: rgba(0,0,0,.16);
  color: rgba(230,238,248,.74);
}
.suiteHeader__pill--muted{opacity:.9;}
.suiteHeader__tagline{
  margin-top: 6px;
  color: rgba(230,238,248,.68);
  font-size: 15px;
  line-height: 1.25;
  max-width: 980px;
}
.suiteHeader__right{display:flex; align-items:center; gap:12px; flex-shrink:0;}
.suiteHeader__badge{
  width: 54px; height: 54px; border-radius: 999px;
  border: 1px solid rgba(140,170,210,.22);
  background: radial-gradient(circle at 30% 30%, rgba(230,238,248,.10), rgba(0,0,0,.16));
  overflow:hidden;
  box-shadow: 0 10px 22px rgba(0,0,0,.20);
  display:flex; align-items:center; justify-content:center;
}
.suiteHeader__badgeImg{width:100%; height:100%; object-fit:cover; display:block;}
@media (max-width: 700px){
  .suiteHeader{flex-direction:column; align-items:flex-start;}
  .suiteHeader__right{width:100%; justify-content:space-between;}
  .suiteHeader__tagline{max-width: 100%;}
}

  /* Target ↔ Chrono pairing controls (per block) */
  .chronoCtl{display:flex; flex-direction:column; gap:6px; margin-top:8px;}
  .chronoSel{width:180px; max-width:220px; padding:8px 10px; border-radius:12px; background:#0b1426; border:1px solid rgba(255,255,255,.12); color:#e8eefc;}
  .chronoStart{width:100px; padding:8px 10px; border-radius:12px; background:#0b1426; border:1px solid rgba(255,255,255,.12); color:#e8eefc;}


  /* Pairing panel (SM blocks -> Chrono sources) */
  .pairList{display:flex; flex-direction:column; gap:22px; margin-top:10px;}
  .pairRow{display:flex; align-items:center; justify-content:space-between; flex-wrap:wrap; gap:14px;
    padding:14px 14px; border-radius:22px; border:1px solid var(--stroke2);
    background: rgba(10,18,32,.55);
    box-shadow: inset 0 1px 0 rgba(255,255,255,.03);
  }
  .pairLeft{display:flex; align-items:center; flex-wrap:wrap; gap:10px;}
  .pairTitle{font-weight:800; letter-spacing:.2px;}
  .pairMeta{display:flex; gap:8px; flex-wrap:wrap; color: rgba(225,235,248,.78); font-weight:700;}
  .pairMeta .chip{padding:7px 10px; border-radius:999px; border:1px solid var(--stroke2); background: rgba(15,27,42,.55);}
  .pairRight{display:flex; align-items:center; gap:10px; flex:1 1 100%; min-width: 0; justify-content:flex-end; margin-top:10px;}
  
  .pairCtl{display:flex; flex-direction:column; align-items:flex-end; gap:6px; width:100%;}
  .pairCtlLbl{font-size:12px; letter-spacing:.3px; opacity:.65; font-weight:800; text-transform:uppercase;}
.pairRight select{flex: 0 1 320px; min-width: 180px; max-width: 100%; height: 40px !important; max-height:40px !important; padding: 8px 12px !important; line-height: 1.1; font-size:13px; box-sizing:border-box;}
  .pairRight .btnTiny{padding:8px 10px; border-radius:12px; font-weight:800; opacity:.9;}
  .pairRow.warn{border-color: rgba(255,196,87,.35); background: rgba(255,196,87,.06);}


/* Pairing responsive */
@media (max-width: 520px){
  .pairRight{flex:1 1 100%; justify-content:stretch; margin-top:10px;}
  .pairRight select{flex:1 1 100%; max-width:100%; height:40px !important; max-height:40px !important; padding:8px 12px !important; font-size:13px;}
}

  select.sel{height:40px !important; max-height:40px !important; padding:8px 12px !important; font-size:13px;}

  /* Header info icon */
  .hdrInfo{
    display:inline-flex; align-items:center; justify-content:center;
    width:16px; height:16px;
    margin-left:6px;
    border-radius:999px;
    border:1px solid rgba(140,170,210,.28);
    background: rgba(0,0,0,.12);
    color: rgba(230,238,248,.82);
    font-size:11px;
    font-weight:900;
    line-height:1;
    cursor: help;
    opacity:.75;
    transform: translateY(-1px);
  }
  th:hover .hdrInfo{opacity:1; border-color: rgba(77,163,255,.60);}

</style>
</head>
<body>
<div class="wrap">
  
  <header class="suiteHeader">
    <div class="suiteHeader__left">
      <div class="suiteHeader__topline">
        <div class="suiteHeader__title">ShotLedger</div>
        <div class="suiteHeader__pill">v1.5.15</div>
        <div class="suiteHeader__pill suiteHeader__pill--muted">standalone</div>
      </div>
      <div class="suiteHeader__tagline">
        Release gate: ShotMarker fix + UX polish + export validation. Built for 1000-yard reality: vertical is king; velocity is context.
      </div>
    </div>
    <div class="suiteHeader__right">
      <button class="btn small" id="toggleRightBtn" type="button">Hide Kestrel panel</button>
      <div class="suiteHeader__badge" title="Suite mark">
        <img class="suiteHeader__badgeImg" alt="Target" src="data:image/jpeg;base64,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"/>
      </div>
    </div>
  </header>


  <div class="grid" id="grid">
    <div class="leftCol">
<div class="card">
    <div class="panelTitle">
      <h2>Imports</h2>
      <div class="row">
<button class="btn small" id="btnSM" type="button">ShotMarker CSV</button>
        <button class="btn small" id="btnK" type="button">Kestrel CSV</button>
        <button class="btn small" id="btnG" type="button">Add Garmin CSV</button>
        <button class="btn small" id="btnGClear" type="button">Clear Garmin</button>
        <button class="btn small" id="btnAMP" type="button">AMP CSV</button>
        <button class="btn small" id="btnAMPClear" type="button">Clear AMP</button>
        <input class="hidden" id="fileSM" type="file" accept=".csv,text/csv"/>
        <input class="hidden" id="fileK" type="file" accept=".csv,text/csv"/>
        <input class="hidden" id="fileG" type="file" accept=".csv,text/csv" multiple/>
        <input class="hidden" id="fileAMP" type="file" accept=".csv,text/csv"/>
      </div>
    </div>
    <div class="row" id="importPills"></div>
    <div class="status" id="importStatus"></div>
  </div>

  <div class="card" id="phase4ToolsCard">
    <div class="rollupHeader" id="toolsHeader">
          <div>
            <b>Tools</b>
            <div class="meta">Undo, exports, Garmin mapping</div>
          </div>
          <div id="toolsChevron">▸</div>
        </div>
        <div class="rollupBody hidden" id="toolsBody">
          <div class="row miniBtns" style="margin-top:2px;">

        <button class="btn small ghost" id="btnUndo" type="button" title="Undo last state change">Undo</button>
        <button class="btn small" id="btnImportJSON" type="button">Import JSON</button>
        <button class="btn small" id="btnExportCSV" type="button">Export CSV</button>
        <button class="btn small" id="btnExportJSON" type="button">Export JSON</button>
        <button class="btn small ghost" id="btnClearAll" type="button" title="Clear all loaded data">Clear</button>
        <input class="hidden" id="fileJSON" type="file" accept=".json,application/json"/>
      </div>
    <div class="hint">Tip: the <b>ΔVel (σ)</b> chip shows how many SDs a shot’s velocity is from the block mean (record shots). Click the chip to toggle <b>Exclude</b>. Undo restores the last change.

          <div style="margin-top:12px; border-top:1px solid rgba(140,170,210,.12); padding-top:12px;">
<div id="pairingCard" style="margin-top:12px;">
              <div class="rollupHeader" id="pairHeader" aria-expanded="false">
                <div>
                  <b>Pairing</b>
                  <div class="meta" id="pairMetaLine">ShotMarker strings → Chrono sources</div>
                </div>
                <div id="pairChevron">▸</div>
              </div>
              <div class="rollupBody hidden" id="pairBody">
                <div class="hint" style="margin-top:2px;">
                  If files were uploaded out of order, pick the chrono file that belongs to each ShotMarker string. (1:1 by shot index within the string.)
                </div>
                <div class="pairList" id="pairingList"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
  </div>

<div class="card" id="blocksCard" style="margin-bottom:14px;">
      <div class="rollupHeader" id="blocksHeader">
        <div>
          <b>Blocks</b>
          <div class="meta" id="blocksMeta">Rollups, distance, filters</div>
        </div>
        <div id="blocksChevron">▸</div>
      </div>
      <div class="rollupBody hidden" id="blocksBody">
        <div class="row" style="justify-content:flex-end; margin-top:2px;">
          <button class="btn small ghost" id="clearBlockFilterBtn" type="button">Show all</button>
        </div>
      <div class="hint" id="blockHint">Load ShotMarker to see block rollups.</div>
      
      <div class="row" style="margin-top:10px; gap:12px; align-items:flex-end;">
        <div style="min-width:200px;">
          <label style="margin:0 0 6px;">Default distance (yd)</label>
          <input id="defaultDist" type="number" min="10" step="1" value="1000"/>
        </div>
        <div class="hint" style="margin-bottom:2px;">Distance drives MOA + dispersion stats. You can override per block on the right.</div>
      </div>

      <div class="blockList" id="blockRollups" style="margin-top:10px;"></div>
      </div>
    </div>

    </div>

    <div class="rightCol" id="rightCol">
      <div class="card">
        <div class="rollupHeader" id="kHeader">
          <div>
            <b>Kestrel (per-shot)</b>
            <div class="meta" id="kMeta">No file loaded</div>
          </div>
          <div id="kChevron">▾</div>
        </div>
        <div class="rollupBody" id="kBody">
          <div class="two">
            <div>
              <label>Alignment mode</label>
              <select id="alignMode">
                <option value="anchors" selected>Anchors (2-point map)</option>
              </select>
            </div>
            <div>
              <label>Tolerance</label>
              <select id="tolSel">
                <option value="5">±5s</option>
                <option value="10" selected>±10s</option>
                <option value="15">±15s</option>
                <option value="30">±30s</option>
                <option value="60">±60s</option>
              </select>
            </div>
          </div>

          <div class="two">
            <div>
              <label>Session date (for anchors)</label>
              <input id="sessionDate" type="date"/>
            </div>
            <div>
              <label>Join</label>
              <select id="joinMode">
                <option value="nearest" selected>Nearest sample</option>
              </select>
            </div>
          </div>

          <div class="two">
            <div>
              <label>Anchor A shot #</label>
              <input id="aShot" type="number" min="1" value="1"/>
            </div>
            <div>
              <label>Anchor A time (HH:MM:SS)</label>
              <input id="aTime" type="text" value="19:28:10" placeholder="19:28:10"/>
            </div>
          </div>

          <div class="two">
            <div>
              <label>Anchor B shot #</label>
              <input id="bShot" type="number" min="1" value="60"/>
            </div>
            <div>
              <label>Anchor B time (HH:MM:SS)</label>
              <input id="bTime" type="text" value="19:41:55" placeholder="19:41:55"/>
            </div>
          </div>

          <div class="kbtns">
            <button class="btn small" id="applyBtn" type="button">Apply Kestrel to shots</button>
            <button class="btn small ghost" id="clearBtn" type="button">Clear Kestrel fields</button>
            <button class="btn small" id="autofitBtn" type="button">Auto-fit anchors to Kestrel range (demo)</button>
            <button class="btn small ghost" id="dateFromSMBtn" type="button">Set session date from ShotMarker</button>
          </div>

          <div class="status" id="kStatus"></div>
        </div>
        <!-- Tools moved to main column -->
          <!-- Garmin mapping moved to main column -->
</div>
<div class="card" id="manualCard" style="margin-top:14px;">
        <div class="rollupHeader" id="manHeader">
          <div>
            <b>Manual inputs</b>
            <div class="meta">Apply to selected shots or a whole string</div>
          </div>
          <div id="manChevron">▸</div>
        </div>
        <div class="rollupBody hidden" id="manBody">
          <div class="row" style="gap:10px; align-items:center; flex-wrap:wrap; margin-top:2px;">
            <button class="btn" id="btnApplySelected" type="button">Apply to selected</button>
            <span class="pill" id="selCountPill">Selected: 0</span>
          </div>

          <div style="margin-top:10px;">
            <label>— Select string —</label>
            <select id="manBlockSel"></select>
          </div>

          <div class="row" style="gap:10px; align-items:center; flex-wrap:wrap; margin-top:10px;">
            <button class="btn" id="btnApplyToString" type="button">Apply to string</button>
            <button class="btn ghost" id="btnClearSelection" type="button">Clear selection</button>
          </div>

          <div style="margin-top:12px;">
            <label>Primer Seat (in)</label>
            <input id="manPrimerSeat" type="number" step="0.0001" placeholder="e.g. 0.0035"/>
          </div>

          <div style="margin-top:10px;">
            <label>Wind Zero Δ (MOA)</label>
            <input id="manWindZero" type="number" step="0.01" placeholder="e.g. +0.25"/>
          </div>

          <div style="margin-top:10px;">
            <label>Elev Zero Δ (MOA)</label>
            <input id="manElevZero" type="number" step="0.01" placeholder="e.g. -0.10"/>
          </div>

          <div style="margin-top:10px;">
            <label>Wind Call</label>
            <input id="manWindCall" type="text" placeholder="e.g. hold 0.5L, 6–10mph"/>
          </div>

          <div style="margin-top:10px;">
            <label>Notes</label>
            <textarea id="manNotes" rows="6" style="width:100%; resize:vertical;" placeholder="free text (trigger, bag, mirage, condition change, mental note, etc.)"></textarea>
          </div>

          <div class="hint" style="margin-top:10px;">Saved in Export JSON.</div>
          <div class="status" id="manStatus"></div>
        </div>
      </div>


      </div>
    </div>
  </div>

<div class="card tableCard">
        <div class="tableHead">
          <div class="panelTitle" style="margin:0;">
            <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; width:100%;">
              <h2 style="margin:0;">Shot list (first 200)</h2>
              <div class="row" style="gap:8px; align-items:center;">
                <button class="btn small ghost" id="btnDense" type="button" title="Toggle dense row spacing">Dense</button>
              </div>
            </div>
            <div class="hint">Tip: click a column header to sort; scroll horizontally inside the table to see all Kestrel columns.</div>
          </div>
        </div>
        <div class="tableWrap" id="tableWrap">
          <table id="shotTable">
            <thead>
              <tr>
                <th class="sticky c0">Sel</th>
                <th class="sticky c1" data-sort="idx">#</th>
                <th class="sticky c2" data-sort="block">Block</th>
                <th class="sticky c3" data-sort="state">State</th>
                <th data-sort="relTime">Rel time</th>
                <th>Tag</th>
                <th data-sort="score">Score</th>
                <th data-sort="vel">Vel</th>
                <th data-sort="velSrc">Vel Src</th>
      <th title="AMP Peak force (from AMP press).">AMP Peak</th>
      <th title="AMP Work/area under force curve (consistency signal).">AMP Work</th>
      <th title="AMP anomaly score: max(|z|) across Peak/Work/Start metrics.">AMP Δ(σ) <span class="hdrInfo" title="AMP Δ(σ) = max(|z|) across AMP Peak / Work / Start.&#10;Colors: ≤0.7σ node-solid • 0.7–1.3σ normal noise • 1.3–1.9σ eyebrow raise • ≥1.9σ real outlier.&#10;Hover each chip for per-metric z-scores.">ⓘ</span></th>
                <th data-sort="dsigma" title="ΔVel (σ) = (shot velocity − block mean) / block SD (record shots only). Click chip to toggle Exclude.">ΔVel (σ) <span class="hdrInfo" title="ΔVel (σ) = |shot vel − string avg| / string SD using the active velocity source (Garmin if present else SM).&#10;≤0.7σ solid • 0.7–1.3σ normal noise • 1.3–1.9σ eyebrow raise • ≥1.9σ real outlier.">ⓘ</span></th>
                <th data-sort="xIn">X (in)</th>
                <th data-sort="yIn">Y (in)</th>
                <th data-sort="hMoa">H (MOA)</th>
                <th data-sort="vMoa">V (MOA)</th>
                <th data-sort="rMoa">R (MOA)</th>
                <th data-sort="kTime">Kestrel time</th>
                <th data-sort="join">Join</th>
                <th data-sort="kdt">Δt (s)</th>
                <th data-sort="crosswind">Crosswind</th>
                <th data-sort="headwind">Headwind</th>
                <th data-sort="windSpeed">Wind spd</th>
                <th data-sort="trueDir">Dir (true)</th>
                <th data-sort="temp">Temp</th>
                <th data-sort="rh">RH</th>
                <th data-sort="stationP">Station P</th>
                <th data-sort="da">DA</th>
                <th data-sort="primerSeat">Primer (in)</th>
                <th data-sort="windZero">Wind0 Δ</th>
                <th data-sort="elevZero">Elev0 Δ</th>
                <th data-sort="windCall">Wind Call</th>
                <th data-sort="notes">Notes</th>
              </tr>
            </thead>
            <tbody id="shotTbody"></tbody>
          </table>
        </div>
      </div>
    </div>

    

</div>

<script>
(() => {
  // ---------- state ----------
  let smShots = [];   // {idx, block, relTime, tag, score, vel, blockDate}
  let smBlocks = [];  // {label, dateStr, n}
  let kSamples = [];  // {tEpoch, formatted, crosswind, headwind, windSpeed, trueDir, temp, rh, stationP, da}
  let kRange = null;  // {minEpoch,maxEpoch,minStr,maxStr}
  let smFirstDate = null;

  let selectedShots = new Set(); // shot idx
  const chronoPair = new Map(); // block -> {name, start}

  // ---------- Chrono pairing UI heuristics ----------
  function shouldShowChronoControls(){
    // Show manual controls only when needed (mismatched counts or missing files).
    if(!smBlocks || !smBlocks.length) return false;
    if(!gFiles || !gFiles.length) return false;
    if(gFiles.length !== smBlocks.length) return true;

    // If shot counts per block don't match the corresponding Garmin file, allow manual selection.
    // (We still auto-pair by order; this just exposes controls for correction.)
    const groups = groupByBlock();
    for(let i=0;i<smBlocks.length;i++){
      const blk = smBlocks[i].label;
      const list = groups.get(blk) || [];
      const gf = gFiles[i];
      const gcount = (gf && gf.shots) ? gf.shots.length : 0;
      if(gcount && list.length && gcount !== list.length) return true;
    }
    return false;
  }

  function autoPairChronoByOrder(){
    if(!smBlocks || !smBlocks.length) return;
    if(!gFiles || !gFiles.length) return;
    // Only auto-pair when counts line up 1:1.
    if(gFiles.length !== smBlocks.length) return;

    for(let i=0;i<smBlocks.length;i++){
      const blk = smBlocks[i].label;
      const gf = gFiles[i];
      if(!gf) continue;
      if(!chronoPair.has(blk)){
        chronoPair.set(blk, {name: gf.name, start: 1});
      } else {
        // preserve existing, but fill missing fields
        const cur = chronoPair.get(blk) || {};
        if(!cur.name) cur.name = gf.name;
        if(!cur.start) cur.start = 1;
        chronoPair.set(blk, cur);
      }
    }

    // Pairing panel (SM strings ↔ chrono sources)
    renderPairingPanel();
  }

  // ---------- Phase 5.1: geometry (MOA + dispersion) ----------
  let defaultDistYd = 1000;
  const blockDist = new Map(); // block -> distance yd
  let blockAutoDist = new Map(); // block -> ShotMarker-provided distance (auto)
  let geoStats = new Map(); // block -> {distYd, n, horizESmoa, vertESmoa, radialESmoa, mrMoa}

  let gFiles = [];    // [{name, shots:[{idx, vel, timeSec}], startIdx}]
  let ampSession = null; // {name, map: Map(traceNum->obj), stats}
  let undo = null;     // {shotIdx, prevState}
  let blockStats = new Map();
  let tableSort = { key: 'idx', dir: 1 }; // Phase 5.4.4




  // ---------- Phase 5.4.7: Clear + JSON Import ----------
  function clearAll(){
    smShots = [];
    smBlocks = [];
    activeBlock = null;
    smFirstDate = null;

    // reset distances
    defaultDistYd = 1000;
    blockDist.clear();
    blockAutoDist.clear();
    geoStats = new Map();
    blockStats = new Map();

    // reset kestrel
    kSamples = [];
    kRange = null;
    ampSession = null;
    if(kMeta) kMeta.textContent = 'No file loaded';

    // reset garmin
    gFiles = [];
    undo = null;

    // reset AMP
    ampSession = null;

    // clear file inputs so re-select works
    const fsm = el('fileSM'); if(fsm) fsm.value = '';
    const fk  = el('fileK');  if(fk) fk.value = '';
    const fg  = el('fileG');  if(fg) fg.value = '';
    const fa = el('fileAMP'); if(fa) fa.value = '';
    const fj  = el('fileJSON'); if(fj) fj.value = '';

    // UI resets
    setPills(null, null, null);
    if(importStatus) importStatus.innerHTML = `<span class="hint">Cleared. Import a ShotMarker CSV or JSON to begin.</span>`;
    if(kStatus) kStatus.innerHTML = '';
    if(blocksMeta){ blocksMeta.textContent = 'Rollups, distance, filters'; blocksMeta.title=''; }
    if(el('blockHint')) el('blockHint').textContent = 'Load ShotMarker or JSON to see block rollups.';
    if(el('defaultDist')) el('defaultDist').value = defaultDistYd;

    renderGarminMapping();
    renderBlockRollups();
    renderTable();
    if(el('importStatus')) el('importStatus').innerHTML = `<span class=\"good\">Cleared.</span>`;
  }

  function escA(s){
    return String(s==null?'':s)
      .replace(/&/g,'&amp;')
      .replace(/"/g,'&quot;')
      .replace(/</g,'&lt;')
      .replace(/>/g,'&gt;');
  }

  function renderPairingPanel(){
    const card = el('pairingCard');
    const listEl = el('pairingList');
    const metaEl = el('pairMetaLine');
    if(!card || !listEl) return;

    if(!smBlocks || !smBlocks.length){
      card.style.display = 'none';
      return;
    }
    card.style.display = '';

    const gcount = (gFiles && gFiles.length) ? gFiles.length : 0;
    if(metaEl){
      const base = 'ShotMarker strings → Chrono sources';
      metaEl.textContent = gcount ? `${base} • ${smBlocks.length} strings • ${gcount} chrono files` : base;
    }

    if(!gcount){
      listEl.innerHTML = `<div class="hint">Load chrono/Garmin files to enable pairing.</div>`;
      return;
    }

    const groups = groupByBlock();
    const optHtml = ['<option value="">— Select chrono file —</option>']
      .concat(gFiles.map(g=>`<option value="${escA(g.name)}">${esc(g.name)} (${(g.shots&&g.shots.length)||0})</option>`))
      .join('');

    const rows = [];
    for(let i=0;i<smBlocks.length;i++){
      const blk = smBlocks[i].label;
      const shots = groups.get(blk) || [];
      const total = shots.length;
      let rec=0, sighters=0;
      for(const sh of shots){
        const st = (sh.state||'RECORD');
        if(st==='SIGHTER') sighters++;
        else if(st==='RECORD') rec++;
      }
      const vs = blockStats.get(blk) || computeVelStats(shots);
      const mean = (vs.mean!=null && Number.isFinite(vs.mean)) ? Math.round(vs.mean) : '—';
      const sd = (vs.sd!=null && Number.isFinite(vs.sd)) ? vs.sd.toFixed(1) : '—';
      const es = (vs.es!=null && Number.isFinite(vs.es)) ? Math.round(vs.es) : '—';

      const cur = chronoPair.get(blk);
      const selName = cur && cur.name ? cur.name : '';

      // warn styling if mismatch counts exist
      let warn = '';
      if(selName){
        const gf = gFiles.find(g=>g.name===selName);
        const gshots = gf ? ((gf.shots&&gf.shots.length)||0) : 0;
        if(total && gshots && gshots !== total) warn = ' warn';
      }

      rows.push(`
        <div class="pairRow${warn}">
          <div class="pairLeft">
            <span class="pill">${esc(blk)}</span>
            <div class="pairMeta">
              <span class="chip">shots: ${rec}</span>
              <span class="chip">sighters: ${sighters}</span>
              <span class="chip">avg ${mean}</span>
              <span class="chip">SD ${sd}</span>
              <span class="chip">ES ${es}</span>
            </div>
          </div>
          <div class="pairRight"><div class="pairCtl"><div class="pairCtlLbl">Chrono file</div><select class="sel" data-pair-block="${escA(blk)}">${optHtml}</select></div></div>
        </div>
      `);
    }
    listEl.innerHTML = rows.join('');

    // apply selections + bind changes
    const sels = listEl.querySelectorAll('select[data-pair-block]');
    sels.forEach(sel=>{
      const blk = sel.getAttribute('data-pair-block') || '';
      const cur = chronoPair.get(blk);
      sel.value = (cur && cur.name) ? cur.name : '';

      sel.addEventListener('change', ()=>{
        const name = sel.value || '';
        if(name){
          chronoPair.set(blk, {name, start: 1});
        } else {
          chronoPair.delete(blk);
        }
        const res = smShots.length ? applyGarminToShots() : {matched:0, overrides:0, unmapped:0, extra:0};
        recomputeBlockStats();
        recomputeGeoStats();
        renderBlockRollups();
        renderTable();
        renderPairingPanel();

        const st = el('gStatus');
        if(st){
          st.innerHTML = `<span class="good">Pairings updated.</span> Matched ${res.matched} • Overrides ${res.overrides}`;
        }
      });
    });
  }


function importFromJSON(txt, name){
    const data = JSON.parse(txt);

    if(!data || !Array.isArray(data.shots)){
      throw new Error('Invalid ShotLedger JSON (missing shots[]).');
    }

    // Clear first (but keep rollups collapsed state etc.)
    smShots = [];
    smBlocks = [];
    activeBlock = (data.ui && data.ui.activeBlock) ? data.ui.activeBlock : null;

    // UI defaults
    defaultDistYd = (data.ui && Number.isFinite(+data.ui.defaultDistYd)) ? +data.ui.defaultDistYd : 1000;
    if(el('defaultDist')) el('defaultDist').value = defaultDistYd;

    // Restore per-block chrono pairings (optional)
    chronoPair.clear();
    if(data.ui && Array.isArray(data.ui.chronoPairings)){
      for(const p of data.ui.chronoPairings){
        if(!p || !p.block) continue;
        chronoPair.set(p.block, {name: p.name||'', start: (p.start!=null ? Number(p.start) : 1)});
      }
    }

    // Clear any selection
    selectedShots.clear();
    updateSelPill();

    // Restore distances per block
    blockDist.clear();
    blockAutoDist.clear();
    if(Array.isArray(data.blocks)){
      for(const b of data.blocks){
        if(!b || !b.block) continue;
        const dist = b.distance || {};
        if(dist && Number.isFinite(+dist.manualYd) && +dist.manualYd>0){
          blockDist.set(b.block, +dist.manualYd);
        }
        if(dist && Number.isFinite(+dist.shotMarkerYd) && +dist.shotMarkerYd>0){
          blockAutoDist.set(b.block, +dist.shotMarkerYd);
        }
      }
    }

    // Restore shots
    for(const s of data.shots){
      if(!s) continue;
      const sh = {
        idx: Number(s.idx),
        block: s.block || '(unknown)',
        blockDate: s.blockDate || '',
        relTime: s.relTime || '',
        tag: s.tag || '',
        score: s.score || '',
        vel: (s.velSM!=null ? String(s.velSM) : (s.vel!=null ? String(s.vel) : '')),
        velSM: (s.velSM!=null && Number.isFinite(+s.velSM)) ? +s.velSM : null,
        velActive: (s.velActive!=null && Number.isFinite(+s.velActive)) ? +s.velActive : ((s.velSM!=null && Number.isFinite(+s.velSM)) ? +s.velSM : null),
        velSrc: s.velSrc || 'SM',
        // manual inputs (optional)
        primerSeat: (s.primerSeat!=null && Number.isFinite(+s.primerSeat)) ? +s.primerSeat : null,
        windZero: (s.windZero!=null && Number.isFinite(+s.windZero)) ? +s.windZero : null,
        elevZero: (s.elevZero!=null && Number.isFinite(+s.elevZero)) ? +s.elevZero : null,
        windCall: s.windCall || null,
        notes: s.notes || null,
        // geometry
        xIn: (s.xIn!=null && Number.isFinite(+s.xIn)) ? +s.xIn : null,
        yIn: (s.yIn!=null && Number.isFinite(+s.yIn)) ? +s.yIn : null,
        hMoa: (s.hMoa!=null && Number.isFinite(+s.hMoa)) ? +s.hMoa : null,
        vMoa: (s.vMoa!=null && Number.isFinite(+s.vMoa)) ? +s.vMoa : null,
        rMoa: (s.rMoa!=null && Number.isFinite(+s.rMoa)) ? +s.rMoa : null,
        // AMP (optional)
        ampPeak: (s.ampPeak!=null && Number.isFinite(+s.ampPeak)) ? +s.ampPeak : null,
        ampWork: (s.ampWork!=null && Number.isFinite(+s.ampWork)) ? +s.ampWork : null,
        ampStartPos: (s.ampStartPos!=null && Number.isFinite(+s.ampStartPos)) ? +s.ampStartPos : null,
        ampZ: (s.ampZ!=null && Number.isFinite(+s.ampZ)) ? +s.ampZ : null,
        ampZPeak: (s.ampZPeak!=null && Number.isFinite(+s.ampZPeak)) ? +s.ampZPeak : null,
        ampZWork: (s.ampZWork!=null && Number.isFinite(+s.ampZWork)) ? +s.ampZWork : null,
        ampZStart: (s.ampZStart!=null && Number.isFinite(+s.ampZStart)) ? +s.ampZStart : null,
        // state + provenance
        state: s.state || 'RECORD',
        stateSrc: s.stateSrc || '',
        // kestrel (optional)
        j: s.j || s.join || null,
        kdt: (s.kdt!=null && Number.isFinite(+s.kdt)) ? +s.kdt : (s.dt!=null && Number.isFinite(+s.dt) ? +s.dt : null),
        k: s.k || null
      };
      smShots.push(sh);
    }

    // Rebuild blocks list
    const seen = new Map();
    for(const sh of smShots){
      if(!seen.has(sh.block)) seen.set(sh.block, {label: sh.block, dateStr: sh.blockDate || '', n: 0, distYdAuto: blockAutoDist.get(sh.block) || null});
      seen.get(sh.block).n += 1;
    }
    smBlocks = Array.from(seen.values());

    // Attempt to set first date (for Kestrel date helper)
    smFirstDate = null;
    for(const b of smBlocks){
      const dt = parseSMDateStr(b.dateStr);
      if(dt){ smFirstDate = dt; break; }
    }

    // Pills/status
    setPills(name || 'ShotLedger JSON', (kSamples.length? (kMeta.textContent||'Kestrel loaded') : null),
             (gFiles.length ? gFiles.map(g=>({name:g.name,count:(g.shots?g.shots.length:0)})) : null));
    importStatus.innerHTML = `<span class="good">Imported JSON.</span> <span class="hint">Shots: <b>${smShots.length}</b> • Blocks: <b>${smBlocks.length}</b></span>`;

    // Recompute derived stats to ensure everything is coherent (MOA will be recomputed if coords exist)
    recomputeBlockStats();
    recomputeGeoStats();
    renderBlockRollups();
    renderTable();
  }

  const el = (id)=>document.getElementById(id);

  // --- Minimal UI helpers (some builds call these) ---
  function toast(msg){
    try{
      const s = el('importStatus') || el('kStatus') || el('manStatus');
      if(s){
        s.textContent = String(msg ?? '');
      }else{
        console.log(msg);
      }
    }catch(_e){
      console.log(msg);
    }
  }

  // Central re-render hook used by importers
  function render(){
    try{ renderPairingPanel && renderPairingPanel(); }catch(_e){}
    try{ renderGarminMapping && renderGarminMapping(); }catch(_e){}
    try{ renderBlockRollups && renderBlockRollups(); }catch(_e){}
    try{ renderSummaries && renderSummaries(); }catch(_e){}
    try{ renderTable && renderTable(); }catch(_e){}
  }

  function updateSelPill(){
    const p = el('selCountPill');
    if(p) p.textContent = `Selected: ${selectedShots.size||0}`;
  }

  function manualPayload(){
    const numOrNull = (v)=>{
      if(v==null) return null;
      const s = String(v).trim();
      if(!s) return null;
      const n = Number(s);
      return Number.isFinite(n) ? n : null;
    };
    const strOrNull = (v)=>{
      const s = (v==null) ? '' : String(v).trim();
      return s ? s : null;
    };
    return {
      primerSeat: numOrNull(el('manPrimerSeat') && el('manPrimerSeat').value),
      windZero: numOrNull(el('manWindZero') && el('manWindZero').value),
      elevZero: numOrNull(el('manElevZero') && el('manElevZero').value),
      windCall: strOrNull(el('manWindCall') && el('manWindCall').value),
      notes: strOrNull(el('manNotes') && el('manNotes').value)
    };
  }

  function applyManualToShots(shots){
    const p = manualPayload();
    const changed = {n:0};
    for(const sh of shots){
      if(p.primerSeat!=null) sh.primerSeat = p.primerSeat;
      if(p.windZero!=null) sh.windZero = p.windZero;
      if(p.elevZero!=null) sh.elevZero = p.elevZero;
      if(p.windCall!=null) sh.windCall = p.windCall;
      if(p.notes!=null) sh.notes = p.notes;
      changed.n++;
    }
    return {p, changed:changed.n};
  }

  function applyChronoPairings(){
    if(!smShots.length || !gFiles.length) return {blocks:0, mapped:0, missing:0};
    let blocks=0, mapped=0, missing=0;

    // helper: lookup gFile by name
    const byName = new Map(gFiles.map(g=>[g.name, g]));
    const groups = groupByBlock();

    const showChronoCtl = shouldShowChronoControls();
    for(const [block, list] of groups.entries()){
      const pair = chronoPair.get(block);
      if(!pair || !pair.name) continue;
      const g = byName.get(pair.name);
      if(!g || !g.shots || !g.shots.length){ missing += list.length; continue; }
      blocks++;
      const start = Math.max(1, Number(pair.start||1)) - 1;
      // map in shot index order
      const ordered = [...list].sort((a,b)=>a.idx-b.idx);
      for(let i=0;i<ordered.length;i++){
        const sh = ordered[i];
        const gi = start + i;
        const gs = g.shots[gi];
        const v = gs && Number.isFinite(gs.vel) ? gs.vel : null;
        if(v!=null){
          sh.velG = v;
          sh.velActive = v;
          sh.velSrc = 'GARMIN';
          mapped++;
        } else {
          // fall back to SM
          sh.velG = null;
          sh.velActive = (sh.velSM!=null ? sh.velSM : null);
          sh.velSrc = 'SM';
        }
      }
    }
    recomputeBlockStats();
    renderBlockRollups();
    renderTable();
    return {blocks, mapped, missing};
  }

  const importPills = el('importPills');
  const importStatus = el('importStatus');
  const shotTbody = el('shotTbody');
  const kStatus = el('kStatus');
  const blocksMeta = el('blocksMeta');
  const kMeta = el('kMeta');
  const kBody = el('kBody');
  const kChevron = el('kChevron');
  const rightCol = el('rightCol');
  const gridEl = el('grid');
  const toggleRightBtn = el('toggleRightBtn');
  // ---------- rollup helpers (Tools / Blocks) ----------
  function wireRollup(headerEl, bodyEl, chevronEl, startCollapsed=false){
    if(!headerEl || !bodyEl || !chevronEl) return;
    const set = (collapsed)=>{
      bodyEl.classList.toggle('hidden', collapsed);
      chevronEl.textContent = collapsed ? '▸' : '▾';
      headerEl.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
    };
    set(!!startCollapsed);
    headerEl.addEventListener('click', ()=> set(!bodyEl.classList.contains('hidden')));
  }

  wireRollup(el('toolsHeader'), el('toolsBody'), el('toolsChevron'), true);
  wireRollup(el('pairHeader'), el('pairBody'), el('pairChevron'), true);
  wireRollup(el('blocksHeader'), el('blocksBody'), el('blocksChevron'), true);
  wireRollup(el('manHeader'), el('manBody'), el('manChevron'), true);


  function setPills(smName, kName, gList){
    // gList: array of {name, count} or strings
    importPills.innerHTML = '';
    if(smName){
      const p = document.createElement('div'); p.className='pill';
      p.innerHTML = `<span class="good">ShotMarker</span> <span style="opacity:.8;">•</span> <span style="opacity:.9;white-space:nowrap;max-width:520px;">${esc(smName)}</span>`;
      importPills.appendChild(p);
    }
    if(kName){
      const p = document.createElement('div'); p.className='pill';
      p.innerHTML = `<span class="good">Kestrel</span> <span style="opacity:.8;">•</span> <span style="opacity:.9;white-space:nowrap;max-width:520px;">${esc(kName)}</span>`;
      importPills.appendChild(p);
    }
    const arr = Array.isArray(gList) ? gList : (gList ? [gList] : []);
    for(const gi of arr){
      const name = (typeof gi === 'string') ? gi : (gi && gi.name ? gi.name : '');
      if(!name) continue;
      const count = (typeof gi === 'object' && gi && typeof gi.count==='number') ? gi.count : null;
      const p = document.createElement('div'); p.className='pill';
      p.innerHTML = `<span class="good">Garmin</span> <span style="opacity:.8;">•</span> <span style="opacity:.9;white-space:nowrap;max-width:520px;">${esc(name)}</span>${count!=null ? ` <span style="opacity:.7;">•</span> <span style="opacity:.85;">${count} shots</span>`:''}`;
      importPills.appendChild(p);
    }
  }

  function esc(s){ return (s||'').replace(/[&<>"]/g, c=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;" }[c])); }

  function formatVel(vActive, vFallback){
    const v = (vActive!=null && Number.isFinite(vActive) && vActive>0) ? vActive : null;
    if(v!=null) return Math.round(v).toString();
    const n = parseFloat(String(vFallback||'').trim());
    return Number.isFinite(n) ? Math.round(n).toString() : esc(vFallback||'');
  }


  function inferStateFromTag(tag){
    const t = String(tag||'').toLowerCase();
    if(/sight/.test(t) || /\bsgt\b/.test(t) || /\bsighter\b/.test(t)) return 'SIGHTER';
    return 'RECORD';
  }

  function stateCell(sh){
    const st = (sh && sh.state) ? sh.state : 'RECORD';
    const a = (st==='RECORD') ? 'active' : '';
    const b = (st==='SIGHTER') ? 'active' : '';
    const c = (st==='EXCLUDE') ? 'active' : '';
    const src = (sh.stateSrc||"");
    const extra = (st==="EXCLUDE" ? (src==="FLAG" ? " (exclude: flag)" : (src ? ` (exclude: ${src.toLowerCase()})` : " (exclude: manual)")) : (st==="SIGHTER" ? (src==="TAG" ? " (sighter: tag)" : (src ? ` (sighter: ${src.toLowerCase()})` : "")) : ""));
    return `<div class="stateCtl" title="Shot state: Record counts in stats; Sighter + Exclude do not.${extra}">
      <button class="sbtn rec ${a}" data-idx="${sh.idx}" data-state="RECORD" type="button">R</button>
      <button class="sbtn sgt ${b}" data-idx="${sh.idx}" data-state="SIGHTER" type="button">S</button>
      <button class="sbtn exc ${c}" data-idx="${sh.idx}" data-state="EXCLUDE" type="button">\u2715</button>
    </div>`;
  }


  
  function ampPill(sh){
    if(!sh) return '';
    const z = sh.ampZ;
    if(z==null || !Number.isFinite(z)) return '';
    const az = Math.abs(z);

    // Determine which metric drove the max anomaly
    const cand = [
      {k:'Peak', z: sh.ampZPeak},
      {k:'Work', z: sh.ampZWork},
      {k:'Start', z: sh.ampZStart},
    ].filter(o => o.z!=null && Number.isFinite(o.z));
    let top = {k:'', z:null};
    for(const o of cand){
      if(top.z==null || Math.abs(o.z) > Math.abs(top.z)) top = o;
    }

    // Match ΔVel chip styling thresholds
    let cls = 'flagchip ok';
    if(az>1.9) cls='flagchip bad';
    else if(az>1.3) cls='flagchip problem';
    else if(az>0.7) cls='flagchip warn';

    const zpk = (sh.ampZPeak!=null && Number.isFinite(sh.ampZPeak)) ? (sh.ampZPeak>=0?'+':'')+sh.ampZPeak.toFixed(2) : '—';
    const zwk = (sh.ampZWork!=null && Number.isFinite(sh.ampZWork)) ? (sh.ampZWork>=0?'+':'')+sh.ampZWork.toFixed(2) : '—';
    const zst = (sh.ampZStart!=null && Number.isFinite(sh.ampZStart)) ? (sh.ampZStart>=0?'+':'')+sh.ampZStart.toFixed(2) : '—';

    const tip = `AMP anomaly = max(|z|) across metrics (this shot). ` +
                `Driver: ${top.k||'—'} (|z|=${az.toFixed(2)}σ)\n` +
                `Peak z=${zpk}σ, Work z=${zwk}σ, Start z=${zst}σ`;
    return `<span class="${cls}" title="${escA(tip)}">${az.toFixed(1)}σ</span>`;
  }

function joinPill(status){
    const s = String(status||'').toUpperCase();
    if(!s) return '';
    let cls = 'muted', label = s;
    if(s==='JOIN'){ cls='ok'; label='JOIN'; }
    else if(s==='MISS'){ cls='warn'; label='MISS'; }
    else if(s==='OUT'){ cls='muted'; label='OUT'; }
    else if(s==='BADMAP' || s==='BAD'){ cls='bad'; label='BAD'; }
    return `<span class="joinpill ${cls}">${esc(label)}</span>`;
  }

  // ---------- utilities ----------
  function parseHMS(s){
    // "19:28:10"
    const m = String(s||'').trim().match(/^(\d{1,2}):(\d{2})(?::(\d{2}))?$/);
    if(!m) return null;
    const hh = +m[1], mm=+m[2], ss=+(m[3]||0);
    if(hh>23||mm>59||ss>59) return null;
    return hh*3600 + mm*60 + ss;
  }
  function parseSMDateStr(dateStr){
    // Supports ShotMarker archive headers like "Sep 25 2025" OR "12/27/2025"
    const s = String(dateStr||'').trim();
    // "Sep 25 2025"
    let m = s.match(/^([A-Za-z]{3})\s+(\d{1,2})\s+(\d{4})$/);
    if(m){
      const mon = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"].indexOf(m[1]);
      if(mon<0) return null;
      const d = +m[2], y=+m[3];
      const dt = new Date(Date.UTC(y, mon, d, 0,0,0));
      return isNaN(dt.getTime()) ? null : dt;
    }
    // "12/27/2025" (MM/DD/YYYY)
    m = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
    if(m){
      const mo = +m[1], d = +m[2], y = +m[3];
      const dt = new Date(Date.UTC(y, mo-1, d, 0,0,0));
      return isNaN(dt.getTime()) ? null : dt;
    }
    return null;
  }

  function parseDistanceYdFromBlockHeader(parts){
    // parts: CSV fields from a block header line, e.g. ["Sep 25 2025","R3","#227 (HWW)","1000yd", ...]
    // ShotMarker exports vary; this tries multiple common patterns.
    const joined = parts.map(p=>String(p||'').trim()).join(' ').replace(/\s+/g,' ').trim();

    // Explicit "####yd" / "#### yd" / "yards"
    let mm = joined.match(/\b(\d{2,4})\s*(yd|yard|yards)\b/i);
    if(mm){
      const n = Number(mm[1]);
      if(Number.isFinite(n) && n>=25 && n<=2500) return n;
    }

    // Explicit meters: "####m"
    mm = joined.match(/\b(\d{2,4})\s*m\b/i);
    if(mm){
      const n = Number(mm[1]);
      if(Number.isFinite(n) && n>=25 && n<=3000){
        return n / 0.9144; // meters -> yards
      }
    }

    // Keyed fields: "Distance", "Range"
    for(let i=0;i<parts.length-1;i++){
      const key = String(parts[i]||'').toLowerCase();
      if(key.includes('distance') || key.includes('range')){
        const val = String(parts[i+1]||'').trim();
        let m2 = val.match(/^(\d{2,4})(?:\s*(yd|yard|yards))?$/i);
        if(m2){
          const n = Number(m2[1]);
          if(Number.isFinite(n) && n>=25 && n<=2500) return n;
        }
        m2 = val.match(/^(\d{2,4})\s*m$/i);
        if(m2){
          const n = Number(m2[1]);
          if(Number.isFinite(n) && n>=25 && n<=3000) return n/0.9144;
        }
      }
    }

    // Fallback: a lone plausible distance token (avoid #227 etc by requiring not preceded by '#')
    const tokens = joined.split(/[^0-9]+/).filter(Boolean).map(Number).filter(n=>Number.isFinite(n));
    // Prefer common match distances if present
    const common = [100,200,300,600,800,900,1000,1200,1400,1760];
    for(const c of common){
      if(tokens.includes(c)) return c;
    }
    // Otherwise pick the largest plausible (often distance is the largest number in header aside from year)
    const filtered = tokens.filter(n=>n>=25 && n<=2500 && n!==2024 && n!==2025 && n!==2026);
    if(filtered.length){
      return Math.max(...filtered);
    }
    return null;
  }

  function dateToISO(d){
    const y = d.getUTCFullYear();
    const m = String(d.getUTCMonth()+1).padStart(2,'0');
    const da = String(d.getUTCDate()).padStart(2,'0');
    return `${y}-${m}-${da}`;
  }
  function epochFromLocal(dateISO, secondsSinceMidnight){
    // Treat as local time (browser). Kestrel timestamps are local formatted as string; we parse them as local too.
    const [y,m,d] = dateISO.split('-').map(Number);
    const base = new Date(y, m-1, d, 0,0,0,0).getTime()/1000;
    return base + secondsSinceMidnight;
  }

  // ---------- ShotMarker archive parser ----------
  function stripBOM(s){ return String(s||'').replace(/^\ufeff+/,''); }

  // ---------- ShotMarker parser (archive OR single-session CSV) ----------
  function parseShotMarkerArchive(text){
    const raw = String(text||'');
    const lines = raw.split(/\r?\n/);

    const blocks = [];
    const shots = [];
    let curBlock = null;
    let inShots = false;
    let shotIdx = 0;

    for(let i=0;i<lines.length;i++){
      const lineRaw = lines[i];
      const line = stripBOM(lineRaw);
      if(!line || !line.trim()) continue;

      const parts = splitCSV(line);

      // Block header: "Sep 25 2025,R3,#227 (HWW),..." OR "12/27/2025,R1,..."
      const p0 = stripBOM(parts[0]||'').trim();
      const p1 = String(parts[1]||'').trim();
      if(parts.length>=2 && parseSMDateStr(p0) && /^R\d+/i.test(p1)){
        const dateStr = p0;
        const round = p1.toUpperCase();
        const label = `${dateStr} ${round}`;
        const distYd = parseDistanceYdFromBlockHeader(parts);
        curBlock = { label, dateStr, n:0, distYdAuto: distYd };
        blocks.push(curBlock);
        inShots = false;
        continue;
      }

      // Header line inside block (ShotMarker variations may have whitespace/quotes/BOM/case)
      const low = line.trimStart().toLowerCase();
      if(curBlock && (low.startsWith(',time,') || low.startsWith('"",time,') || low.startsWith(', time,'))){
        inShots = true;
        continue;
      }

      // Shot rows inside block
      if(curBlock && inShots && low.startsWith(',')){
        const row = splitCSV(line);
        // Expected: ["", time, tags, id, score, temp C, x mm, y mm, v fps, ...]
        const relTime = (row[1]||'').trim();
        if(!relTime || relTime.toLowerCase()==='time' || !/^\d/.test(relTime)) continue;

        const tag = (row[2]||'').trim();
        const score = (row[4]||'').trim();
        const xMm = (row[6]||'').trim();
        const yMm = (row[7]||'').trim();
        const vel = (row[8]||'').trim();

        shotIdx += 1;
        curBlock.n += 1;
        shots.push({ idx: shotIdx, block: curBlock.label, blockDate: curBlock.dateStr, relTime, tag, score, vel, xMm, yMm });
      }
    }

    // Fallback: if archive parsing found nothing, try a single-session CSV layout
    if(!shots.length){
      return parseShotMarkerFlat(raw);
    }
    return { blocks, shots };
  }

  function parseShotMarkerFlat(text){
    const raw = String(text||'');
    const lines = raw.split(/\r?\n/).map(stripBOM);
    let headerRow = null;
    let headerIdx = -1;

    // Find a header line that looks like a normal CSV table (no archive block headers)
    for(let i=0;i<Math.min(lines.length, 80);i++){
      const ln = lines[i];
      if(!ln || !ln.trim()) continue;
      const row = splitCSV(ln).map(x=>String(x||'').replace(/^"|"$/g,'').trim());
      const low = row.map(c=>c.toLowerCase());

      const hasTime = low.some(c=>c==='time' || c.includes('time'));
      const hasX = low.some(c=>c==='x' || c.includes('x (mm)') || (c.includes('x') && c.includes('mm')));
      const hasY = low.some(c=>c==='y' || c.includes('y (mm)') || (c.includes('y') && c.includes('mm')));
      const hasVel = low.some(c=>c.includes('vel') || (c.includes('v') && c.includes('fps')) || c.includes('speed'));
      if(hasTime && hasX && hasY && hasVel){
        headerRow = row;
        headerIdx = i;
        break;
      }
    }

    if(!headerRow){
      return { blocks:[], shots:[] };
    }

    const idxOf = (pred)=>{
      for(let i=0;i<headerRow.length;i++){
        const c = headerRow[i].toLowerCase();
        if(pred(c)) return i;
      }
      return -1;
    };

    const iTime = idxOf(c=>c==='time' || c.includes('time'));
    const iTags = idxOf(c=>c==='tags' || c.includes('tag'));
    const iScore = idxOf(c=>c==='score' || c.includes('points'));
    const iXmm = idxOf(c=>c==='x' || c.includes('x (mm)') || (c.includes('x') && c.includes('mm')));
    const iYmm = idxOf(c=>c==='y' || c.includes('y (mm)') || (c.includes('y') && c.includes('mm')));
    const iVel = idxOf(c=>c.includes('vel') || (c.includes('v') && c.includes('fps')) || c.includes('speed'));

    // Try to infer a date somewhere in the file for labeling
    let dateStr = '';
    for(let i=0;i<Math.min(lines.length, 40);i++){
      const m1 = String(lines[i]||'').match(/\b(\d{1,2}\/\d{1,2}\/\d{4})\b/);
      if(m1){ dateStr = m1[1]; break; }
      const m2 = String(lines[i]||'').match(/\b([A-Za-z]{3}\s+\d{1,2}\s+\d{4})\b/);
      if(m2){ dateStr = m2[1]; break; }
    }
    if(!dateStr) dateStr = 'Session';

    const blockLabel = (dateStr==='Session') ? 'Session R1' : `${dateStr} R1`;
    const blocks = [{label:blockLabel, dateStr:(dateStr==='Session'?'':dateStr), n:0, distYdAuto: null}];

    const shots = [];
    let shotIdx = 0;

    for(let i=headerIdx+1;i<lines.length;i++){
      const ln = lines[i];
      if(!ln || !ln.trim()) continue;
      const row = splitCSV(ln).map(x=>String(x||'').replace(/^"|"$/g,'').trim());
      const relTime = (iTime>=0 ? (row[iTime]||'').trim() : '');
      if(!relTime || relTime.toLowerCase()==='time') continue;

      const xMm = (iXmm>=0 ? (row[iXmm]||'').trim() : '');
      const yMm = (iYmm>=0 ? (row[iYmm]||'').trim() : '');

      // if row is clearly not a data row, skip
      if(!xMm && !yMm && iVel>=0 && !(row[iVel]||'').trim()) continue;

      shotIdx += 1;
      blocks[0].n += 1;
      shots.push({
        idx: shotIdx,
        block: blockLabel,
        blockDate: blocks[0].dateStr,
        relTime,
        tag: (iTags>=0 ? (row[iTags]||'').trim() : ''),
        score: (iScore>=0 ? (row[iScore]||'').trim() : ''),
        vel: (iVel>=0 ? (row[iVel]||'').trim() : ''),
        xMm,
        yMm
      });
    }

    return { blocks, shots };
  }

  // Robust CSV splitter for this simple case (handles quoted commas).
  function splitCSV(line){
    const out = [];
    let cur = '';
    let q = false;
    for(let i=0;i<line.length;i++){
      const ch = line[i];
      if(ch === '"'){
        if(q && line[i+1] === '"'){ cur += '"'; i++; }
        else q = !q;
      } else if(ch === ',' && !q){
        out.push(cur); cur='';
      } else {
        cur += ch;
      }
    }
    out.push(cur);
    return out;
  }

  // ---------- Kestrel parser ----------
  function parseKestrel(text){
    const lines = text.split(/\r?\n/).filter(l=>l.trim().length>0);
    // Find header row containing FORMATTED DATE_TIME
    let header = null, start = -1;
    for(let i=0;i<Math.min(lines.length, 50);i++){
      const row = splitCSV(lines[i]);
      if(row[0] && row[0].replace(/"/g,'') === 'FORMATTED DATE_TIME'){
        header = row.map(x=>x.replace(/^"|"$/g,'').trim());
        start = i+2; // skip units row too
        break;
      }
    }
    if(!header) return { samples:[], range:null, error:'Could not find Kestrel header (FORMATTED DATE_TIME).' };

    const col = (name)=> header.indexOf(name);
    const idxTime = col('FORMATTED DATE_TIME');
    const idxTemp = col('Temperature');
    const idxRH   = col('Relative Humidity');
    const idxDA   = col('Density Altitude');
    const idxXW   = col('Crosswind');
    const idxHW   = col('Headwind');
    const idxWS   = col('Wind Speed');
    const idxTrue = col('Compass True Direction');
    const idxSP   = col('Station Pressure');

    const samples = [];
    let minEpoch = Infinity, maxEpoch = -Infinity;
    let minStr = '', maxStr = '';
    for(let i=start;i<lines.length;i++){
      const row = splitCSV(lines[i]).map(x=>x.replace(/^"|"$/g,''));
      if(!row[idxTime] || !/^\d{4}-\d{2}-\d{2}/.test(row[idxTime])) continue;
      const dt = parseKestrelDate(row[idxTime]);
      if(!dt) continue;
      const tEpoch = dt.getTime()/1000;
      const formatted = row[idxTime];
      const s = {
        tEpoch,
        formatted,
        crosswind: safeNum(row[idxXW]),
        headwind: safeNum(row[idxHW]),
        windSpeed: safeNum(row[idxWS]),
        trueDir: safeNum(row[idxTrue]),
        temp: safeNum(row[idxTemp]),
        rh: safeNum(row[idxRH]),
        stationP: safeNum(row[idxSP]),
        da: safeNum(row[idxDA])
      };
      samples.push(s);
      if(tEpoch < minEpoch){ minEpoch=tEpoch; minStr=formatted; }
      if(tEpoch > maxEpoch){ maxEpoch=tEpoch; maxStr=formatted; }
    }
    samples.sort((a,b)=>a.tEpoch-b.tEpoch);
    const range = (samples.length? {minEpoch,maxEpoch,minStr,maxStr}: null);
    return { samples, range, header };
  }

  function safeNum(v){
    const n = parseFloat(String(v||'').trim());
    return Number.isFinite(n) ? n : null;
  }

  function parseKestrelDate(s){
    // "2025-12-27 07:01:05 PM" -> local Date
    const m = String(s||'').trim().match(/^(\d{4})-(\d{2})-(\d{2})\s+(\d{2}):(\d{2}):(\d{2})\s+(AM|PM)$/);
    if(!m) return null;
    let Y=+m[1], M=+m[2], D=+m[3], hh=+m[4], mm=+m[5], ss=+m[6];
    const ap = m[7];
    if(ap==='PM' && hh!==12) hh+=12;
    if(ap==='AM' && hh===12) hh=0;
    return new Date(Y, M-1, D, hh, mm, ss, 0);
  }

  function nearestSample(epoch){
    // binary search in kSamples
    if(!kSamples.length) return {s:null, dt:Infinity};
    let lo=0, hi=kSamples.length-1;
    while(lo<hi){
      const mid = Math.floor((lo+hi)/2);
      if(kSamples[mid].tEpoch < epoch) lo = mid+1;
      else hi = mid;
    }
    let best = kSamples[lo];
    let bestDt = Math.abs(best.tEpoch - epoch);
    if(lo>0){
      const prev = kSamples[lo-1];
      const dt = Math.abs(prev.tEpoch - epoch);
      if(dt < bestDt){ best=prev; bestDt=dt; }
    }
    return {s:best, dt:bestDt};
  }

  function computeShotEpoch(idx){
    const aShot = clampInt(el('aShot').value, 1, smShots.length||1);
    const bShot = clampInt(el('bShot').value, 1, smShots.length||1);
    const aSec = parseHMS(el('aTime').value);
    const bSec = parseHMS(el('bTime').value);
    const dateISO = el('sessionDate').value;
    if(!dateISO || aSec===null || bSec===null || !Number.isFinite(aShot) || !Number.isFinite(bShot) || aShot===bShot) return null;

    const absA = epochFromLocal(dateISO, aSec);
    const absB = epochFromLocal(dateISO, bSec);
    const t = (idx - aShot) / (bShot - aShot);
    return absA + t * (absB - absA);
  }

  function clampInt(v, lo, hi){
    const n = Math.trunc(Number(v));
    if(!Number.isFinite(n)) return lo;
    return Math.max(lo, Math.min(hi, n));
  }

  function clearKestrel(){
    for(const sh of smShots){
      sh.k = null;
      sh.kdt = null;
      sh.j = null;
    }
    renderTable();
    kStatus.innerHTML = `<span class="good">Cleared Kestrel fields.</span>`;
  }

  function applyKestrel(){
    if(!smShots.length){
      kStatus.innerHTML = `<span class="bad">Load ShotMarker first.</span>`;
      return;
    }
    if(!kSamples.length){
      kStatus.innerHTML = `<span class="bad">Load Kestrel CSV first.</span>`;
      return;
    }
    const tol = Number(el('tolSel').value)||10;
    let joined=0, missed=0, badmap=0, outwin=0;

    // date mismatch warning
    const smDate = smFirstDate ? dateToISO(smFirstDate) : null;
    const sessISO = el('sessionDate').value || '';
    const dateMismatch = (smDate && sessISO && smDate !== sessISO);

    // compute predicted range for shots
    const t1 = computeShotEpoch(1);
    const tN = computeShotEpoch(smShots.length);
    let rangeLine = '';
    if(t1 && tN){
      rangeLine = `Predicted shots range: ${new Date(t1*1000).toLocaleString()} \u2192 ${new Date(tN*1000).toLocaleString()}`;
    }

    for(const sh of smShots){
      const epoch = computeShotEpoch(sh.idx);
      const {s, dt} = nearestSample(epoch);

      if(epoch===null){
        sh.k = null; sh.kdt = null; sh.j = 'BADMAP';
        badmap++; continue;
      }

      if(kRange && (epoch < (kRange.minEpoch - tol) || epoch > (kRange.maxEpoch + tol))){
        sh.k = null; sh.kdt = null; sh.j = 'OUT';
        outwin++; continue;
      }

      if(s && dt <= tol){
        sh.k = s; sh.kdt = dt; sh.j = 'JOIN';
        joined++;
      } else {
        sh.k = null; sh.kdt = dt; sh.j = 'MISS';
        missed++;
      }
    }
    renderTable();

    const lines = [];
    lines.push(`<span class="good">Applied Kestrel to shots.</span>`);
    lines.push(`<span class="good">Joined:</span> ${joined}`);
    lines.push(`<span class="warn">Missed (out of tolerance):</span> ${missed}`);
    lines.push(`<span class="warn">Out of window:</span> ${outwin}`);
    lines.push(`<span class="warn">Bad time mapping:</span> ${badmap}`);
    if(rangeLine) lines.push(`<span class="hint">${esc(rangeLine)}</span>`);
    if(kRange) lines.push(`<span class="hint">Kestrel range: ${esc(kRange.minStr)} \u2192 ${esc(kRange.maxStr)}</span>`);
    if(dateMismatch){
      lines.push(`<span class="warn">⚠ Date mismatch: ShotMarker ${esc(smDate)} vs session date ${esc(sessISO)} (this is OK for demo, but real joins need same day/session).</span>`);
    }
    // anchor window warning
    const aSec = parseHMS(el('aTime').value), bSec = parseHMS(el('bTime').value);
    if(kRange && sessISO && aSec!==null && bSec!==null){
      const aE = epochFromLocal(sessISO, aSec);
      const bE = epochFromLocal(sessISO, bSec);
      const minA = Math.min(aE,bE), maxA=Math.max(aE,bE);
      if(maxA < kRange.minEpoch || minA > kRange.maxEpoch){
        lines.push(`<span class="bad">⚠ Anchors do not overlap the Kestrel time window. Either change anchor times or use Auto-fit for demo.</span>`);
      }
    }

    kStatus.innerHTML = lines.join("\n");
  }

  function autoFitAnchors(){
    if(!smShots.length || !kRange){
      kStatus.innerHTML = `<span class="bad">Load ShotMarker + Kestrel first.</span>`;
      return;
    }
    const dateISO = el('sessionDate').value;
    if(!dateISO){
      kStatus.innerHTML = `<span class="bad">Set session date first.</span>`;
      return;
    }
    const min = new Date(kRange.minEpoch*1000);
    const max = new Date(kRange.maxEpoch*1000);
    // set anchors to 60s inside range
    const a = new Date(min.getTime() + 60*1000);
    const b = new Date(max.getTime() - 60*1000);
    const fmt = (d)=> String(d.getHours()).padStart(2,'0')+':'+String(d.getMinutes()).padStart(2,'0')+':'+String(d.getSeconds()).padStart(2,'0');
    el('aShot').value = 1;
    el('bShot').value = smShots.length;
    el('aTime').value = fmt(a);
    el('bTime').value = fmt(b);
    kStatus.innerHTML = `<span class="good">Auto-fit anchors set.</span> Now click <b>Apply</b> to validate join plumbing.`;
  }

  function setDateFromSM(){
    if(!smFirstDate){
      kStatus.innerHTML = `<span class="bad">Load ShotMarker first.</span>`;
      return;
    }
    el('sessionDate').value = dateToISO(smFirstDate);
    kStatus.innerHTML = `<span class="good">Session date set from ShotMarker: ${esc(dateToISO(smFirstDate))}</span>`;
  }

  
  // ---------- Garmin chrono parser ----------
  function parseGarmin(text){
    const lines = text.split(/\r?\n/).filter(l=>String(l).trim().length>0);
    let header = null;
    let start = 0;
    for(let i=0;i<Math.min(lines.length, 60);i++){
      const row = splitCSV(lines[i]).map(x=>String(x||'').replace(/^\ufeff+/,'').trim());
      if(row.length>=2 && row[0]==='#' && row.join(',').toLowerCase().includes('speed')){
        header = row;
        start = i+1;
        break;
      }
    }
    if(!header) return {shots:[], error:'Could not find Garmin header row (expected a column named Speed (FPS)).'};

    const idxIdx = 0;
    const idxSpeed = header.findIndex(h=>String(h).toLowerCase().includes('speed') && String(h).toLowerCase().includes('fps'));
    const idxTime = header.findIndex(h=>String(h).toLowerCase()==='time');

    const shots=[];
    for(let i=start;i<lines.length;i++){
      const row = splitCSV(lines[i]);
      if(!row.length) continue;
      const idx = parseInt(String(row[idxIdx]||'').trim(),10);
      if(!Number.isFinite(idx)) continue;
      const vel = safeNum(row[idxSpeed]);
      const timeSec = (idxTime>=0 ? parseHMS(row[idxTime]) : null);
      shots.push({idx, vel, timeSec});
    }
    shots.sort((a,b)=>a.idx-b.idx);
    return {shots, error:null};
  }

  // ---------- AMP CSV (seating force) ----------
  // AMP exports are "metrics as rows, traces as columns" (Trace 1..N).
  function parseAMP(text){
    const lines = text.split(/\r?\n/).filter(l=>l!=null && l.trim().length);
    if(!lines.length) return { traces:[], error:'Empty AMP file' };

    const header = splitCSV(lines[0]);
    // Expect first col = metric name, then Trace 1..N
    const traceCols = header.slice(1).map(h=>String(h||'').trim());
    const traceNums = traceCols.map(h=>{
      const m = /\b(\d+)\b/.exec(h);
      return m ? parseInt(m[1],10) : null;
    });

    const want = new Set(['Peak Force','Work Done','Starting Pos','Terminal Force']);
    const rowsByMetric = {};
    for(let i=1;i<lines.length;i++){
      const parts = splitCSV(lines[i]);
      if(!parts.length) continue;
      const metric = String(parts[0]||'').trim();
      if(!want.has(metric)) continue;
      rowsByMetric[metric] = parts.slice(1).map(v=>{
        const n = parseFloat(String(v||'').trim());
        return Number.isFinite(n) ? n : null;
      });
    }

    // Build traces
    const traces = [];
    for(let j=0;j<traceNums.length;j++){
      const n = traceNums[j];
      if(!n) continue;
      const t = {
        trace: n,
        peak: rowsByMetric['Peak Force'] ? rowsByMetric['Peak Force'][j] : null,
        work: rowsByMetric['Work Done'] ? rowsByMetric['Work Done'][j] : null,
        startPos: rowsByMetric['Starting Pos'] ? rowsByMetric['Starting Pos'][j] : null,
        term: rowsByMetric['Terminal Force'] ? rowsByMetric['Terminal Force'][j] : null
      };
      // keep if any value exists
      if(t.peak!=null || t.work!=null || t.startPos!=null || t.term!=null) traces.push(t);
    }

    // Stats + z-scores (mean/std)
    function meanStd(arr){
      const xs = arr.filter(v=>v!=null && Number.isFinite(v));
      if(xs.length<2) return {mean:null,std:null};
      const mean = xs.reduce((a,b)=>a+b,0)/xs.length;
      const varr = xs.reduce((a,b)=>a+(b-mean)*(b-mean),0)/xs.length;
      const std = Math.sqrt(varr);
      return {mean,std};
    }
    const ps = meanStd(traces.map(t=>t.peak));
    const ws = meanStd(traces.map(t=>t.work));
    const ss = meanStd(traces.map(t=>t.startPos));

    for(const t of traces){
      t.zPeak = (ps.mean!=null && ps.std>0 && t.peak!=null) ? ((t.peak-ps.mean)/ps.std) : null;
      t.zWork = (ws.mean!=null && ws.std>0 && t.work!=null) ? ((t.work-ws.mean)/ws.std) : null;
      t.zStart = (ss.mean!=null && ss.std>0 && t.startPos!=null) ? ((t.startPos-ss.mean)/ss.std) : null;
      // a single "anomaly score" = max abs z among metrics
      let m = 0;
      for(const z of [t.zPeak, t.zWork, t.zStart]){
        if(z!=null && Number.isFinite(z)) m = Math.max(m, Math.abs(z));
      }
      t.ampZ = (m>0) ? m : null;
    }

    return { traces, stats:{peak:ps, work:ws, startPos:ss}, error:null };
  }

  function applyAMPToShots(){
    // Map AMP trace 1..N onto shot idx 1..N (file order). If your session is 66 rounds,
    // Trace 1 maps to Shot #1, etc.
    if(!ampSession || !ampSession.map) return;
    for(const sh of smShots){
      const tr = ampSession.map.get(sh.idx);
      if(tr){
        sh.ampPeak = tr.peak;
        sh.ampWork = tr.work;
        sh.ampStartPos = tr.startPos;
        sh.ampZ = tr.ampZ;
        sh.ampZPeak = tr.zPeak;
        sh.ampZWork = tr.zWork;
        sh.ampZStart = tr.zStart;
      } else {
        sh.ampPeak = null;
        sh.ampWork = null;
        sh.ampStartPos = null;
        sh.ampZ = null;
      }
    }
  }

  async function importAMPCSV(file){
    const text = await file.text();
    const parsed = parseAMP(text);
    if(parsed.error){
      ampSession = null;
      toast('AMP: ' + parsed.error);
      return;
    }
    const map = new Map();
    for(const t of parsed.traces) map.set(t.trace, t);
    ampSession = { name: file.name, map, stats: parsed.stats, n: parsed.traces.length };
    applyAMPToShots();
    render();
    toast(`AMP loaded: ${parsed.traces.length} traces`);
  }

  function fmtAmp(n){
    return (n!=null && Number.isFinite(n)) ? n.toFixed(2) : '';
  }


  function ampValCell(label, val, z){
    if(val==null || !Number.isFinite(val)) return '';
    const zs = (z!=null && Number.isFinite(z)) ? (z>=0?'+':'')+z.toFixed(2)+'σ' : '—';
    const tip = `AMP ${label}: ${val.toFixed(2)} (z=${zs})`;
    return `<span title="${escA(tip)}">${val.toFixed(2)}</span>`;
  }




  function buildGarminMap(){
    const map = new Map(); // key: SM shot idx -> {vel,file,fileIdx}
    for(const gf of gFiles){
      const base = (gf && Number.isFinite(gf.startIdx) && gf.startIdx>0) ? Math.trunc(gf.startIdx) : 1;
      const shots = gf.shots || [];
      for(const s of shots){
        const fileIdx = (s && Number.isFinite(s.idx)) ? Math.trunc(s.idx) : null;
        if(fileIdx==null) continue;
        const smIdx = base + (fileIdx - 1);
        if(!Number.isFinite(smIdx) || smIdx<=0) continue;
        map.set(smIdx, {vel: s.vel, file: gf.name, fileIdx});
      }
    }
    return map;
  }

  function applyGarminToShots(){
    // Apply Garmin velocities by block pairing (one chrono file per ShotMarker target).
    // This avoids needing global "start shot #" alignment when your workflow is 1:1 targets↔chrono.
    let matched = 0, overrides = 0;

    // Preserve SM velocities as baseline
    for(const sh of smShots){
      const smv = parseFloat(String(sh.vel||'').trim());
      const smVelNum = Number.isFinite(smv) ? smv : null;
      sh.velSM = smVelNum;
      sh.vel = smVelNum;
      // active velocity selection: default to ShotMarker until Garmin provides a value
      sh.velActive = smVelNum;
      sh.velSrc = 'SM';

      // coverage / provenance
      sh.gInfo = null;
      sh.gMapped = false;
    }

    if(!smShots.length || !gFiles.length) return {matched:0, overrides:0, unmapped: smShots.length, extra:0};

    // Auto pair by order when files count matches block count and no manual pairing exists.
    autoPairChronoByOrder();

    const gByName = new Map(gFiles.map(g=>[g.name, g]));
    const groups = groupByBlock();

    // Determine block order (prefer ShotMarker-declared order)
    const blockOrder = (smBlocks && smBlocks.length) ? smBlocks.map(b=>b.label) : Array.from(groups.keys());

    for(const blk of blockOrder){
      const list = (groups.get(blk) || []).slice().sort((a,b)=>a.idx-b.idx);
      if(!list.length) continue;

      const pair = chronoPair.get(blk) || {};
      const gf = pair.name ? gByName.get(pair.name) : null;
      if(!gf || !gf.shots || !gf.shots.length) continue;

      const start = (pair.start && Number.isFinite(+pair.start) && +pair.start>0) ? Math.trunc(+pair.start) : 1;
      const base = start - 1;

      for(let i=0;i<list.length;i++){
        const sh = list[i];
        const gs = gf.shots[base + i];
        const gvel = gs && Number.isFinite(gs.vel) ? gs.vel : null;

        if(gvel!=null && gvel>0){
          sh.gInfo = {vel:gvel, file: gf.name, fileIdx: gs.idx};
          sh.gMapped = true;
          matched++;
          if(sh.velSM==null || Math.abs((sh.velSM||0) - gvel) > 0.0001) overrides++;
          sh.vel = gvel;
          sh.velActive = gvel;
          sh.velSrc = 'Garmin';
        }
      }
    }

    const unmapped = Math.max(0, smShots.length - matched);
    return {matched, overrides, unmapped, extra:0};
  }


  // Phase 3 Step 2: block rollups + optional filter
  let activeBlock = null; // null = all
let collapsedBlocks = new Set(); // block label strings collapsed in All view

  function groupByBlock(){
    const map = new Map();
    for(const sh of smShots){
      const key = sh.block || '(unknown)';
      if(!map.has(key)) map.set(key, []);
      map.get(key).push(sh);
    }
    return map;
  }

  function countStates(list){
    let rec=0, sgt=0, exc=0;
    for(const sh of list){
      const st = sh.state || 'RECORD';
      if(st==='EXCLUDE') exc++;
      else if(st==='SIGHTER') sgt++;
      else rec++;
    }
    return {rec, sgt, exc, total:list.length};
  }


  function computeVelStats(list){
    // RECORD shots only; velocities must be finite > 0
    const vals = [];
    for(const sh of list){
      if((sh.state||'RECORD')!=='RECORD') continue;
      const v = (sh.velActive!=null && Number.isFinite(sh.velActive) && sh.velActive>0) ? sh.velActive : null;
      if(v!=null) vals.push(v);
    }
    const n = vals.length;
    if(!n) return {n:0, mean:null, sd:null, es:null, min:null, max:null};
    let sum = 0;
    let mn = Infinity, mx = -Infinity;
    for(const v of vals){ sum += v; if(v<mn) mn=v; if(v>mx) mx=v; }
    const mean = sum / n;
    let sd = null;
    if(n >= 3){
      let ss = 0;
      for(const v of vals){ const d = v-mean; ss += d*d; }
      sd = Math.sqrt(ss / (n-1)); // sample SD
    }
    const es = (n >= 2) ? (mx - mn) : null;
    return {n, mean, sd, es, min: mn, max: mx};
  }

  // ---------- Phase 5.3: wind variability + "wind explains horizontal" ----------
  function computeWindStats(list){
    // RECORD shots only; requires joined Kestrel crosswind
    const w = [];
    const pairs = []; // {x: crosswind, y: hMoa}
    let rec = 0;
    for(const sh of list){
      if((sh.state||'RECORD')!=='RECORD') continue;
      rec++;
      const cw = (sh.k && sh.j==='JOIN' && sh.k.crosswind!=null && Number.isFinite(sh.k.crosswind)) ? sh.k.crosswind : null;
      if(cw==null) continue;
      w.push(cw);
      const hm = (sh.hMoa!=null && Number.isFinite(sh.hMoa)) ? sh.hMoa : null;
      if(hm!=null) pairs.push({x:cw, y:hm});
    }
    const n = w.length;
    if(!n) return {rec, n:0, mean:null, sd:null, min:null, max:null, bracket:null, pairsN:pairs.length, r:null};
    let sum=0, mn=Infinity, mx=-Infinity;
    for(const v of w){ sum+=v; if(v<mn) mn=v; if(v>mx) mx=v; }
    const mean = sum/n;
    let sd=null;
    if(n>=3){
      let ss=0;
      for(const v of w){ const d=v-mean; ss += d*d; }
      sd = Math.sqrt(ss/(n-1)); // sample SD
    }
    const bracket = (n>=2) ? (mx-mn) : null;
    const r = (pairs.length>=10) ? pearson(pairs.map(p=>p.x), pairs.map(p=>p.y)) : null;
    return {rec, n, mean, sd, min:mn, max:mx, bracket, pairsN:pairs.length, r};
  }

  function pearson(xs, ys){
    const n = Math.min(xs.length, ys.length);
    if(n<3) return null;
    let sx=0, sy=0;
    for(let i=0;i<n;i++){ sx+=xs[i]; sy+=ys[i]; }
    const mx=sx/n, my=sy/n;
    let sxx=0, syy=0, sxy=0;
    for(let i=0;i<n;i++){
      const dx = xs[i]-mx, dy=ys[i]-my;
      sxx += dx*dx; syy += dy*dy; sxy += dx*dy;
    }
    if(sxx<=0 || syy<=0) return null;
    return sxy / Math.sqrt(sxx*syy);
  }

  function windInstabilityLabel(ws){
    if(!ws || ws.n===0) return null;
    const sd = ws.sd;
    const br = ws.bracket;
    const sdOk = (sd!=null ? sd : 999);
    const brOk = (br!=null ? br : 999);
    if(sdOk<=1.0 && brOk<=3.0) return {lvl:'OK', icon:'✅', title:'Wind stable (SD≤1mph and bracket≤3mph)'};
    if(sdOk<=2.0 && brOk<=6.0) return {lvl:'VAR', icon:'⚠', title:'Wind variable (SD 1–2mph or bracket 3–6mph)'};
    return {lvl:'WILD', icon:'🚨', title:'Wind wild (SD>2mph or bracket>6mph)'};
  }

  function windExplainLabel(r){
    if(r==null || !Number.isFinite(r)) return null;
    const a = Math.abs(r);
    if(a < 0.25) return {txt:'Low', title:`Weak wind→horizontal relationship (r=${r.toFixed(2)})`};
    if(a < 0.50) return {txt:'Med', title:`Moderate wind→horizontal relationship (r=${r.toFixed(2)})`};
    return {txt:'High', title:`Strong wind→horizontal relationship (r=${r.toFixed(2)})`};
  }

  // ---------- Phase 4: block stats + per-shot flags ----------
  function recomputeBlockStats(){
    blockStats = new Map();
    const groups = groupByBlock();
    for(const [block, list] of groups.entries()){
      blockStats.set(block, computeVelStats(list));
    }
  }

  
  function fmtIn(v){
    return (v!=null && Number.isFinite(v)) ? v.toFixed(3) : '';
  }
  function fmtMoa(v){
    return (v!=null && Number.isFinite(v)) ? v.toFixed(2) : '';
  }
  function moaFromIn(inches, distYd){
    if(!(inches!=null && Number.isFinite(inches)) || !(distYd!=null && Number.isFinite(distYd)) || distYd<=0) return null;
    return inches / (1.047 * (distYd/100));
  }

  function distForBlock(block){
    // precedence: user override -> ShotMarker auto -> default
    const v = blockDist.get(block);
    const n = Number(v);
    if(Number.isFinite(n) && n>0) return n;
    const a = blockAutoDist.get(block);
    const an = Number(a);
    if(Number.isFinite(an) && an>0) return an;
    return defaultDistYd;
  }

  function computeGeoStatsForBlock(block, list){
    const distYd = distForBlock(block);
    // RECORD shots only with coords
    const pts = [];
    for(const sh of list){
      if((sh.state||'RECORD')!=='RECORD') continue;
      if(sh.xIn==null || sh.yIn==null) continue;
      pts.push({x: sh.xIn, y: sh.yIn, sh});
    }
    const n = pts.length;
    // Clear per-shot MOA for this block first (so toggles reflow correctly)
    for(const sh of list){
      sh.hMoa=null; sh.vMoa=null; sh.rMoa=null;
    }
    if(n===0) return {distYd, n:0, horizESmoa:null, vertESmoa:null, radialESmoa:null, mrMoa:null};

    // centroid for MR + per-shot offsets
    let sx=0, sy=0;
    for(const p of pts){ sx+=p.x; sy+=p.y; }
    const cx = sx/n, cy = sy/n;

    // per-shot
    for(const p of pts){
      const dx = p.x - cx;
      const dy = p.y - cy;
      const r = Math.hypot(dx,dy);
      p.sh.hMoa = moaFromIn(Math.abs(dx), distYd);
      p.sh.vMoa = moaFromIn(Math.abs(dy), distYd);
      p.sh.rMoa = moaFromIn(r, distYd);
    }

    // axis ES using raw coords (centroid shift doesn't change spread)
    let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
    for(const p of pts){
      if(p.x<minX) minX=p.x; if(p.x>maxX) maxX=p.x;
      if(p.y<minY) minY=p.y; if(p.y>maxY) maxY=p.y;
    }
    const horizESin = (maxX-minX);
    const vertESin = (maxY-minY);

    // radial ES = max pairwise distance (O(n^2) but n<=~60)
    let maxD = 0;
    for(let i=0;i<n;i++){
      for(let j=i+1;j<n;j++){
        const dx = pts[i].x-pts[j].x;
        const dy = pts[i].y-pts[j].y;
        const d = Math.hypot(dx,dy);
        if(d>maxD) maxD=d;
      }
    }

    // mean radius about centroid
    let mrSum=0;
    for(const p of pts){
      const dx=p.x-cx, dy=p.y-cy;
      mrSum += Math.hypot(dx,dy);
    }
    const mrIn = mrSum/n;

    return {
      distYd, n,
      horizESmoa: moaFromIn(horizESin, distYd),
      vertESmoa: moaFromIn(vertESin, distYd),
      radialESmoa: moaFromIn(maxD, distYd),
      mrMoa: moaFromIn(mrIn, distYd)
    };
  }

  function recomputeGeoStats(){
    geoStats = new Map();
    const groups = groupByBlock();
    for(const [block, list] of groups.entries()){
      geoStats.set(block, computeGeoStatsForBlock(block, list));
    }
  }

function velFlagForShot(sh){
    const st = (sh.state||'RECORD');
    if(st !== 'RECORD') return {level:'off', text:'', why:'Non-record shot'};
    const v = (sh.velActive!=null && Number.isFinite(sh.velActive) && sh.velActive>0) ? sh.velActive : null;
    if(v==null) return {level:'off', text:'', why:'Missing velocity'};

    const vs = blockStats.get(sh.block) || computeVelStats(smShots.filter(s=>s.block===sh.block));
    const sd = (vs && Number.isFinite(vs.sd) && vs.sd>0) ? vs.sd : null;
    if(sd==null) return {level:'off', text:'', why:'Need ≥3 record velocities in block (to compute SD)'};

    const z = (v - vs.mean) / sd;
    const az = Math.abs(z);

    // thresholds: <=0.5 OK; 0.5–1.0 Warn; 1.0–1.5 Problem; >1.5 Red
    let level='ok';
    if(az > 1.5) level='bad';
    else if(az > 1.0) level='problem';
    else if(az > 0.5) level='warn';

    const text = `${az.toFixed(1)}σ`;
    return {level, text, z, az};
  }

  function flagCell(sh){
    const f = velFlagForShot(sh);
    if(!f.text) return `<span class="flagchip off" title="${esc(f.why || 'No Δσ available.')}">—</span>`;
    const desc = (f.az<=0.3) ? 'basically on the node'
      : (f.az<=1.0) ? 'normal noise'
      : (f.az<=1.5) ? 'eyebrow raise'
      : 'real outlier (candidate for exclusion)';
    const title =
`Δ${f.text} — ${desc}

Δ0.1σ = basically on the node

Δ0.7σ = normal noise

Δ1.3σ = eyebrow raise

Δ1.9σ = real outlier (candidate for exclusion)

Click to toggle EXCLUDE.`;
    return `<span class="flagchip ${esc(f.level)}" title="${esc(title)}" data-flag-shot="${sh.idx}">${esc(f.text)}</span>`;
  }

  function setShotStateByIdx(shotIdx, newState, pushUndo=true, src='MANUAL'){
    const sh = smShots.find(s=>s.idx===shotIdx);
    if(!sh) return;
    const prev = sh.state || 'RECORD';
    const prevSrc = sh.stateSrc || '';
    if(prev === newState && prevSrc === (src||'')) return;

    if(pushUndo) undo = {type:'shot', shotIdx, prevState: prev, prevSrc};

    sh.state = newState;

    // Track why this shot is in its current state (helps explain "exclude by flag" vs manual, etc.)
    // src values: 'FLAG', 'MANUAL', 'TAG', '' (default)
    if(newState === 'EXCLUDE'){
      sh.stateSrc = (src||'MANUAL');
    } else if(newState === 'SIGHTER'){
      sh.stateSrc = (src||'MANUAL');
    } else {
      sh.stateSrc = '';
    }

    const p4 = el('importStatus');
    if(p4){
      const srcTxt = (newState==='EXCLUDE' ? (sh.stateSrc||'') : '');
      p4.innerHTML = `<span class="hint">Stats updated after state change.</span>`;
    }

    recomputeBlockStats();
    recomputeGeoStats();
    renderBlockRollups();
    renderTable();
  }

  function undoLast(){
    if(!undo) return;

    // Phase 5.4.5: undo supports either shot state changes or Garmin mapping edits.
    if(undo.type === 'garminMap'){
      const prevStarts = Array.isArray(undo.prevStarts) ? undo.prevStarts : [];
      for(let i=0;i<gFiles.length;i++){
        if(prevStarts[i]!=null) gFiles[i].startIdx = prevStarts[i];
      }
      undo = null;
      const res = smShots.length ? applyGarminToShots() : {matched:0, overrides:0, unmapped:0, extra:0};

    // If per-target pairings exist, apply them now
    applyChronoPairings();
      recomputeBlockStats();
      renderBlockRollups();
      renderTable();
      renderGarminMapping();
      el('importStatus').innerHTML = `<span class="good">Undid Garmin mapping change.</span> <span class="hint">Matched: ${res.matched} • Unmapped: ${res.unmapped}</span>`;
      return;
    }

    // Default: undo a shot state change
    const {shotIdx, prevState, prevSrc} = undo;
    undo = null;
    setShotStateByIdx(shotIdx, prevState, false, prevSrc||'');
    el('importStatus').innerHTML = `<span class="good">Undid last change.</span>`;
  }

  function resetStatesInActiveBlock(){
    if(!activeBlock){
      el('importStatus').innerHTML = `<span class="warn">Pick a block first (click it in the rollups).</span>`;
      return;
    }
    const list = smShots.filter(s=>s.block===activeBlock);
    let changed = 0;
    for(const sh of list){
      const inferred = (String(sh.tag||'').toLowerCase().includes('sight') ? 'SIGHTER' : 'RECORD');
      if((sh.state||'RECORD') !== inferred){
        sh.state = inferred;
        sh.stateSrc = (inferred==='SIGHTER') ? 'TAG' : '';
        changed++;
      }
    }
    undo = null;
    recomputeBlockStats();
    recomputeGeoStats();
    renderBlockRollups();
    renderTable();
    el('importStatus').innerHTML = `<span class="good">Reset ${changed} shot(s) in block.</span>`;
  }

  function renderGarminMapping(){
    const body = el('garminMapBody');
    if(!body) return;
    if(!gFiles.length){
      body.innerHTML = `<tr><td colspan="3" style="color:rgba(230,238,248,.6); padding:10px;">No Garmin files loaded.</td></tr>`;
      return;
    }
    body.innerHTML = gFiles.map((g,i)=>{
      const n = (g.shots && g.shots.length) ? g.shots.length : 0;
      const start = (g.startIdx!=null ? g.startIdx : 1);
      return `<tr>
        <td style="max-width:240px; overflow:hidden; text-overflow:ellipsis;">${esc(g.name)}</td>
        <td>${n}</td>
        <td><input type="number" min="1" step="1" value="${start}" data-gstart="${i}"/></td>
      </tr>`;
    }).join('');
  }
  function applyGarminMappingFromUI(){
    const body = el('garminMapBody');
    if(!body) return;

    // Phase 5.4.5: allow Undo for mapping edits
    const prevStarts = gFiles.map(g=> (g && Number.isFinite(g.startIdx) && g.startIdx>0) ? Math.trunc(g.startIdx) : 1);

    const inputs = body.querySelectorAll('input[data-gstart]');
    let changed = false;
    for(const inp of inputs){
      const i = Number(inp.getAttribute('data-gstart'));
      const v = Math.trunc(Number(inp.value));
      if(Number.isFinite(i) && gFiles[i]){
        const next = (Number.isFinite(v) && v>0) ? v : 1;
        const cur = (gFiles[i].startIdx!=null ? Math.trunc(gFiles[i].startIdx) : 1);
        if(cur !== next) changed = true;
        gFiles[i].startIdx = next;
      }
    }

    if(changed){
      undo = {type:'garminMap', prevStarts};
    }

    const res = smShots.length ? applyGarminToShots() : {matched:0, overrides:0, unmapped:0, extra:0};
    recomputeBlockStats();
    renderBlockRollups();
    renderTable();
    renderGarminMapping();

    const warn = [];
    if(res.extra>0) warn.push(`<span class="warn">⚠ ${res.extra} Garmin shot(s) map beyond ShotMarker count.</span>`);
    if(res.unmapped>0) warn.push(`<span class="warn">⚠ ${res.unmapped} ShotMarker shot(s) have no Garmin match.</span>`);
    el('importStatus').innerHTML =
      `<span class="good">Applied Garmin mapping.</span> Matched: ${res.matched} • Overrides: ${res.overrides} • Unmapped: ${res.unmapped}` +
      (warn.length ? `<div style="margin-top:6px;">${warn.join(' ')}</div>` : '');
  }


  function downloadBlob(filename, mime, text){
    const blob = new Blob([text], {type:mime});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 1000);
  }

  function exportCSV(){
  if(!smShots.length){
    el('importStatus').innerHTML = `<span class="bad">Load ShotMarker first.</span>`;
    return;
  }
  // Ensure stats are current
  recomputeBlockStats();
  recomputeGeoStats();

  const csvCell = (v)=>{
    if(v===null || v===undefined) return '';
    const s = String(v);
    if(/[",\r\n]/.test(s)) return `"${s.replace(/"/g,'""')}"`;
    return s;
  };

  const cols = [
    '#','Block','Rel time','Tag','State','State Src',
    'Score','Vel','Vel Src',
    'Dist (yd)','Dist Src',
    'X (in)','Y (in)','H (MOA)','V (MOA)','R (MOA)',
    'Block Rad ES (MOA)','Block Vert ES (MOA)','Block Horiz ES (MOA)','Block MR (MOA)',
    'Block N (vel)','Block Mean (vel)','Block SD (vel)','Block ES (vel)',
    'ΔVel (σ)','Δσ Level',
    'Kestrel time','Join','Δt (s)',
    'Crosswind','Headwind','Wind spd','Dir (true)','Temp','RH','Station P','DA'
  ];

  const lines = [cols.map(csvCell).join(',')];

  for(const sh of smShots){
    const vs = blockStats.get(sh.block) || {n:0,mean:null,sd:null,es:null};
    const f = velFlagForShot(sh);
    const k = sh.k;

    const distYd = Math.round(distForBlock(sh.block));
    const distSrc = blockDist.has(sh.block) ? 'MAN' : (blockAutoDist.has(sh.block) ? 'SM' : 'DEF');

    const gs = geoStats.get(sh.block);

    const row = [
      sh.idx,
      sh.block,
      sh.relTime,
      sh.tag||'',
      (sh.state||'RECORD'),
      (sh.stateSrc||''),
      sh.score||'',
      (sh.velActive!=null ? Math.round(sh.velActive) : ''),
      sh.velSrc||'SM',
      distYd,
      distSrc,
      (sh.xIn!=null ? sh.xIn.toFixed(4) : ''),
      (sh.yIn!=null ? sh.yIn.toFixed(4) : ''),
      (sh.hMoa!=null ? sh.hMoa.toFixed(3) : ''),
      (sh.vMoa!=null ? sh.vMoa.toFixed(3) : ''),
      (sh.rMoa!=null ? sh.rMoa.toFixed(3) : ''),
      (gs && gs.radialESmoa!=null ? gs.radialESmoa.toFixed(3) : ''),
      (gs && gs.vertESmoa!=null ? gs.vertESmoa.toFixed(3) : ''),
      (gs && gs.horizESmoa!=null ? gs.horizESmoa.toFixed(3) : ''),
      (gs && gs.mrMoa!=null ? gs.mrMoa.toFixed(3) : ''),
      vs.n||0,
      (vs.mean!=null ? vs.mean.toFixed(2) : ''),
      (vs.sd!=null ? vs.sd.toFixed(2) : ''),
      (vs.es!=null ? vs.es.toFixed(2) : ''),
      (f && f.text ? f.az.toFixed(2) : ''),
      (f && f.text ? String(f.level||'').toUpperCase() : ''),
      (k ? k.formatted : ''),
      (sh.j||''),
      (sh.kdt!=null ? sh.kdt.toFixed(2) : ''),
      (k && k.crosswind!=null ? k.crosswind.toFixed(2) : ''),
      (k && k.headwind!=null ? k.headwind.toFixed(2) : ''),
      (k && k.windSpeed!=null ? k.windSpeed.toFixed(2) : ''),
      (k && k.trueDir!=null ? k.trueDir.toFixed(0) : ''),
      (k && k.temp!=null ? k.temp.toFixed(2) : ''),
      (k && k.rh!=null ? k.rh.toFixed(2) : ''),
      (k && k.stationP!=null ? k.stationP.toFixed(2) : ''),
      (k && k.da!=null ? k.da.toFixed(0) : '')
    ];

    lines.push(row.map(csvCell).join(','));
  }

  downloadBlob('ShotLedger_export.csv', 'text/csv;charset=utf-8', lines.join('\n'));
  el('importStatus').innerHTML = `<span class="good">Exported CSV (states + MOA + Δσ + distance authority).</span>`;
}

  function exportJSON(){
  if(!smShots.length && !gFiles.length && !kSamples.length){
    el('importStatus').innerHTML = `<span class="bad">Nothing to export yet.</span>`;
    return;
  }

  // Ensure snapshots are current
  recomputeBlockStats();
  recomputeGeoStats();

  // Build per-block snapshot (distance authority + stats)
  const groups = groupByBlock();
  const blocks = [];
  for(const [block, list] of groups.entries()){
    const distYd = distForBlock(block);
    const distSrc = blockDist.has(block) ? 'MAN' : (blockAutoDist.has(block) ? 'SM' : 'DEF');
    const vel = blockStats.get(block) || computeVelStats(list);
    const geo = geoStats.get(block) || computeGeoStatsForBlock(block, list);
    const wind = computeWindStats(list);

    blocks.push({
      block,
      distance: {
        yd: distYd,
        src: distSrc,
        manualYd: (blockDist.has(block) ? Number(blockDist.get(block)) : null),
        shotMarkerYd: (blockAutoDist.has(block) ? Number(blockAutoDist.get(block)) : null),
        defaultYd: defaultDistYd
      },
      velStats: vel,
      geoStats: geo,
      windStats: wind
    });
  }

  const payload = {
    version: '1.5.41',
    exportedAt: new Date().toISOString(),
    ui: {
      activeBlock: activeBlock || null,
      defaultDistYd: defaultDistYd,
      anchors: {
        sessionDate: el('sessionDate') ? el('sessionDate').value : '',
        aShot: el('aShot') ? Number(el('aShot').value) : null,
        aTime: el('aTime') ? el('aTime').value : '',
        bShot: el('bShot') ? Number(el('bShot').value) : null,
        bTime: el('bTime') ? el('bTime').value : '',
        tol: el('tolSel') ? Number(el('tolSel').value) : null
      },
      garminFiles: gFiles.map(g=>({name:g.name, n:(g.shots?g.shots.length:0), startIdx:g.startIdx||1})),
      chronoPairings: Array.from(chronoPair.entries()).map(([block,v])=>({block, name:v.name||'', start:(v.start||1)}))
    },
    blocks,
    shots: smShots.map(s=>{
      const f = velFlagForShot(s);
      const distYd = distForBlock(s.block);
      const distSrc = blockDist.has(s.block) ? 'MAN' : (blockAutoDist.has(s.block) ? 'SM' : 'DEF');
      return {
        idx: s.idx,
        block: s.block,
        relTime: s.relTime,
        tag: s.tag,
        score: s.score,
        // velocity
        velSM: s.velSM,
        velActive: s.velActive,
        velSrc: s.velSrc,
        // state + provenance
        state: (s.state||'RECORD'),
        stateSrc: (s.stateSrc||''),
        // distance used for MOA/stats
        distanceYd: distYd,
        distanceSrc: distSrc,
        // geometry
        xIn: s.xIn,
        yIn: s.yIn,
        hMoa: s.hMoa,
        vMoa: s.vMoa,
        rMoa: s.rMoa,
        // delta-sigma
        deltaSigmaAbs: (f && f.text ? f.az : null),
        deltaSigmaLevel: (f && f.text ? f.level : null),
        // AMP (optional)
        ampPeak: (s.ampPeak!=null && Number.isFinite(+s.ampPeak)) ? +s.ampPeak : null,
        ampWork: (s.ampWork!=null && Number.isFinite(+s.ampWork)) ? +s.ampWork : null,
        ampStartPos: (s.ampStartPos!=null && Number.isFinite(+s.ampStartPos)) ? +s.ampStartPos : null,
        ampZ: (s.ampZ!=null && Number.isFinite(+s.ampZ)) ? +s.ampZ : null,
        ampZPeak: (s.ampZPeak!=null && Number.isFinite(+s.ampZPeak)) ? +s.ampZPeak : null,
        ampZWork: (s.ampZWork!=null && Number.isFinite(+s.ampZWork)) ? +s.ampZWork : null,
        ampZStart: (s.ampZStart!=null && Number.isFinite(+s.ampZStart)) ? +s.ampZStart : null,
        // manual inputs
        primerSeat: (s.primerSeat!=null ? s.primerSeat : null),
        windZero: (s.windZero!=null ? s.windZero : null),
        elevZero: (s.elevZero!=null ? s.elevZero : null),
        windCall: (s.windCall || null),
        notes: (s.notes || null),
        // kestrel join summary
        kestrel: (s.k ? s.k.formatted : null),
        join: s.j || null,
        dt: s.kdt,
        k: (s.k ? s.k : null)
      };
    })
  };

  downloadBlob('ShotLedger_export.json', 'application/json;charset=utf-8', JSON.stringify(payload, null, 2));
  el('importStatus').innerHTML = `<span class="good">Exported JSON (blocks + shots + distance authority + stats snapshots).</span>`;


  // ---------- Phase 5.4.7: Clear + JSON Import ----------
  function clearAll(){
    smShots = [];
    smBlocks = [];
    activeBlock = null;
    smFirstDate = null;

    // reset distances
    defaultDistYd = 1000;
    blockDist.clear();
    blockAutoDist.clear();
    geoStats = new Map();
    blockStats = new Map();

    // reset kestrel
    kSamples = [];
    kRange = null;
    if(kMeta) kMeta.textContent = 'No file loaded';

    // reset garmin
    gFiles = [];
    undo = null;

    // clear file inputs so re-select works
    const fsm = el('fileSM'); if(fsm) fsm.value = '';
    const fk  = el('fileK');  if(fk) fk.value = '';
    const fg  = el('fileG');  if(fg) fg.value = '';
    const fa  = el('fileAMP'); if(fa) fa.value = '';
    const fj  = el('fileJSON'); if(fj) fj.value = '';

    // UI resets
    setPills(null, null, null);
    if(importStatus) importStatus.innerHTML = `<span class="hint">Cleared. Import a ShotMarker CSV or JSON to begin.</span>`;
    if(kStatus) kStatus.innerHTML = '';
    if(blocksMeta){ blocksMeta.textContent = 'Rollups, distance, filters'; blocksMeta.title=''; }
    if(el('blockHint')) el('blockHint').textContent = 'Load ShotMarker or JSON to see block rollups.';
    if(el('defaultDist')) el('defaultDist').value = defaultDistYd;

    renderGarminMapping();
    renderBlockRollups();
    renderTable();
    if(el('importStatus')) el('importStatus').innerHTML = `<span class="good">Cleared.</span>`;
  }

  function importFromJSON(txt, name){
    const data = JSON.parse(txt);

    if(!data || !Array.isArray(data.shots)){
      throw new Error('Invalid ShotLedger JSON (missing shots[]).');
    }

    // Clear first (but keep rollups collapsed state etc.)
    smShots = [];
    smBlocks = [];
    activeBlock = (data.ui && data.ui.activeBlock) ? data.ui.activeBlock : null;

    // UI defaults
    defaultDistYd = (data.ui && Number.isFinite(+data.ui.defaultDistYd)) ? +data.ui.defaultDistYd : 1000;
    if(el('defaultDist')) el('defaultDist').value = defaultDistYd;

    // Restore distances per block
    blockDist.clear();
    blockAutoDist.clear();
    if(Array.isArray(data.blocks)){
      for(const b of data.blocks){
        if(!b || !b.block) continue;
        const dist = b.distance || {};
        if(dist && Number.isFinite(+dist.manualYd) && +dist.manualYd>0){
          blockDist.set(b.block, +dist.manualYd);
        }
        if(dist && Number.isFinite(+dist.shotMarkerYd) && +dist.shotMarkerYd>0){
          blockAutoDist.set(b.block, +dist.shotMarkerYd);
        }
      }
    }

    // Restore shots
    for(const s of data.shots){
      if(!s) continue;
      const sh = {
        idx: Number(s.idx),
        block: s.block || '(unknown)',
        blockDate: s.blockDate || '',
        relTime: s.relTime || '',
        tag: s.tag || '',
        score: s.score || '',
        vel: (s.velSM!=null ? String(s.velSM) : (s.vel!=null ? String(s.vel) : '')),
        velSM: (s.velSM!=null && Number.isFinite(+s.velSM)) ? +s.velSM : null,
        velActive: (s.velActive!=null && Number.isFinite(+s.velActive)) ? +s.velActive : ((s.velSM!=null && Number.isFinite(+s.velSM)) ? +s.velSM : null),
        velSrc: s.velSrc || 'SM',
        // geometry
        xIn: (s.xIn!=null && Number.isFinite(+s.xIn)) ? +s.xIn : null,
        yIn: (s.yIn!=null && Number.isFinite(+s.yIn)) ? +s.yIn : null,
        hMoa: (s.hMoa!=null && Number.isFinite(+s.hMoa)) ? +s.hMoa : null,
        vMoa: (s.vMoa!=null && Number.isFinite(+s.vMoa)) ? +s.vMoa : null,
        rMoa: (s.rMoa!=null && Number.isFinite(+s.rMoa)) ? +s.rMoa : null,
        // state + provenance
        state: s.state || 'RECORD',
        stateSrc: s.stateSrc || '',
        // kestrel (optional)
        j: s.j || s.join || null,
        kdt: (s.kdt!=null && Number.isFinite(+s.kdt)) ? +s.kdt : (s.dt!=null && Number.isFinite(+s.dt) ? +s.dt : null),
        k: s.k || null
      };
      smShots.push(sh);
    }

    // Rebuild blocks list
    const seen = new Map();
    for(const sh of smShots){
      if(!seen.has(sh.block)) seen.set(sh.block, {label: sh.block, dateStr: sh.blockDate || '', n: 0, distYdAuto: blockAutoDist.get(sh.block) || null});
      seen.get(sh.block).n += 1;
    }
    smBlocks = Array.from(seen.values());

    // Attempt to set first date (for Kestrel date helper)
    smFirstDate = null;
    for(const b of smBlocks){
      const dt = parseSMDateStr(b.dateStr);
      if(dt){ smFirstDate = dt; break; }
    }

    // Pills/status
    setPills(name || 'ShotLedger JSON', (kSamples.length? (kMeta.textContent||'Kestrel loaded') : null),
             (gFiles.length ? gFiles.map(g=>({name:g.name,count:(g.shots?g.shots.length:0)})) : null));
    importStatus.innerHTML = `<span class="good">Imported JSON.</span> <span class="hint">Shots: <b>${smShots.length}</b> • Blocks: <b>${smBlocks.length}</b></span>`;

    // Recompute derived stats to ensure everything is coherent (MOA will be recomputed if coords exist)
    recomputeBlockStats();
    recomputeGeoStats();
    renderBlockRollups();
    renderTable();
  }
}

  function csvCell(v){
    const s = (v==null) ? '' : String(v);
    if(/[",\n\r]/.test(s)) return '"' + s.replace(/"/g,'""') + '"';
    return s;
  }


  
  function geoLine(block){
    const gs = geoStats.get(block);
    if(!gs || !gs.n) return '';
    const parts = [];
    parts.push(` • Dist ${Math.round(gs.distYd)}yd`);
    parts.push(` • Rad ES ${gs.radialESmoa!=null ? gs.radialESmoa.toFixed(2) : '—'}`);
    parts.push(` • V ES ${gs.vertESmoa!=null ? gs.vertESmoa.toFixed(2) : '—'}`);
    parts.push(` • H ES ${gs.horizESmoa!=null ? gs.horizESmoa.toFixed(2) : '—'}`);
    parts.push(` • MR ${gs.mrMoa!=null ? gs.mrMoa.toFixed(2) : '—'}`);
    return parts.join('');
  }

function renderBlockRollups(){
    const roll = el('blockRollups');
    const hint = el('blockHint');
    if(!roll || !hint) return;
    const showChronoCtl = shouldShowChronoControls();
    if(!smShots.length){
      hint.textContent = 'Load ShotMarker to see block rollups.';
      roll.innerHTML = '';
      return;
    }

    const groups = groupByBlock();

    // Mixed-distance hint (based on ShotMarker headers + overrides)
    const distSet = new Set();
    for(const blk of groups.keys()){
      const d = distForBlock(blk);
      if(Number.isFinite(d) && d>0) distSet.add(Math.round(d));
    }
    const distList = [...distSet].sort((a,b)=>a-b);

    const baseHint = activeBlock
      ? `Filtered to: ${activeBlock}`
      : `Showing all blocks (${groups.size}). Click a block to filter the table.`;

    const distHint = (distList.length>1)
      ? ` ⚠ Mixed distances detected: ${distList.join(', ')}yd. (Default distance is only used when a block has no ShotMarker yardage and no manual override.)`
      : '';

    hint.textContent = baseHint + distHint;

    // Ensure geometry is current (state toggles or distance edits)
    recomputeGeoStats();

    const items = [];
    for(const [block, list] of groups.entries()){
      const c = countStates(list);
      const isActive = (activeBlock === block);
      const vs = computeVelStats(list);
      const vLine = (vs.n===0)
        ? 'Vel —'
        : `Vel ${Math.round(vs.mean)} | SD ${vs.sd!=null ? vs.sd.toFixed(1) : '—'} | ES ${vs.es!=null ? Math.round(vs.es) : '—'}`;

      const gs = geoStats.get(block);
      const distYd = (gs && gs.distYd!=null) ? gs.distYd : distForBlock(block);

      // Distance authority: manual override > ShotMarker header > default
      const distSrc = blockDist.has(block) ? 'MAN' : (blockAutoDist.has(block) ? 'SM' : 'DEF');
      const distTag = distSrc==='SM' ? ' (SM)' : (distSrc==='MAN' ? ' (man)' : '');
      const gLine = (gs && gs.n)
        ? `Dist ${Math.round(distYd)}yd${distTag} | Rad ${gs.radialESmoa!=null ? gs.radialESmoa.toFixed(2) : '—'} | V ${gs.vertESmoa!=null ? gs.vertESmoa.toFixed(2) : '—'} | H ${gs.horizESmoa!=null ? gs.horizESmoa.toFixed(2) : '—'} | MR ${gs.mrMoa!=null ? gs.mrMoa.toFixed(2) : '—'}`
        : `Dist ${Math.round(distYd)}yd${distTag}`;

      const ws = computeWindStats(list);
      let wLine = '';
      if(ws && ws.n>0){
        const inst = windInstabilityLabel(ws);
        const exp = windExplainLabel(ws.r);
        const joinPct = ws.rec>0 ? Math.round(100*ws.n/ws.rec) : 0;
        const brTxt = (ws.bracket!=null && Number.isFinite(ws.bracket)) ? `${ws.min.toFixed(1)}–${ws.max.toFixed(1)}` : '—';
        const sdTxt = (ws.sd!=null && Number.isFinite(ws.sd)) ? ws.sd.toFixed(1) : '—';
        const meanTxt = (ws.mean!=null && Number.isFinite(ws.mean)) ? ws.mean.toFixed(1) : '—';

        const instCls = (inst && inst.lvl==='OK') ? 'ok' : ((inst && inst.lvl==='VAR') ? 'warn' : ((inst && inst.lvl==='WILD') ? 'bad' : 'neutral'));

        wLine = `Wind avg ${meanTxt} | SD ${sdTxt} | Br ${brTxt} | ${joinPct}% joined` +
               (inst ? ` <span class="windChip ${instCls}" title="${esc(inst.title)}">${inst.icon}</span>` : '') +
               (exp ? ` <span class="windChip neutral" title="${esc(exp.title)}">Explains H: ${esc(exp.txt)}</span>` : '');
      }

      const countsLine = `${c.total} shots | ${c.rec} record | ${c.sgt} sighters | ${c.exc} excluded`;

      items.push({block, c, isActive, vs, vLine, wLine, gLine, countsLine, distYd, distSrc});
    }

    // preserve original order from smBlocks when possible
    const order = new Map(smBlocks.map((b,i)=>[b.label, i]));
    items.sort((a,b)=>{
      const ai = order.has(a.block) ? order.get(a.block) : 1e9;
      const bi = order.has(b.block) ? order.get(b.block) : 1e9;
      return ai - bi;
    });

    roll.innerHTML = items.map(it=>{
      const sd = it.vs && it.vs.sd!=null ? it.vs.sd : null;
      const es = it.vs && it.vs.es!=null ? it.vs.es : null;
      const warn = (sd!=null && sd>15) || (es!=null && es>40);

      const srcCls = it.distSrc==='SM' ? 'sm' : (it.distSrc==='MAN' ? 'man' : 'def');
      const srcTxt = it.distSrc==='SM' ? 'SM' : (it.distSrc==='MAN' ? 'MAN' : 'DEF');
      const srcTitle = it.distSrc==='SM'
        ? 'Distance from ShotMarker header'
        : (it.distSrc==='MAN' ? 'Manual distance override (double-click to reset)' : 'Default distance');

      return `<div class="blockRow ${it.isActive?'active':''}" data-block="${esc(it.block)}" title="Click to filter table to this block">
        <div class="l">
          <div class="title">${esc(it.block)}</div>
          <div class="meta">
            <div class="metaLine metaCounts">${esc(it.countsLine||'')}</div>
            <div class="metaLine metaVel">${esc(it.vLine||'')}</div>
            <div class="metaLine metaGeo">${esc(it.gLine||'')}</div>
            ${it.wLine ? `<div class="metaLine metaWind">${it.wLine}</div>` : ``}
          </div>
        </div>
        <div class="stats">
          <span class="bchip rec">R ${it.c.rec}</span>
          <span class="bchip sgt">S ${it.c.sgt}</span>
          <span class="bchip exc">✕ ${it.c.exc}</span>
          <div class="chronoCtl ${showChronoCtl ? "" : "hidden"}" title="Pair this ShotMarker target to a chrono file (one file per target).">
            <select class="chronoSel" data-chrono="${esc(it.block)}">
              <option value="">— Chrono —</option>
              ${gFiles.map(g=>`<option value="${esc(g.name)}" ${((chronoPair.get(it.block)||{}).name===g.name)?'selected':''}>${esc(g.name)}</option>`).join('')}
            </select>
            <input class="chronoStart" data-chrono-start="${esc(it.block)}" type="number" min="1" step="1"
                   value="${(chronoPair.get(it.block)&&chronoPair.get(it.block).start)||1}"
                   title="Start shot # within the chrono file (1-based)"/>
          </div>

          ${(it.c.rec<5) ? `<span class="warnChip" title="Low sample: fewer than 5 record shots in this block. Treat stats cautiously.">n<5</span>` : ``}
          ${((it.vs && it.vs.n>0 && (!it.vs.sd || !Number.isFinite(it.vs.sd) || it.vs.sd<=0)) ? `<span class="warnChip" title="SD not available (need ≥3 record velocities). Δσ flags disabled for this block.">SD?</span>` : ``)}
          <span class="distSrc ${srcCls}" title="${esc(srcTitle)}">${esc(srcTxt)}</span>
          <input class="distInput" data-dist="${esc(it.block)}" type="number" min="10" step="1"
                 value="${Math.round(distForBlock(it.block))}"
                 title="Distance (yd) for this block. Change to override; double-click to reset to SM/default."/>
          ${warn ? `<span class="warnChip" title="Heads-up: SD>15 or ES>40 (record shots only)">⚠</span>` : ``}
        </div>
      </div>`;
    }).join('');

    // Manual inputs: refresh string dropdown
    const msel = el('manBlockSel');
    if(msel){
      const opts = [`<option value="">— Select string —</option>`]
        .concat(items.map(it=>`<option value="${esc(it.block)}" ${(msel.value===it.block || activeBlock===it.block)?'selected':''}>${esc(it.block)}</option>`));
      msel.innerHTML = opts.join('');
    }
  }

// ---------- rendering ----------
  function renderTable(){
    const tbody = el('shotTbody');
    if(!tbody) return;

    // Ensure we have a stable per-block shot index (1..N in file order)
    // This supports "sorted 1–22 within each target".
    let need = false;
    for(const sh of smShots){ if(sh && sh.inBlock==null){ need = true; break; } }
    if(need){
      const ctr = new Map();
      for(const sh of smShots){
        const b = sh.block || '';
        const n = (ctr.get(b)||0) + 1;
        ctr.set(b, n);
        sh.inBlock = n;
      }
    }

    const buildRow = (sh, numOverride) => {
      const k = sh.k;
      const tag = sh.tag ? `<span class="tagpill">${esc(sh.tag)}</span>` : '';
      const st = (sh.state||'RECORD');
      const src = (sh.stateSrc||'');
      let trCls = (st==='EXCLUDE') ? (`row-exclude ${src==='FLAG' ? 'row-exclude-flag' : 'row-exclude-manual'}`) : (st==='SIGHTER' ? 'row-sighter' : '');
      if(gFiles.length && !sh.gMapped) trCls += (trCls?' ':'') + 'row-garmiss';

      const num = (numOverride!=null ? numOverride : (sh.inBlock!=null ? sh.inBlock : sh.idx));

      return `<tr class="${trCls}">
        <td class="sticky c0"><input type="checkbox" class="rowSel" data-sel="${sh.idx}" ${selectedShots.has(sh.idx)?"checked":""}></td>
        <td class="sticky c1">${num}</td>
        <td class="sticky c2">${esc(sh.block||'')}</td>
        <td class="sticky c3">${stateCell(sh)}</td>
        <td>${esc(sh.relTime||'')}</td>
        <td>${tag}</td>
        <td>${esc(sh.score||'')}</td>
        <td>${formatVel(sh.velActive, sh.vel)}</td>
        <td>${esc(sh.velSrc||'SM')}</td>
        <td>${ampValCell('Peak', sh.ampPeak, sh.ampZPeak)}</td>
        <td>${ampValCell('Work', sh.ampWork, sh.ampZWork)}</td>
        <td>${ampPill(sh)}</td>
        <td>${flagCell(sh)}</td>
        <td>${fmtIn(sh.xIn)}</td>
        <td>${fmtIn(sh.yIn)}</td>
        <td>${fmtMoa(sh.hMoa)}</td>
        <td>${fmtMoa(sh.vMoa)}</td>
        <td>${fmtMoa(sh.rMoa)}</td>
        <td>${k ? esc(k.formatted) : ''}</td>
        <td>${joinPill(sh.j)}</td>
        <td>${(sh.kdt!=null && Number.isFinite(sh.kdt)) ? sh.kdt.toFixed(1) : ''}</td>
        <td>${k && k.crosswind!=null ? k.crosswind.toFixed(1) : ''}</td>
        <td>${k && k.headwind!=null ? k.headwind.toFixed(1) : ''}</td>
        <td>${k && k.windSpeed!=null ? k.windSpeed.toFixed(1) : ''}</td>
        <td>${k && k.trueDir!=null ? k.trueDir.toFixed(0) : ''}</td>
        <td>${k && k.temp!=null ? k.temp.toFixed(1) : ''}</td>
        <td>${k && k.rh!=null ? k.rh.toFixed(1) : ''}</td>
        <td>${k && k.stationP!=null ? k.stationP.toFixed(2) : ''}</td>
        <td>${k && k.da!=null ? k.da.toFixed(0) : ''}</td>
        <td>${fmtIn(sh.primerSeat)}</td>
        <td>${fmtMoa(sh.windZero)}</td>
        <td>${fmtMoa(sh.elevZero)}</td>
        <td>${esc(sh.windCall||'')}</td>
        <td>${esc(sh.notes||'')}</td>
      </tr>`;
    };

    // Active block view keeps sorting behavior (click headers)
    if(activeBlock){
      let view = smShots.filter(s=>s.block===activeBlock);

      const key = tableSort && tableSort.key ? tableSort.key : null;
      const dir = (tableSort && tableSort.dir) ? tableSort.dir : 1;

      function sortVal(sh, k){
        const st = (sh.state||'RECORD');
        if(k==='idx') return sh.inBlock!=null ? sh.inBlock : sh.idx;
        if(k==='block') return String(sh.block||'');
        if(k==='state') return st;
        if(k==='relTime') return String(sh.relTime||'');
        if(k==='score') return String(sh.score||'');
        if(k==='vel') return (sh.velActive!=null && Number.isFinite(sh.velActive)) ? sh.velActive : null;
        if(k==='velSrc') return String(sh.velSrc||'');
        if(k==='dsigma'){
          const f = velFlagForShot(sh);
          return (f && Number.isFinite(f.az)) ? f.az : null;
        }
        if(k==='xIn') return (sh.xIn!=null && Number.isFinite(sh.xIn)) ? sh.xIn : null;
        if(k==='yIn') return (sh.yIn!=null && Number.isFinite(sh.yIn)) ? sh.yIn : null;
        if(k==='hMoa') return (sh.hMoa!=null && Number.isFinite(sh.hMoa)) ? sh.hMoa : null;
        if(k==='vMoa') return (sh.vMoa!=null && Number.isFinite(sh.vMoa)) ? sh.vMoa : null;
        if(k==='rMoa') return (sh.rMoa!=null && Number.isFinite(sh.rMoa)) ? sh.rMoa : null;
        if(k==='kTime') return sh.k ? String(sh.k.formatted||'') : '';
        if(k==='join') return String(sh.j||'');
        if(k==='kdt') return (sh.kdt!=null && Number.isFinite(sh.kdt)) ? sh.kdt : null;
        if(k==='crosswind') return (sh.k && sh.k.crosswind!=null) ? sh.k.crosswind : null;
        if(k==='headwind') return (sh.k && sh.k.headwind!=null) ? sh.k.headwind : null;
        if(k==='windSpeed') return (sh.k && sh.k.windSpeed!=null) ? sh.k.windSpeed : null;
        if(k==='trueDir') return (sh.k && sh.k.trueDir!=null) ? sh.k.trueDir : null;
        if(k==='temp') return (sh.k && sh.k.temp!=null) ? sh.k.temp : null;
        if(k==='rh') return (sh.k && sh.k.rh!=null) ? sh.k.rh : null;
        if(k==='stationP') return (sh.k && sh.k.stationP!=null) ? sh.k.stationP : null;
        if(k==='da') return (sh.k && sh.k.da!=null) ? sh.k.da : null;
        if(k==='primerSeat') return (sh.primerSeat!=null && Number.isFinite(sh.primerSeat)) ? sh.primerSeat : null;
        if(k==='windZero') return (sh.windZero!=null && Number.isFinite(sh.windZero)) ? sh.windZero : null;
        if(k==='elevZero') return (sh.elevZero!=null && Number.isFinite(sh.elevZero)) ? sh.elevZero : null;
        if(k==='windCall') return String(sh.windCall||'');
        if(k==='notes') return String(sh.notes||'');
        return null;
      }

      if(key){
        view = [...view].sort((a,b)=>{
          const va = sortVal(a,key);
          const vb = sortVal(b,key);

          if(va==null && vb==null) return 0;
          if(va==null) return 1;
          if(vb==null) return -1;

          if(typeof va==='number' && typeof vb==='number') return dir*(va-vb);
          return dir*String(va).localeCompare(String(vb));
        });
      } else {
        // default: 1..22 within block
        view = [...view].sort((a,b)=> (a.inBlock||0) - (b.inBlock||0));
      }

      const rows = view.slice(0,200).map(sh=> buildRow(sh)).join('');
      tbody.innerHTML = rows || `<tr><td colspan="31" style="color:rgba(230,238,248,.6); padding:16px;">Load ShotMarker CSV to see shots.</td></tr>`;
      updateSelPill();
      updateSortIndicators();
      return;
    }

    // ----- All shots view: group by target (block) with rollups -----
    const colCount = document.querySelectorAll('#shotTable thead th').length || 1;

    // Order blocks as they appeared in ShotMarker (smBlocks), fall back to grouped keys
    const order = (smBlocks && smBlocks.length) ? smBlocks.map(b=>b.label) : Array.from(groupByBlock().keys());
    const groups = groupByBlock();

    const out = [];
    let shown = 0;
    const LIMIT = 200;

    for(const block of order){
      const list0 = groups.get(block);
      if(!list0 || !list0.length) continue;

      const list = [...list0].sort((a,b)=> (a.inBlock||0) - (b.inBlock||0));

      // header counts
      let nRec=0, nSgt=0, nExc=0;
      for(const sh of list){
        const st = (sh.state||'RECORD');
        if(st==='SIGHTER') nSgt++;
        else if(st==='EXCLUDE') nExc++;
        else nRec++;
      }
      const dist = distForBlock(block);
      const distTxt = (dist!=null && Number.isFinite(dist) && dist>0) ? ` • ${Math.round(dist)}yd` : '';
      const caret = collapsedBlocks.has(block) ? '▶' : '▼';

      out.push(`<tr class="tGroupHeader" data-block="${esc(block)}">
        <td colspan="${colCount}">
          <span class="tCaret">${caret}</span>
          <span class="tTitle">${esc(block)}</span>
          <span class="tMeta">${list.length} shots • <span class="good">R</span> ${nRec} • <span class="warn">S</span> ${nSgt} • <span class="bad">X</span> ${nExc}${distTxt}</span>
        </td>
      </tr>`);

      if(collapsedBlocks.has(block)) continue;

      for(const sh of list){
        if(shown >= LIMIT){
          out.push(`<tr class="tGroupFooter"><td colspan="${colCount}" class="hint" style="padding:14px;">Showing first ${LIMIT} rows in All view. Use Blocks to drill into a single target.</td></tr>`);
          break;
        }
        shown++;
        out.push(buildRow(sh, sh.inBlock!=null ? sh.inBlock : sh.idx));
      }
      if(shown >= LIMIT) break;
    }

    tbody.innerHTML = out.join('') || `<tr><td colspan="${colCount}" style="color:rgba(230,238,248,.6); padding:16px;">Load ShotMarker CSV to see shots.</td></tr>`;
    updateSelPill();
    updateSortIndicators();
  }


  function renderSummaries(){
    const btxt = smBlocks.slice(0,5).map((b,i)=>`${i+1}. ${b.label} — ${b.n} shots`).join("\n");
    const metaLine = smBlocks.length ? `${smBlocks.length} blocks • ${smShots.length} shots` : `Rollups, distance, filters`;
    if(blocksMeta){
      blocksMeta.textContent = metaLine;
      if(smBlocks.length){
        blocksMeta.title = `Blocks found: ${smBlocks.length}
Total shots (incl. sighters): ${smShots.length}
First 5 blocks:
${btxt}`;
      } else {
        blocksMeta.title = '';
      }
    }
  }


  // Phase 3 Step 1: state toggle delegation
  shotTbody.addEventListener('click', (e)=>{

    // Group header toggle in All view
    const hdr = e.target && e.target.closest ? e.target.closest('tr.tGroupHeader[data-block]') : null;
    if(hdr && !activeBlock){
      const block = hdr.getAttribute('data-block') || '';
      if(block){
        if(collapsedBlocks.has(block)) collapsedBlocks.delete(block);
        else collapsedBlocks.add(block);
        renderTable();
      }
      return;
    }

    // Phase 3 Step 1: state toggle delegation
    const btn = e.target && e.target.closest ? e.target.closest('button[data-idx][data-state]') : null;
    if(!btn) return;
    const idx = parseInt(btn.getAttribute('data-idx')||'', 10);
    const st = btn.getAttribute('data-state')||'RECORD';
    const src = (st==='EXCLUDE') ? 'MANUAL' : 'MANUAL';
    setShotStateByIdx(idx, st, true, src);
  });


  // ---------- UI wiring ----------

  el('clearBlockFilterBtn').addEventListener('click', ()=>{
    activeBlock = null;
    renderTable();
    renderBlockRollups();
  });

  el('blockRollups').addEventListener('click', (e)=>{
    const inp = e.target && e.target.closest ? e.target.closest('input.distInput[data-dist]') : null;
    if(inp){
      const blk = inp.getAttribute('data-dist');
      const n = Number(inp.value);
      if(blk && Number.isFinite(n) && n>0){
        blockDist.set(blk, n);
        recomputeGeoStats();
        renderBlockRollups();
        renderTable();
      }
      return;
    }
    const row = e.target && e.target.closest ? e.target.closest('.blockRow[data-block]') : null;
    if(!row) return;
    const block = row.getAttribute('data-block');
    activeBlock = (activeBlock === block) ? null : block;
    renderTable();
    renderBlockRollups();
  });

  el('blockRollups').addEventListener('change', (e)=>{
    // Chrono pairing dropdown
    const sel = e.target && e.target.closest ? e.target.closest('select.chronoSel[data-chrono]') : null;
    if(sel){
      const blk = sel.getAttribute('data-chrono');
      const name = sel.value || '';
      const cur = chronoPair.get(blk) || {name:'', start:1};
      cur.name = name;
      chronoPair.set(blk, cur);
      applyChronoPairings();
      return;
    }

    // Chrono start shot #
    const cs = e.target && e.target.closest ? e.target.closest('input.chronoStart[data-chrono-start]') : null;
    if(cs){
      const blk = cs.getAttribute('data-chrono-start');
      const start = Math.max(1, Number(cs.value||1));
      const cur = chronoPair.get(blk) || {name:'', start:1};
      cur.start = start;
      chronoPair.set(blk, cur);
      applyChronoPairings();
      return;
    }

    // Distance override
    const inp = e.target && e.target.closest ? e.target.closest('input.distInput[data-dist]') : null;
    if(!inp) return;
    const blk = inp.getAttribute('data-dist');
    const n = Number(inp.value);
    if(blk && Number.isFinite(n) && n>0){
      blockDist.set(blk, n);
      recomputeGeoStats();
      renderBlockRollups();
      renderTable();
    }
  });

  // Phase 5.4.1: double-click distance box to clear manual override (revert to SM header / default)
  el('blockRollups').addEventListener('dblclick', (e)=>{
    const inp = e.target && e.target.closest ? e.target.closest('input.distInput[data-dist]') : null;
    if(!inp) return;
    const blk = inp.getAttribute('data-dist');
    if(!blk) return;
    if(blockDist.has(blk)){
      blockDist.delete(blk);
      recomputeGeoStats();
      renderBlockRollups();
      renderTable();
      el('importStatus').innerHTML = `<span class="hint">Distance override cleared for ${esc(blk)}.</span>`;
    } else {
      // if no manual override, a double-click is a no-op (but feels responsive)
      el('importStatus').innerHTML = `<span class="hint">No manual distance override set for ${esc(blk)}.</span>`;
    }
  });




  el('btnSM').addEventListener('click', ()=>el('fileSM').click());
  el('btnK').addEventListener('click', ()=>el('fileK').click());
  el('btnG').addEventListener('click', ()=>el('fileG').click());
    el('btnAMP').addEventListener('click', ()=>el('fileAMP').click());
    el('btnAMPClear').addEventListener('click', ()=>{
    ampSession = null;
    if(smShots && smShots.length){
      for(const sh of smShots){
        sh.ampPeak = null;
        sh.ampWork = null;
        sh.ampStartPos = null;
        sh.ampZ = null;
      }
    }
    const fa = el('fileAMP');
    if(fa) fa.value = '';
    recomputeBlockStats();
    renderBlockRollups();
    renderTable();
    toast('AMP cleared');
  });
el('fileSM').addEventListener('change', async (e)=>{
    const f = e.target.files && e.target.files[0];
    if(!f) return;
    const text = await f.text();
    const {blocks, shots} = parseShotMarkerArchive(text);
    smBlocks = blocks;
    smShots = shots;
    // capture any auto distance from ShotMarker headers
    blockAutoDist = new Map();
    for(const b of smBlocks){
      if(b && b.label){
        const n = Number(b.distYdAuto);
        if(Number.isFinite(n) && n>0) blockAutoDist.set(b.label, n);
      }
    }
    // If user hasn't changed default distance yet, and ShotMarker provides one, seed the default distance.
    const defInput = el('defaultDist');
    if(defInput){
      const cur = Number(defInput.value);
      if(!(Number.isFinite(cur) && cur>0) && blockAutoDist.size){
        defInput.value = String(Math.round([...blockAutoDist.values()][0]));
      }
    }

    for(const sh of smShots){
      const smv = parseFloat(String(sh.vel||'').trim());
      sh.velSM = Number.isFinite(smv) ? smv : null;
      sh.velActive = sh.velSM;
      sh.xMmNum = safeNum(sh.xMm);
      sh.yMmNum = safeNum(sh.yMm);
      sh.xIn = (sh.xMmNum!=null) ? (sh.xMmNum/25.4) : null;
      sh.yIn = (sh.yMmNum!=null) ? (sh.yMmNum/25.4) : null;
      sh.hMoa = null; sh.vMoa=null; sh.rMoa=null;
      sh.velSrc = 'SM';
      sh.state = inferStateFromTag(sh.tag);
      sh.stateSrc = (sh.state==='SIGHTER') ? 'TAG' : '';
      sh.k = null; sh.kdt = null; sh.j = null;
    }
    smFirstDate = (blocks.length ? parseSMDateStr(blocks[0].dateStr) : null);
    if(gFiles.length){ applyGarminToShots(); applyChronoPairings(); }

    importStatus.innerHTML = '';
    if(!smShots.length){
      importStatus.innerHTML = `<span class="bad">ShotMarker parse: 0 shots found.</span> <span class="hint">Tip: export a ShotMarker <b>Archive CSV</b> (multi-target) or a <b>session CSV</b> that includes Time/Tags/X(mm)/Y(mm)/Vel.</span>`;
    } else {
      importStatus.innerHTML = `<span class="good">ShotMarker OK:</span> ${blocks.length} blocks • ${shots.length} shots flattened.`;
      renderTable();
      renderSummaries();
      renderBlockRollups();
      // default session date to today if empty
      if(!el('sessionDate').value){
        const now = new Date();
        el('sessionDate').value = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-${String(now.getDate()).padStart(2,'0')}`;
      }
    }
    setPills(f.name, (kSamples.length? (kMeta.textContent||'Kestrel loaded') : null), (gFiles.length ? gFiles.map(g=>({name:g.name,count:(g.shots?g.shots.length:0)})) : null));
  });

  el('fileK').addEventListener('change', async (e)=>{
    const f = e.target.files && e.target.files[0];
    if(!f) return;
    const text = await f.text();
    const parsed = parseKestrel(text);
    kSamples = parsed.samples;
    kRange = parsed.range;
    if(parsed.error){
      kMeta.textContent = 'Parse error';
      kStatus.innerHTML = `<span class="bad">${esc(parsed.error)}</span>`;
    } else {
      kMeta.textContent = `${f.name} • ${kSamples.length} samples`;
      kStatus.innerHTML = kRange
        ? `<span class="good">Kestrel OK:</span> ${kSamples.length} samples\n<span class="hint">Kestrel range: ${esc(kRange.minStr)} \u2192 ${esc(kRange.maxStr)}</span>`
        : `<span class="warn">Kestrel loaded but no samples detected.</span>`;
    }
    // update pills
    setPills((smShots.length? 'ShotMarker loaded' : null), f.name, (gFiles.length ? gFiles.map(g=>({name:g.name,count:(g.shots?g.shots.length:0)})) : null));
  });
  el('fileG').addEventListener('change', async (e)=>{
    const files = Array.from(e.target.files || []);
    if(!files.length) return;

    const added = [];
    const errs = [];

    // default sequential starts: append after existing Garmin total
    const existingTotal = gFiles.reduce((acc,g)=>acc + ((g.shots&&g.shots.length)||0), 0);

    let running = existingTotal;

    for(const f of files){
      try{
        const txt = await f.text();
        const parsed = parseGarmin(txt);
        if(parsed.error){
          errs.push(`${f.name}: ${parsed.error}`);
          continue;
        }
        const shots = parsed.shots || [];
        const startIdx = running + 1;
        running += shots.length;

        gFiles.push({name:f.name, shots, startIdx});
        added.push({name:f.name, count: shots.length, startIdx});
      } catch(err){
        errs.push(`${f.name}: ${String(err&&err.message ? err.message : err)}`);
      }
    }

    // allow re-adding the same file name if needed
    e.target.value = '';

    // Apply to current ShotMarker (if loaded)
    const res = smShots.length ? applyGarminToShots() : {matched:0, overrides:0, unmapped:0, extra:0};

    const totalFiles = gFiles.length;
    const totalShots = gFiles.reduce((acc,g)=>acc + ((g.shots&&g.shots.length)||0), 0);

    const lines = [];
    if(errs.length){
      lines.push(`<span class="bad">Garmin issues:</span> ${errs.map(esc).join(' • ')}`);
    }
    if(added.length){
      lines.push(`<span class="good">Garmin added:</span> ${added.map(a=>`${esc(a.name)} (${a.count}) `).join(' • ')}`);
    }
    if(totalFiles){
      lines.push(`<span class="good">Garmin total:</span> ${totalFiles} file(s) • ${totalShots} chrono shots`);
    } else {
      lines.push(`<span class="hint">No Garmin data loaded.</span>`);
    }

    if(smShots.length && totalShots){
      lines.push(`<span class="hint">Matched by mapping: ${res.matched} • Overrides used: ${res.overrides} • Unmapped: ${res.unmapped}</span>`);
      if(totalShots < smShots.length){
        lines.push(`<span class="warn">⚠ Garmin chrono shots (${totalShots}) &lt; ShotMarker shots (${smShots.length}). Some shots will remain SM velocity.</span>`);
      }
      if(res.extra>0){
        lines.push(`<span class="warn">⚠ ${res.extra} Garmin shot(s) map beyond the ShotMarker shot count (check start shot #).</span>`);
      }
    } else if(totalShots && !smShots.length){
      lines.push(`<span class="hint">Load ShotMarker to apply velocities.</span>`);
    }

    importStatus.innerHTML = lines.join("\n");

    setPills((smShots.length? 'ShotMarker loaded' : null), (kSamples.length? (kMeta.textContent||'Kestrel loaded') : null),
             (gFiles.length ? gFiles.map(g=>({name:g.name,count:(g.shots?g.shots.length:0)})) : null));
    renderGarminMapping();
    recomputeBlockStats();
    renderBlockRollups();
    renderTable();
  });

  el('fileAMP').addEventListener('change', async (e)=>{
    const f = e.target.files && e.target.files[0];
    if(!f) return;
    try{
      await importAMPCSV(f);
    }catch(err){
      console.error(err);
      toast('AMP import failed');
    }
  });


  el('btnGClear').addEventListener('click', ()=>{
    gFiles = [];
    if(smShots.length){
      // reset to ShotMarker velocities only
      for(const sh of smShots){
        sh.velActive = sh.velSM;
        sh.velSrc = 'SM';
      }
    }
    importStatus.innerHTML = `<span class="hint">Garmin cleared.</span>`;
    setPills((smShots.length? 'ShotMarker loaded' : null), (kSamples.length? (kMeta.textContent||'Kestrel loaded') : null), null);
    renderGarminMapping();
    recomputeBlockStats();
    renderBlockRollups();
    renderTable();
  });




  
  // ---------- Phase 5.4.7: UX guardrails ----------
  function validateKestrelAnchors(){
    const dateISO = (el('sessionDate').value||'').trim();
    const aShot = clampInt(el('aShot').value, 1, smShots.length||1);
    const bShot = clampInt(el('bShot').value, 1, smShots.length||1);
    const aSec = parseHMS(el('aTime').value);
    const bSec = parseHMS(el('bTime').value);
    if(!smShots.length) return {ok:false, msg:'Load ShotMarker first.'};
    if(!kSamples.length) return {ok:false, msg:'Load Kestrel CSV first.'};
    if(!dateISO) return {ok:false, msg:'Set session date.'};
    if(aSec===null || bSec===null) return {ok:false, msg:'Anchor times must be HH:MM:SS.'};
    if(aShot===bShot) return {ok:false, msg:'Anchor A and B shot # must be different.'};
    return {ok:true, msg:''};
  }

  function updateKestrelApplyGuard(){
    const btn = el('applyBtn');
    if(!btn) return;
    const v = validateKestrelAnchors();
    btn.disabled = !v.ok;
    btn.style.opacity = v.ok ? '1' : '.55';
    btn.style.cursor = v.ok ? 'pointer' : 'not-allowed';
    // Show a quiet helper line when disabled (don’t overwrite real status messages)
    const helperId = 'kGuardHelp';
    let help = document.getElementById(helperId);
    if(!help){
      help = document.createElement('div');
      help.id = helperId;
      help.className = 'hint';
      help.style.marginTop = '8px';
      const kbtns = btn.closest('.kbtns');
      if(kbtns) kbtns.insertAdjacentElement('afterend', help);
    }
    if(help){
      help.textContent = v.ok ? '' : ('Apply is disabled: ' + v.msg);
    }
  }

  el('applyBtn').addEventListener('click', applyKestrel);
  el('clearBtn').addEventListener('click', clearKestrel);
  el('autofitBtn').addEventListener('click', autoFitAnchors);
  el('dateFromSMBtn').addEventListener('click', setDateFromSM);
  // Update Apply guard when anchor inputs change
  ['sessionDate','aShot','bShot','aTime','bTime','tolSel','joinMode','alignMode'].forEach(id=>{
    const n = el(id);
    if(n) n.addEventListener('input', updateKestrelApplyGuard);
    if(n) n.addEventListener('change', updateKestrelApplyGuard);
  });


  el('kHeader').addEventListener('click', ()=>{
    const hide = !kBody.classList.contains('hidden');
    kBody.classList.toggle('hidden', hide);
    kChevron.textContent = hide ? '▸' : '▾';
  });

    // Phase 4 buttons
  if(el('btnUndo')) el('btnUndo').addEventListener('click', undoLast);
  if(el('btnExportCSV')) el('btnExportCSV').addEventListener('click', exportCSV);
  if(el('btnExportJSON')) el('btnExportJSON').addEventListener('click', exportJSON);
  if(el('btnImportJSON')) el('btnImportJSON').addEventListener('click', ()=> el('fileJSON').click());
  if(el('fileJSON')) el('fileJSON').addEventListener('change', async (e)=>{
    const f = e.target.files && e.target.files[0];
    if(!f) return;
    try{
      const txt = await f.text();
      importFromJSON(txt, f.name || 'import.json');
      const _st = el('importStatus') || el('importStatus') || el('status');
      if(_st) _st.innerHTML = `<span class="good">Imported JSON.</span>`;
    }catch(err){
      console.error(err);
      const _st2 = el('importStatus') || el('importStatus') || el('status');
      if(_st2) _st2.innerHTML = `<span class="bad">JSON import failed: ${esc(String(err && err.message ? err.message : err))}</span>`;
    }finally{
      // allow re-importing same file
      e.target.value = '';
    }
  });
  if(el('btnClearAll')) el('btnClearAll').addEventListener('click', clearAll);

  if(el('btnApplyGarminMap')) el('btnApplyGarminMap').addEventListener('click', applyGarminMappingFromUI);
  if(el('btnResetBlockStates')) el('btnResetBlockStates').addEventListener('click', resetStatesInActiveBlock);

  // Click flag chip to exclude shot quickly (and track provenance)
  document.addEventListener('click', (ev)=>{
    const t = ev.target;
    if(!(t instanceof HTMLElement)) return;
    const sid = t.getAttribute('data-flag-shot');
    if(!sid) return;
    const shotIdx = parseInt(sid, 10);
    if(!Number.isFinite(shotIdx)) return;
    const sh = smShots.find(s=>s.idx===shotIdx);
    if(!sh) return;

    // Toggle EXCLUDE by flag:
    // - If already excluded *by flag*, clicking again returns to RECORD.
    // - If excluded manually, a click converts it to "flag exclude" (undo restores).
    const cur = sh.state || 'RECORD';
    const curSrc = sh.stateSrc || '';
    const next = (cur==='EXCLUDE' && curSrc==='FLAG') ? 'RECORD' : 'EXCLUDE';
    const nextSrc = (next==='EXCLUDE') ? 'FLAG' : '';

    setShotStateByIdx(shotIdx, next, true, nextSrc);
    el('importStatus').innerHTML = `<span class="good">Shot #${shotIdx} → ${next}${(next==='EXCLUDE') ? ' (flag)' : ''}</span>`;
  });

  toggleRightBtn.addEventListener('click', ()=>{
    const hidden = rightCol.classList.toggle('hidden');
    gridEl.classList.toggle('fullWidth', hidden);
    toggleRightBtn.textContent = hidden ? 'Show Kestrel panel' : 'Hide Kestrel panel';
  });

  // init session date to today
  const now = new Date();
  el('sessionDate').value = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-${String(now.getDate()).padStart(2,'0')}`;
  renderTable();
  renderSummaries();
  // Phase 5.1 default distance
  const dd = el('defaultDist');
  if(dd){
    dd.value = String(defaultDistYd);
    dd.addEventListener('change', ()=>{
      const n = Number(dd.value);
      if(Number.isFinite(n) && n>0){
        defaultDistYd = n;
        recomputeGeoStats();
        renderBlockRollups();
        renderTable();
      }
    });
  }


  // ---------- Phase 5.4.4: table ergonomics (sticky cols, dense toggle, sorting) ----------
  function updateSortIndicators(){
    const ths = document.querySelectorAll('#shotTable thead th[data-sort]');
    ths.forEach(th=>{
      th.classList.remove('sort-asc','sort-desc');
      const k = th.getAttribute('data-sort');
      if(tableSort && tableSort.key===k){
        th.classList.add(tableSort.dir===1 ? 'sort-asc' : 'sort-desc');
      }
    });
  }

  function setupTableErgonomics(){
    const ths = document.querySelectorAll('#shotTable thead th[data-sort]');
    ths.forEach(th=>{
      th.addEventListener('click', ()=>{
        const k = th.getAttribute('data-sort');
        if(!k) return;
        if(tableSort.key===k) tableSort.dir = -tableSort.dir;
        else { tableSort.key = k; tableSort.dir = 1; }
        renderTable();
        updateSortIndicators();
      });
    });

    const btnDense = el('btnDense');
    const wrap = el('tableWrap');
    if(btnDense && wrap){
      btnDense.addEventListener('click', ()=>{
        wrap.classList.toggle('dense');
        const on = wrap.classList.contains('dense');
        btnDense.classList.toggle('active', on);
        btnDense.textContent = on ? 'Normal' : 'Dense';
      });
    }

    updateSortIndicators();
  }

  setupTableErgonomics();

  // Manual inputs wiring + shot selection
  {
  const shotTbody = el('shotTbody');
  if(shotTbody){
    shotTbody.addEventListener('change', (e)=>{
      const cb = e.target && e.target.classList && e.target.classList.contains('rowSel') ? e.target : null;
      if(!cb) return;
      const id = Number(cb.getAttribute('data-sel'));
      if(!Number.isFinite(id)) return;
      if(cb.checked) selectedShots.add(id); else selectedShots.delete(id);
      updateSelPill();
    });
  }

  const clearSelBtn = el('btnClearSelection');
  if(clearSelBtn){
    clearSelBtn.addEventListener('click', ()=>{
      selectedShots.clear();
      updateSelPill();
      renderTable();
      const st = el('manStatus');
      if(st) st.innerHTML = `<span class="hint">Selection cleared.</span>`;
    });
  }

  const applySelBtn = el('btnApplySelected');
  if(applySelBtn){
    applySelBtn.addEventListener('click', ()=>{
      if(!selectedShots.size){
        const st = el('manStatus');
        if(st) st.innerHTML = `<span class="bad">No shots selected.</span>`;
        return;
      }
      const picked = smShots.filter(s=>selectedShots.has(s.idx));
      const res = applyManualToShots(picked);
      renderTable();
      const st = el('manStatus');
      if(st) st.innerHTML = `<span class="good">Applied manual fields to ${res.changed} selected shot(s).</span>`;
    });
  }

  const applyStrBtn = el('btnApplyToString');
  if(applyStrBtn){
    applyStrBtn.addEventListener('click', ()=>{
      const blk = el('manBlockSel') ? el('manBlockSel').value : '';
      if(!blk){
        const st = el('manStatus');
        if(st) st.innerHTML = `<span class="bad">Pick a string / block first.</span>`;
        return;
      }
      const picked = smShots.filter(s=>s.block===blk);
      const res = applyManualToShots(picked);
      renderTable();
      const st = el('manStatus');
      if(st) st.innerHTML = `<span class="good">Applied manual fields to ${res.changed} shot(s) in ${esc(blk)}.</span>`;
    });
  }

  updateSelPill();
  }

  renderBlockRollups();
})();
</script>
</body>
</html>
