


<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>ShotLedger v2.2.2</title>
<style>
  :root{
    --bg0:#070b12; --bg1:#0b1220; --card: rgba(10,18,32,.72);
    --stroke: rgba(140,170,210,.18);
    --stroke2: rgba(140,170,210,.28);
    --txt:#e6eef8; --muted: rgba(230,238,248,.72);
    --pill:#0f1b2a; --pill2:#0c1625; --accent:#4da3ff;
    --good:#3ddc97; --warn:#f7c46a; --bad:#ff6b6b;
  }
  *{box-sizing:border-box}
  body{
    margin:0; color:var(--txt);
    font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial;
    background: radial-gradient(1200px 800px at 20% 0%, #102849 0%, transparent 60%),
                radial-gradient(1000px 700px at 80% 20%, #0b2a3f 0%, transparent 60%),
                linear-gradient(180deg, var(--bg1), var(--bg0));
    min-height:100vh;
  }
  .wrap{max-width:1320px; margin:0 auto; padding:18px 18px 28px;}
  h1{margin:0 0 4px; font-size:20px; letter-spacing:.2px;}
  .sub{color:var(--muted); margin:0 0 14px;}
  .card{
    background: var(--card);
    border: 1px solid var(--stroke);
    border-radius: 16px;
    box-shadow: 0 10px 40px rgba(0,0,0,.25);
    padding: 14px;
    backdrop-filter: blur(10px);
  }
  .topbar{display:flex; gap:12px; align-items:flex-start; justify-content:space-between;}
  .btn{
    background: linear-gradient(180deg, rgba(25,40,64,.92), rgba(15,27,42,.92));
    border:1px solid var(--stroke2);
    color:var(--txt);
    border-radius: 12px;
    padding: 10px 12px;
    cursor:pointer;
    font-weight:600;
  }
  .btn:active{transform: translateY(1px);}
  .btn.small{padding:8px 10px; border-radius:10px; font-weight:600}
  .btn.ghost{background: transparent;}
  .row{display:flex; flex-wrap:wrap; gap:10px; align-items:center;}
  .pill{
    display:inline-flex; align-items:center; gap:8px;
    padding: 8px 10px; border-radius: 999px;
    background: rgba(15,27,42,.65);
    border:1px solid var(--stroke);
    color: var(--muted);
    max-width:100%;
  }
  .pill b{color:var(--txt); font-weight:700}
  .grid{
    margin-top: 14px;
    display:grid;
    grid-template-columns: minmax(0, 1fr) 420px;
    gap: 14px;
    align-items:start;
  }
  @media (max-width: 1100px){
    .grid{grid-template-columns: 1fr;}
  }

  /* --- Phase 3 layout guardrails (prevent page-level horizontal overflow) --- */
  .grid, .leftCol, .rightCol, .tableCard, .tableWrap{min-width:0;}
  .tableWrap{width:100%; max-width:100%;}
  /* Extra breathing room below the chart area (if present) */
  #shotChart, .shotChart{margin-bottom:10px;}

  /* When Kestrel panel is hidden, let the left pane span full width */
  .grid.fullWidth{grid-template-columns: 1fr !important;}
  .grid.fullWidth .leftCol{grid-column: 1 / -1;}

  /* Phase 5.4.8: prevent left-column text from painting behind sticky Kestrel panel */
  .leftCol{overflow:hidden; position:relative; z-index:1;}
  .rightCol{position:relative; z-index:5;}


  .panelTitle{display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:10px;}
  .panelTitle h2{margin:0; font-size:16px;}
  .status{margin-top:10px; color:var(--muted); white-space:pre-line;}
  .status .good{color:var(--good)}
  .status .warn{color:var(--warn)}
  .status .bad{color:var(--bad)}
  label{display:block; color:var(--muted); font-size:12px; margin:8px 0 6px;}
  input, select{
    width:100%;
    background-color: var(--pill);
    color: var(--txt);
    border: 1px solid var(--stroke2);
    border-radius: 12px;
    padding: 10px 10px;
    font-size: 14px;
  }
  select{appearance:auto;}
  textarea{
    width:100%;
    background-color: var(--pill);
    color: var(--txt);
    border: 1px solid var(--stroke2);
    border-radius: 12px;
    padding: 10px 10px;
    font-size: 14px;
    resize: vertical;
    min-height: 120px;
  }
  textarea::placeholder{color: rgba(230,238,248,.45);}

  input:focus, select:focus{
    outline:none;
    border-color: rgba(77,163,255,.75);
    box-shadow: 0 0 0 2px rgba(77,163,255,.20);
  }
  .two{display:grid; grid-template-columns: 1fr 1fr; gap:10px;}
  @media (max-width: 520px){ .two{grid-template-columns: 1fr;} }
  .rollupHeader{
    display:flex; align-items:center; justify-content:space-between;
    cursor:pointer; user-select:none;
    padding:10px 12px; border-radius:12px;
    background: rgba(15,27,42,.55);
    border: 1px solid var(--stroke);
  }
  .rollupHeader .meta{color:var(--muted); font-size:12px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width:60%;}
  .rollupBody{padding:10px 2px 2px;}
  .hidden{display:none !important;}
  .tableCard{padding:0; overflow:hidden; margin-top:14px;}
  .tableHead{padding:14px 14px 10px; border-bottom:1px solid var(--stroke);}
  .tableWrap{
    padding: 0 0 18px;
    overflow:auto;
    -webkit-overflow-scrolling: touch;
    overscroll-behavior: contain;
    max-height: 560px;
  }
  table{
    border-collapse: collapse;
    width: 100%;
    min-width: 1400px;
    font-variant-numeric: tabular-nums;
  }
  th, td{
    padding: 10px 12px;
    border-bottom: 1px solid rgba(140,170,210,.12);
    white-space:nowrap;
  }
  th{
    position: sticky; top: 0;
    background: rgba(9,15,26,.92);
    z-index: 2;
    color: rgba(230,238,248,.9);
    font-weight: 700;
    text-align:left;
  }
  tr:hover td{background: rgba(77,163,255,.06);}
  .tagpill{
    display:inline-flex; padding:2px 8px; border-radius:999px;
    border:1px solid rgba(247,196,106,.35);
    background: rgba(247,196,106,.08);
    color: rgba(247,196,106,.95);
    font-size:12px;
  }
  .rightCol{position:relative;}
  .rightCol .card{position:sticky; top:14px;}
  @media (max-width:1100px){ .rightCol .card{position:relative; top:auto;} }
  .hint{color:var(--muted); font-size:12px;}
  .kbtns{display:flex; flex-wrap:wrap; gap:10px; margin-top:10px;}

  .joinpill{
    display:inline-flex; padding:2px 8px; border-radius:999px;
    border:1px solid rgba(140,170,210,.25);
    background: rgba(140,170,210,.08);
    color: rgba(230,238,248,.85);
    font-size:12px; font-weight:700;
  }
  .joinpill.ok{border-color: rgba(61,220,151,.35); background: rgba(61,220,151,.10); color: rgba(61,220,151,.95);}
  .joinpill.warn{border-color: rgba(247,196,106,.35); background: rgba(247,196,106,.10); color: rgba(247,196,106,.95);}
  .joinpill.bad{border-color: rgba(255,107,107,.40); background: rgba(255,107,107,.10); color: rgba(255,107,107,.95);}
  .joinpill.muted{border-color: rgba(140,170,210,.20); background: rgba(140,170,210,.06); color: rgba(230,238,248,.65);}


  /* Phase 3 (Step 1): shot state controls */
  .stateCtl{display:inline-flex; gap:6px; align-items:center;}
  .sbtn{
    width:26px; height:22px; padding:0;
    border-radius:8px;
    border:1px solid rgba(140,170,210,.25);
    background: rgba(15,27,42,.55);
    color: rgba(230,238,248,.85);
    cursor:pointer;
    font-weight:800;
    line-height:20px;
    display:inline-flex;
    align-items:center;
    justify-content:center;
  }
  .sbtn:hover{border-color: rgba(77,163,255,.55);}
  .sbtn.active{border-color: rgba(77,163,255,.95); box-shadow: 0 0 0 2px rgba(77,163,255,.18) inset;}
  .sbtn.rec.active{border-color: rgba(61,220,151,.75); box-shadow: 0 0 0 2px rgba(61,220,151,.18) inset;}
  .sbtn.sgt.active{border-color: rgba(247,196,106,.80); box-shadow: 0 0 0 2px rgba(247,196,106,.18) inset;}
  .sbtn.exc.active{border-color: rgba(255,107,107,.85); box-shadow: 0 0 0 2px rgba(255,107,107,.18) inset;}
  tr.row-sighter td{background: rgba(247,196,106,.06);}
  tr.row-exclude td{opacity:.42; background: rgba(255,107,107,.03);}

  /* Phase 5.4.5: Garmin coverage highlight */
  tr.row-garmiss td{background: rgba(247,196,106,.045);}
  /* Target (block) group headers in All view */
  tr.tGroupHeader td{
    background: rgba(12,22,36,.78);
    border-top: 1px solid rgba(255,255,255,.08);
    font-weight: 800;
    cursor: pointer;
    padding: 10px 12px;
  }
  tr.tGroupHeader:hover td{background: rgba(12,22,36,.90);}
  .tCaret{display:inline-block; width:18px; opacity:.9;}
  .tTitle{margin-right:10px;}
  .tMeta{color: rgba(230,238,248,.68); font-weight:600; font-size:12.5px;}
  tr.tGroupFooter td{background: rgba(12,22,36,.55);}
  tr.row-garmiss:hover td{background: rgba(247,196,106,.07);}
  tr.row-exclude-flag td{background-image: linear-gradient(90deg, rgba(247,196,106,.55) 0 3px, transparent 3px); background-repeat:no-repeat; background-size:100% 100%;}
  tr.row-exclude-manual td{background-image: linear-gradient(90deg, rgba(255,107,107,.55) 0 3px, transparent 3px); background-repeat:no-repeat; background-size:100% 100%;}


  /* Phase 3 (Step 2): block rollups */
  .blockList{display:flex; flex-direction:column; gap:8px;}

  /* Phase 5.4.2: make Blocks list scrollable without eating the whole page */
  #blocksCard .blockList{max-height:520px; overflow:auto; padding-right:4px;}
  #blocksCard .blockList::-webkit-scrollbar{height:10px;width:10px;}
  #blocksCard .blockList::-webkit-scrollbar-thumb{background: rgba(140,170,210,.20); border-radius:999px;}
  #blocksCard .blockList::-webkit-scrollbar-track{background: transparent;}

  /* Phase 5.4.1: distance source pill */
  .distSrc{
    display:inline-flex; align-items:center; justify-content:center;
    padding:3px 8px; border-radius:999px;
    border:1px solid rgba(140,170,210,.22);
    background: rgba(140,170,210,.06);
    color: rgba(230,238,248,.85);
    font-size:12px; font-weight:900;
  }
  .distSrc.sm{border-color: rgba(77,163,255,.38); background: rgba(77,163,255,.10); color: rgba(77,163,255,.98);}
  .distSrc.man{border-color: rgba(247,196,106,.38); background: rgba(247,196,106,.10); color: rgba(247,196,106,.98);}
  .distSrc.def{opacity:.75;}

  .blockRow{
    display:flex; align-items:center; justify-content:space-between; gap:10px;
    padding:14px 14px; border-radius:14px;
    background: rgba(15,27,42,.50);
    border: 1px solid rgba(140,170,210,.16);
    cursor:pointer;
  }
  .blockRow:hover{border-color: rgba(77,163,255,.45); background: rgba(77,163,255,.05);}
  .blockRow .l{min-width:0;}
  .blockRow .title{font-weight:800;}
    .blockRow .meta{color:var(--muted); font-size:12px; overflow:visible; white-space:normal; max-width:100%;}
  .blockRow .metaLine{margin-top:4px; line-height:1.35; display:block;}
  .blockRow .metaLine.metaCounts{opacity:.85;}
  .blockRow .metaLine.metaVel{opacity:.92;}
  .blockRow .metaLine.metaGeo{opacity:.92;}
  .blockRow .metaLine.metaWind{opacity:.92;}
  .blockRow .stats{display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end;}
  .bchip{display:inline-flex; gap:6px; align-items:center; padding:3px 8px; border-radius:999px;
         border:1px solid rgba(140,170,210,.22); background: rgba(140,170,210,.06); color: rgba(230,238,248,.85); font-size:12px; font-weight:800;}

  .bchip.join{font-variant-numeric: tabular-nums;}
  .bchip.join.ok{background: rgba(37,235,186,.10); border-color: rgba(37,235,186,.30); color: rgba(175,255,235,.95);}
  .bchip.join.warn{background: rgba(255,199,87,.10); border-color: rgba(255,199,87,.30); color: rgba(255,219,150,.95);}
  .bchip.join.bad{background: rgba(255,107,107,.10); border-color: rgba(255,107,107,.30); color: rgba(255,160,160,.95);}
  .bchip.rec{border-color: rgba(61,220,151,.28); background: rgba(61,220,151,.08); color: rgba(61,220,151,.95);}
  .bchip.sgt{border-color: rgba(247,196,106,.30); background: rgba(247,196,106,.08); color: rgba(247,196,106,.95);}
  .bchip.exc{border-color: rgba(255,107,107,.34); background: rgba(255,107,107,.08); color: rgba(255,107,107,.95);}
  .blockRow.active{border-color: rgba(77,163,255,.85); box-shadow: 0 0 0 2px rgba(77,163,255,.18) inset;}


  
  .warnChip{
    display:inline-flex; align-items:center; justify-content:center;
    padding:2px 7px; border-radius:999px;
    border:1px solid rgba(247,196,106,.35);
    background: rgba(247,196,106,.10);
    color: rgba(247,196,106,.95);
    font-size:12px; font-weight:900;
  }
  .windChip{
    display:inline-flex; align-items:center; justify-content:center;
    padding:2px 8px; border-radius:999px;
    border:1px solid rgba(140,170,210,.22);
    background: rgba(140,170,210,.06);
    color: rgba(230,238,248,.85);
    font-size:12px; font-weight:800;
  }
  .windChip.ok{border-color: rgba(61,220,151,.28); background: rgba(61,220,151,.08); color: rgba(61,220,151,.95);}
  .windChip.warn{border-color: rgba(247,196,106,.30); background: rgba(247,196,106,.08); color: rgba(247,196,106,.95);}
  .windChip.bad{border-color: rgba(255,107,107,.34); background: rgba(255,107,107,.08); color: rgba(255,107,107,.95);}
  .windChip.neutral{border-color: rgba(140,170,210,.22); background: rgba(140,170,210,.06);}
/* Phase 4 */
  .flagchip{
    display:inline-flex; align-items:center; gap:6px;
    padding:2px 8px; border-radius:999px;
    font-size:12px; font-weight:800;
    border:1px solid rgba(140,170,210,.25);
    background: rgba(140,170,210,.08);
    color: rgba(230,238,248,.85);
    cursor:pointer;
    user-select:none;
  }
  .flagchip.ok{border-color: rgba(61,220,151,.35); background: rgba(61,220,151,.10); color: rgba(61,220,151,.95);}
  .flagchip.warn{border-color: rgba(247,196,106,.40); background: rgba(247,196,106,.12); color: rgba(247,196,106,.98);}
  .flagchip.problem{border-color: rgba(247,196,106,.55); background: rgba(247,196,106,.16); color: rgba(247,196,106,.98);}
  .flagchip.bad{border-color: rgba(255,107,107,.45); background: rgba(255,107,107,.12); color: rgba(255,107,107,.98);}
  .flagchip.off{opacity:.55; cursor:default;}
  .miniBtns{display:flex; flex-wrap:wrap; gap:10px; margin-top:10px;}
  .miniBtns .btn{flex:1 1 auto;}
  .mapTable{width:100%; border-collapse:collapse; font-variant-numeric: tabular-nums; table-layout:fixed;}
  .mapTable th,.mapTable td{padding:8px 8px; border-bottom:1px solid rgba(140,170,210,.12); white-space:nowrap;}
  .mapTable th:nth-child(1), .mapTable td:nth-child(1){width:70%;}
  .mapTable th:nth-child(2), .mapTable td:nth-child(2){width:10%; text-align:right;}
  .mapTable th:nth-child(3), .mapTable td:nth-child(3){width:20%;}
  .mapTable td:nth-child(1){white-space:normal; overflow-wrap:anywhere;}

  .mapTable th{color: rgba(230,238,248,.9); font-size:12px; text-transform:none; position:sticky; top:0; background: rgba(9,15,26,.92); z-index:1;}
  .mapTable input{width:110px; padding:8px 10px; border-radius:10px;}


  .distInput{
    width:86px;
    padding:8px 10px;
    border-radius:12px;
    background-color: rgba(15,27,42,.65);
    border:1px solid var(--stroke2);
    color: var(--txt);
    font-weight:700;
    text-align:center;
  }
  .bchip.geo{border-color: rgba(77,163,255,.35); background: rgba(77,163,255,.10); color: rgba(77,163,255,.95);}


  /* Phase 5.4.4: table ergonomics */
  .tableWrap.dense th, .tableWrap.dense td{padding:6px 10px;}
  .tableWrap.dense{max-height: 620px;}
  th[data-sort]{cursor:pointer;}
  th[data-sort]::after{content:''; opacity:.55; margin-left:6px; font-weight:900;}
  th.sort-asc::after{content:'▲';}
  th.sort-desc::after{content:'▼';}

  /* Sticky left columns (Sel, #, Block, State) */
  .tableWrap{
    --colSel: 32px;
    --colNum: 58px;
    --colBlock: 220px;
    --colState: 110px;
  }
  th.sticky, td.sticky{
    position: sticky;
    background: rgba(9,15,26,.96);
    z-index: 3;
  }
  td.sticky{background: rgba(9,15,26,.70); z-index:1;}

  /* Sel (checkbox) column: keep it tight */
  th.sticky.c0, td.sticky.c0{
    left:0;
    width: var(--colSel);
    min-width: var(--colSel);
    max-width: var(--colSel);
    padding-left: 6px;
    padding-right: 6px;
    text-align:center;
  }
  .rowSel{
    margin:0;
    width: 16px;
    height: 16px;
    vertical-align: middle;
  }

  th.sticky.c1, td.sticky.c1{
    left: var(--colSel);
    width: var(--colNum);
    min-width: var(--colNum);
  }
  th.sticky.c2, td.sticky.c2{
    left: calc(var(--colSel) + var(--colNum));
    min-width: var(--colBlock);
    max-width:260px;
  }
  th.sticky.c3, td.sticky.c3{
    left: calc(var(--colSel) + var(--colNum) + var(--colBlock));
    min-width: var(--colState);
  }

/* --- Suite unified header (NodeLab-style) --- */
.suiteHeader{
  display:flex; align-items:center; justify-content:space-between; gap:14px;
  padding: 12px 14px;
  border-radius: 22px;
  border: 1px solid var(--stroke);
  box-shadow: 0 10px 40px rgba(0,0,0,.25);
  background: linear-gradient(135deg, rgba(10,18,32,.78), rgba(15,27,42,.55));
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  margin: 0 0 14px;
}
.suiteHeader__left{min-width:0;}
.suiteHeader__topline{display:flex; align-items:baseline; gap:10px; flex-wrap:wrap;}
.suiteHeader__title{font-size: 28px; font-weight: 800; letter-spacing: .2px;}
.suiteHeader__pill{
  font-size: 13px; padding: 4px 10px; border-radius: 999px;
  border: 1px solid rgba(140,170,210,.18);
  background: rgba(0,0,0,.16);
  color: rgba(230,238,248,.74);
}
.suiteHeader__pill--muted{opacity:.9;}
.suiteHeader__tagline{
  margin-top: 6px;
  color: rgba(230,238,248,.68);
  font-size: 15px;
  line-height: 1.25;
  max-width: 980px;
}
.suiteHeader__right{display:flex; align-items:center; gap:12px; flex-shrink:0;}
.suiteHeader__badge{
  width: 54px; height: 54px; border-radius: 999px;
  border: 1px solid rgba(140,170,210,.22);
  background: radial-gradient(circle at 30% 30%, rgba(230,238,248,.10), rgba(0,0,0,.16));
  overflow:hidden;
  box-shadow: 0 10px 22px rgba(0,0,0,.20);
  display:flex; align-items:center; justify-content:center;
}
.suiteHeader__badgeImg{width:100%; height:100%; object-fit:cover; display:block;}
@media (max-width: 700px){
  .suiteHeader{flex-direction:column; align-items:flex-start;}
  .suiteHeader__right{width:100%; justify-content:space-between;}
  .suiteHeader__tagline{max-width: 100%;}
}

  /* Target ↔ Chrono pairing controls (per block) */
  .chronoCtl{display:flex; flex-direction:column; gap:6px; margin-top:8px;}
  .chronoSel{width:180px; max-width:220px; padding:8px 10px; border-radius:12px; background:#0b1426; border:1px solid rgba(255,255,255,.12); color:#e8eefc;}
  .chronoStart{width:100px; padding:8px 10px; border-radius:12px; background:#0b1426; border:1px solid rgba(255,255,255,.12); color:#e8eefc;}


  /* Pairing panel (SM blocks -> Chrono sources) */
  .pairList{display:flex; flex-direction:column; gap:22px; margin-top:10px;}
  .pairRow{display:flex; align-items:center; justify-content:space-between; flex-wrap:wrap; gap:14px;
    padding:14px 14px; border-radius:22px; border:1px solid var(--stroke2);
    background: rgba(10,18,32,.55);
    box-shadow: inset 0 1px 0 rgba(255,255,255,.03);
  }
  .pairLeft{display:flex; align-items:center; flex-wrap:wrap; gap:10px;}
  .pairTitle{font-weight:800; letter-spacing:.2px;}
  .pairMeta{display:flex; gap:8px; flex-wrap:wrap; color: rgba(225,235,248,.78); font-weight:700;}
  .pairMeta .chip{padding:7px 10px; border-radius:999px; border:1px solid var(--stroke2); background: rgba(15,27,42,.55);}
  .pairRight{display:flex; align-items:center; gap:10px; flex:1 1 100%; min-width: 0; justify-content:flex-end; margin-top:10px;}
  
  .pairCtl{display:flex; flex-direction:column; align-items:flex-end; gap:6px; width:100%;}
  .pairCtlLbl{font-size:12px; letter-spacing:.3px; opacity:.65; font-weight:800; text-transform:uppercase;}
.pairRight select{flex: 0 1 320px; min-width: 180px; max-width: 100%; height: 40px !important; max-height:40px !important; padding: 8px 12px !important; line-height: 1.1; font-size:13px; box-sizing:border-box;}
  .pairRight .btnTiny{padding:8px 10px; border-radius:12px; font-weight:800; opacity:.9;}
  .pairRow.warn{border-color: rgba(255,196,87,.35); background: rgba(255,196,87,.06);}


/* Pairing responsive */
@media (max-width: 520px){
  .pairRight{flex:1 1 100%; justify-content:stretch; margin-top:10px;}
  .pairRight select{flex:1 1 100%; max-width:100%; height:40px !important; max-height:40px !important; padding:8px 12px !important; font-size:13px;}
}

  select.sel{height:40px !important; max-height:40px !important; padding:8px 12px !important; font-size:13px;}

  /* Header info icon */
  .hdrInfo{
    display:inline-flex; align-items:center; justify-content:center;
    width:16px; height:16px;
    margin-left:6px;
    border-radius:999px;
    border:1px solid rgba(140,170,210,.28);
    background: rgba(0,0,0,.12);
    color: rgba(230,238,248,.82);
    font-size:11px;
    font-weight:900;
    line-height:1;
    cursor: help;
    opacity:.75;
    transform: translateY(-1px);
  }
  th:hover .hdrInfo{opacity:1; border-color: rgba(77,163,255,.60);}


  /* --- Phase 1-4 additions: dirty markers, preview bar, modal --- */
  .dirtyDot{
    display:inline-block; width:8px; height:8px; border-radius:999px;
    background: rgba(247,196,106,.95);
    box-shadow: 0 0 0 2px rgba(0,0,0,.25);
    margin-left:8px; transform: translateY(-1px);
  }
  .blockRow.dirty{border-color: rgba(247,196,106,.55); background: rgba(247,196,106,.055);}
  tr.row-dirty td{background-image: linear-gradient(90deg, rgba(247,196,106,.55) 0 3px, transparent 3px); background-repeat:no-repeat; background-size:100% 100%;}
  tr.row-preview td{background-image: linear-gradient(90deg, rgba(77,163,255,.60) 0 3px, transparent 3px); background-repeat:no-repeat; background-size:100% 100%;}

  .metaPrimary{margin-top:4px; font-size:13px; color: rgba(230,238,248,.92);}
  .metaPrimary b{color: rgba(230,238,248,.98);}

  .previewBar{
    margin: 10px 14px 0;
    display:flex; align-items:center; justify-content:space-between; gap:12px;
    padding: 10px 12px;
    border-radius: 14px;
    border: 1px solid rgba(77,163,255,.35);
    background: rgba(77,163,255,.07);
  }
  .previewBar__txt{color: rgba(230,238,248,.86); font-size:13px; line-height:1.25;}
  .previewBar__btns{display:flex; gap:10px; flex-shrink:0;}

  .modal{position:fixed; inset:0; z-index:9999;}
  .modal__backdrop{position:absolute; inset:0; background: rgba(0,0,0,.58); backdrop-filter: blur(2px);}
  .modal__panel{position:relative; max-width: 860px; margin: 7vh auto; padding: 14px; border-radius: 18px;}
  .modal__hdr{display:flex; align-items:flex-start; justify-content:space-between; gap:12px; border-bottom:1px solid rgba(140,170,210,.14); padding-bottom:10px;}
  .modal__title{font-size:18px; font-weight:900;}
  .modal__sub{margin-top:4px; color: rgba(230,238,248,.68);}
  .modal__body{padding-top:10px; max-height: 70vh; overflow:auto;}
  .modal__section{margin: 10px 0 14px;}
  .modal__h{font-weight:900; margin-bottom:6px;}
  .modal__body ul{margin: 6px 0 0 18px; color: rgba(230,238,248,.85);}
  .modal__body li{margin: 6px 0;}


  /* FIX: prevent any vertical column seam artifacts by hard-disabling per-cell separators */
  #shotTable th, #shotTable td{
    border-left: none !important;
    border-right: none !important;
    box-shadow: none !important;
    outline: none !important;
    background-image: none !important;
  }
  #shotTable th::before, #shotTable th::after,
  #shotTable td::before, #shotTable td::after{
    content: none !important;
    display: none !important;
  }
/* --- Phase 1-3: Import stepper + summary --- */
.stepper{margin-top:10px; display:grid; grid-template-columns:1fr; gap:8px;}
.step{display:flex; align-items:flex-start; justify-content:space-between; gap:10px; padding:10px 10px; border-radius:14px; border:1px solid rgba(140,170,210,.14); background: rgba(15,27,42,.35);}
.step .left{min-width:0;}
.step .t{font-weight:900;}
.step .m{margin-top:2px; color: rgba(230,238,248,.72); font-size:12px;}
.step .badge{flex-shrink:0; padding:6px 10px; border-radius:999px; border:1px solid rgba(140,170,210,.22); background: rgba(0,0,0,.12); font-weight:900; font-size:12px;}
.badge.good{color: var(--good); border-color: rgba(61,220,151,.35); background: rgba(61,220,151,.08);}
.badge.warn{color: var(--warn); border-color: rgba(247,196,106,.35); background: rgba(247,196,106,.08);}
.badge.off{color: rgba(230,238,248,.55);}
.importSummary{margin-top:10px; padding:10px 12px; border-radius:14px; border:1px dashed rgba(140,170,210,.22); color: rgba(230,238,248,.78); background: rgba(0,0,0,.10); font-size:13px; line-height:1.25;}
.importSummary b{color: rgba(230,238,248,.95);}
/* Phase 0: Columns + layouts + table prefs */
.btn.active{border-color: rgba(77,163,255,.65); box-shadow: 0 0 0 2px rgba(77,163,255,.12) inset;}
.miniSelect{
  appearance:none;
  padding:6px 10px;
  border-radius:12px;
  border:1px solid rgba(140,170,210,25);
  background: rgba(15,27,42,55);
  color: rgba(230,238,248,92);
  font-weight:800;
  font-size:12px;
  line-height:16px;
  cursor:pointer;
}
.miniSelect:focus{outline:none; border-color: rgba(77,163,255,55); box-shadow: 0 0 0 2px rgba(77,163,255,12);}
.colsGrid{
  display:grid;
  grid-template-columns: repeat(3, minmax(0,1fr));
  gap:10px;
  margin-top:12px;
}
@media (max-width: 900px){ .colsGrid{grid-template-columns: repeat(2, minmax(0,1fr));} }
@media (max-width: 620px){ .colsGrid{grid-template-columns: 1fr;} }
.colItem{
  display:flex; align-items:center; gap:10px;
  padding:10px 12px;
  border-radius:14px;
  border:1px solid rgba(140,170,210,18);
  background: rgba(9,15,26,35);
}
.colItem b{font-size:12px;}
.colItem .hint{margin-left:auto;}
.colItem.locked{opacity:.7;}
.colItem input{transform: translateY(0.5px);}
.modalCard .modalHead{display:flex; justify-content:space-between; align-items:flex-start; gap:10px;}
.modalCard .modalFoot{display:flex; justify-content:flex-end; gap:10px; padding-top:12px;}

  /* v2.2.2 UX */
  .nextActionBar{
    position: sticky;
    top: 0;
    z-index: 25;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
    padding:10px 12px;
    margin: 10px 0 12px;
    border-radius: 18px;
    border:1px solid var(--stroke2);
    background: rgba(12,20,36,.78);
    backdrop-filter: blur(8px);
    box-shadow: 0 10px 30px rgba(0,0,0,.25);
  }
  .nextActionBar.hidden{display:none;}
  .nextActionBar__left{display:flex; align-items:center; gap:10px; flex-wrap:wrap; min-width:0;}
  .nextActionBar__title{font-weight:900; opacity:.85;}
  .nextActionBar__steps{display:flex; gap:8px; flex-wrap:wrap;}
  .stepChip{
    padding:6px 10px; border-radius:999px;
    border:1px solid var(--stroke2); background: rgba(15,27,42,.55);
    font-weight:800; letter-spacing:.2px;
  }
  .stepChip.ok{border-color: rgba(61,220,151,.35); color: rgba(61,220,151,.95);}
  .stepChip.warn{border-color: rgba(247,196,106,.35); color: rgba(247,196,106,.95);}
  .stepChip.todo{opacity:.8;}
  .nextActionBar__msg{
    color: rgba(230,238,248,.78);
    font-weight:700;
    max-width: 520px;
    white-space: nowrap;
    overflow:hidden;
    text-overflow: ellipsis;
  }
  .nextActionBar__right{display:flex; gap:8px; flex:0 0 auto;}

  .filterBar{
    margin-top:10px;
    display:flex;
    gap:8px;
    flex-wrap:wrap;
    align-items:center;
    padding:10px 10px;
    border-radius: 16px;
    border:1px solid var(--stroke2);
    background: rgba(10,18,32,.55);
  }
  .miniInput{
    width: 240px;
    max-width: 100%;
    height: 36px !important;
    max-height: 36px !important;
    padding: 8px 10px !important;
    border-radius: 12px !important;
  }
  .miniSelect{
    width: auto;
    min-width: 140px;
    height: 36px !important;
    max-height: 36px !important;
    padding: 6px 10px !important;
    border-radius: 12px !important;
  }
  .filterBar .chk{
    display:flex; align-items:center; gap:8px;
    padding:6px 10px;
    border-radius:999px;
    border:1px solid var(--stroke2);
    background: rgba(15,27,42,.55);
    color: rgba(230,238,248,.82);
    font-weight:800;
    font-size:12px;
    letter-spacing:.2px;
  }
  .filterBar .chk input{width:auto; margin:0;}
  .filterBar__spacer{flex:1 1 auto; min-width: 12px;}
  .btnGroup{display:flex; gap:6px; align-items:center;}
  .btnGroup .btn{min-width:34px; padding:8px 10px;}


  /* --- v2.2.2: blue tooltips + filter help icon --- */
  .infoIcon{
    width:18px; height:18px; line-height:18px;
    border-radius:999px;
    display:inline-flex; align-items:center; justify-content:center;
    border:1px solid rgba(140,170,210,.35);
    background: rgba(77,163,255,.10);
    color: rgba(230,238,248,.92);
    font-weight:700;
    font-size:12px;
    padding:0;
    cursor:pointer;
    transform: translateY(-1px);
  }
  .infoIcon:hover{ background: rgba(77,163,255,.18); border-color: rgba(77,163,255,.45); }
  .infoIcon:active{ transform: translateY(0px); }

  #slBlueTip{
    position:fixed;
    left:0; top:0;
    z-index:99999;
    max-width:360px;
    padding:8px 10px;
    border-radius:10px;
    background: linear-gradient(180deg, rgba(77,163,255,.95), rgba(54,132,232,.92));
    border:1px solid rgba(255,255,255,.16);
    box-shadow: 0 10px 26px rgba(0,0,0,.38);
    color:#ffffff;
    font-size:12px;
    line-height:1.25;
    pointer-events:none;
    opacity:0;
    transform: translate(12px, 12px);
    transition: opacity .10s ease;
    white-space:pre-wrap;
  }
  #slBlueTip.show{ opacity:1; }

</style>
</head>
<body>
<div class="wrap">
  
  <header class="suiteHeader">
    <div class="suiteHeader__left">
      <div class="suiteHeader__topline">
        <div class="suiteHeader__title">ShotLedger</div>
        <div class="suiteHeader__pill">v2.2.2</div>
        <div class="suiteHeader__pill suiteHeader__pill--muted">standalone</div>
      </div>
      <div class="suiteHeader__tagline">
        Built for 1000-yard reality: vertical is king; velocity is context.
      </div>
    </div>
    <div class="suiteHeader__right">
      <button class="btn small" id="toggleRightBtn" type="button">Hide Kestrel panel</button>
            <button class="btn small ghost" id="btnResetMenu" type="button" title="Reset options">Reset</button>
<button class="btn small ghost" id="btnHelp" type="button" title="What is ShotLedger?">?</button>
      <div class="suiteHeader__badge" title="Suite mark">
        <img class="suiteHeader__badgeImg" alt="Target" src="data:image/jpeg;base64,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"/>
      </div>
    </div>
  </header>


  
  <div class="nextActionBar" id="nextActionBar">
    <div class="nextActionBar__left">
      <div class="nextActionBar__title">Next:</div>
      <div class="nextActionBar__steps" id="nextActionSteps"></div>
      <div class="nextActionBar__msg" id="nextActionMsg"></div>
    </div>
    <div class="nextActionBar__right">
      <button class="btn small" id="btnNextDo" type="button">Continue</button>
      <button class="btn small ghost" id="btnNextSkip" type="button" title="Hide until next reload">Dismiss</button>
    </div>
  </div>

<div class="grid" id="grid">
    <div class="leftCol">
<div class="card">
    <div class="panelTitle">
      <h2>Imports</h2>
      <div class="row">
<button class="btn small" id="btnSM" type="button">ShotMarker CSV</button>
        <button class="btn small" id="btnK" type="button">Kestrel CSV</button>
        <button class="btn small" id="btnG" type="button">Add Garmin CSV</button>
        <button class="btn small" id="btnGClear" type="button">Clear Garmin</button>
        <button class="btn small" id="btnAMP" type="button">AMP CSV</button>
        <button class="btn small" id="btnAMPClear" type="button">Clear AMP</button>
        <input class="hidden" id="fileSM" type="file" accept=".csv,text/csv"/>
        <input class="hidden" id="fileK" type="file" accept=".csv,text/csv"/>
        <input class="hidden" id="fileG" type="file" accept=".csv,text/csv" multiple/>
        <input class="hidden" id="fileAMP" type="file" accept=".csv,text/csv"/>
      </div>
    </div>
    <div class="row" id="importPills"></div>
    <div class="status" id="importStatus"></div>
    <div class="stepper" id="importStepper"></div>
    <div class="importSummary" id="importSummary" style="display:none;"></div>
  </div>

  <div class="card" id="phase4ToolsCard">
    <div class="rollupHeader" id="toolsHeader">
          <div>
            <b>Tools</b>
            <div class="meta">Undo, exports, Garmin mapping</div>
          </div>
          <div id="toolsChevron">▸</div>
        </div>
        <div class="rollupBody hidden" id="toolsBody">
          <div class="row miniBtns" style="margin-top:2px;">

        <button class="btn small ghost" id="btnUndo" type="button" title="Undo last state change">Undo</button>
        <button class="btn small" id="btnImportJSON" type="button">Import JSON</button>
        <button class="btn small" id="btnExportCSV" type="button">Export CSV</button>
        <button class="btn small" id="btnExportJSON" type="button">Export JSON</button>
        <button class="btn small ghost" id="btnClearAll" type="button" title="Clear all loaded data">Clear</button>
        <input class="hidden" id="fileJSON" type="file" accept=".json,application/json"/>
      </div>
    <div class="hint">Tip: the <b>ΔVel (σ)</b> chip shows how many SDs a shot’s velocity is from the block mean (record shots). Click the chip to toggle <b>Exclude</b>. Undo restores the last change.

          <div style="margin-top:12px; border-top:1px solid rgba(140,170,210,.12); padding-top:12px;">
<div id="pairingCard" style="margin-top:12px;">
              <div class="rollupHeader" id="pairHeader" aria-expanded="false">
                <div>
                  <b>Pairing</b>
                  <div class="meta" id="pairMetaLine">ShotMarker strings → Chrono sources</div>
                
            <div class="filterBar" id="filterBar">
              <input id="filterSearch" class="miniInput" type="text" placeholder="Search notes/tag/block…" title="Filter by block, tag, notes, score"/>
              <select id="filterBlockSel" class="miniSelect" title="Block filter">
                <option value="">All blocks</option>
              </select>
              <label class="chk"><input type="checkbox" id="filterHideExcluded"/> Hide excluded</label>
              <label class="chk"><input type="checkbox" id="filterOnlyIssues"/> Only issues</label>
              <label class="chk"><input type="checkbox" id="filterOnlySighters"/> Only sighters</label>
              <label class="chk"><input type="checkbox" id="filterMissingJoin"/> Missing joins</label>
              
              <button class="infoIcon" id="btnFilterHelp" type="button" data-tip="Filters & views

• Search matches block/tag/notes/score.
• Hide excluded hides ✕ rows.
• Only issues shows rows with join misses, missing mappings, or dirty edits.
• Missing joins shows Kestrel join misses.

Click this ? to open Help at the Filters section.">?</button>
<button class="btn small ghost" id="btnClearFilters" type="button" title="Clear filters">Clear</button>
              <div class="filterBar__spacer"></div>
              <div class="btnGroup" id="bulkStateGroup" title="Apply shot state to selected shots">
                <button class="btn small ghost" id="btnBulkRecord" type="button">R</button>
                <button class="btn small ghost" id="btnBulkSighter" type="button">S</button>
                <button class="btn small ghost" id="btnBulkExclude" type="button">✕</button>
              </div>
            </div>
</div>
                <div id="pairChevron">▸</div>
              </div>
              <div class="rollupBody hidden" id="pairBody">
                <div class="hint" style="margin-top:2px;">
                  If files were uploaded out of order, pick the chrono file that belongs to each ShotMarker string. (1:1 by shot index within the string.)
                </div>
                
                <div class="row" style="gap:8px; align-items:center; flex-wrap:wrap; margin-top:10px;">
                  <button class="btn small" id="btnAutoPair" type="button" title="Auto-pair ShotMarker strings to chrono files (smart)">Auto-pair</button>
                  <button class="btn small ghost" id="btnClearPairings" type="button" title="Clear all pairings">Clear pairings</button>
                  <span class="pill" id="pairingStatusPill" style="margin-left:auto; display:none;"></span>
                </div>
<div class="pairList" id="pairingList"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
  </div>

<div class="card" id="blocksCard" style="margin-bottom:14px;">
      <div class="rollupHeader" id="blocksHeader">
        <div>
          <b>Blocks</b>
          <div class="meta" id="blocksMeta">Rollups, distance, filters</div>
        </div>
        <div id="blocksChevron">▸</div>
      </div>
      <div class="rollupBody hidden" id="blocksBody">
        <div class="row" style="justify-content:flex-end; margin-top:2px; gap:8px;">
          <button class="btn small ghost" id="collapseAllBlocksBtn" type="button">Collapse all</button>
          <button class="btn small ghost" id="expandAllBlocksBtn" type="button">Expand all</button>
          <button class="btn small ghost" id="clearBlockFilterBtn" type="button">Show all</button>
        </div>
      <div class="hint" id="blockHint">Load ShotMarker to see block rollups.</div>
      
      <div class="row" style="margin-top:10px; gap:12px; align-items:flex-end;">
        <div style="min-width:200px;">
          <label style="margin:0 0 6px;">Default distance (yd)</label>
          <input id="defaultDist" type="number" min="10" step="1" value="1000"/>
        </div>
        <div class="hint" style="margin-bottom:2px;">Distance drives MOA + dispersion stats. You can override per block on the right.</div>
      </div>

      <div class="blockList" id="blockRollups" style="margin-top:10px;"></div>
      </div>
    </div>

    </div>

    <div class="rightCol" id="rightCol">
      <div class="card">
        <div class="rollupHeader" id="kHeader">
          <div>
            <b>Kestrel (per-shot)</b>
            <div class="meta" id="kMeta">No file loaded</div>
          </div>
          <div id="kChevron">▾</div>
        </div>
        <div class="rollupBody" id="kBody">
          <div class="two">
            <div>
              <label>Alignment mode</label>
              <select id="alignMode">
                <option value="anchors" selected>Anchors (2-point map)</option>
              </select>
            </div>
            <div>
              <label>Tolerance</label>
              <select id="tolSel">
                <option value="5">±5s</option>
                <option value="10" selected>±10s</option>
                <option value="15">±15s</option>
                <option value="30">±30s</option>
                <option value="60">±60s</option>
              </select>
            </div>
          </div>

          <div class="two">
            <div>
              <label>Session date (for anchors)</label>
              <input id="sessionDate" type="date"/>
            </div>
            <div>
              <label>Join</label>
              <select id="joinMode">
                <option value="nearest" selected>Nearest sample</option>
              </select>
            </div>
          </div>

          <div class="two">
            <div>
              <label>Anchor A shot #</label>
              <input id="aShot" type="number" min="1" value="1"/>
            </div>
            <div>
              <label>Anchor A time (HH:MM:SS)</label>
              <input id="aTime" type="text" value="19:28:10" placeholder="19:28:10"/>
            </div>
          </div>

          <div class="two">
            <div>
              <label>Anchor B shot #</label>
              <input id="bShot" type="number" min="1" value="60"/>
            </div>
            <div>
              <label>Anchor B time (HH:MM:SS)</label>
              <input id="bTime" type="text" value="19:41:55" placeholder="19:41:55"/>
            </div>
          </div>

          <div class="kbtns">
            <button class="btn small" id="applyBtn" type="button">Apply Kestrel to shots</button>
            <button class="btn small ghost" id="clearBtn" type="button">Clear Kestrel fields</button>
            <button class="btn small" id="autofitBtn" type="button">Auto-fit anchors to Kestrel range (demo)</button>
            <button class="btn small ghost" id="dateFromSMBtn" type="button">Set session date from ShotMarker</button>
          </div>

          <div class="status" id="kStatus"></div>
        </div>
        <!-- Tools moved to main column -->
          <!-- Garmin mapping moved to main column -->
</div>
<div class="card" id="manualCard" style="margin-top:14px;">
        <div class="rollupHeader" id="manHeader">
          <div>
            <b>Manual inputs</b>
            <div class="meta">Apply to selected shots or a whole string</div>
          </div>
          <div id="manChevron">▸</div>
        </div>
        <div class="rollupBody hidden" id="manBody">
          <div class="row" style="gap:10px; align-items:center; flex-wrap:wrap; margin-top:2px;">
            <button class="btn" id="btnApplySelected" type="button">Apply to selected</button>
            <span class="pill" id="selCountPill">Selected: 0</span>
          </div>

          
          <div class="row" style="gap:10px; align-items:center; flex-wrap:wrap; margin-top:10px;">
            <div style="min-width:220px; flex:0 0 220px;">
              <label style="margin:0 0 6px;">Bulk shot state</label>
              <select id="manStateSel">
                <option value="">(leave unchanged)</option>
                <option value="RECORD">Record (R)</option>
                <option value="SIGHTER">Sighter (S)</option>
                <option value="EXCLUDE">Exclude (✕)</option>
              </select>
            </div>
            <div class="hint" style="margin-top:20px; flex:1; min-width:240px;">
              Tip: use keyboard shortcuts — <b>r</b>/<b>s</b>/<b>x</b> apply to selected shots, <b>?</b> opens Help.
            </div>
          </div>
<div style="margin-top:10px;">
            <label>— Select string —</label>
            <select id="manBlockSel"></select>
          </div>

          <div class="row" style="gap:10px; align-items:center; flex-wrap:wrap; margin-top:10px;">
            <button class="btn" id="btnApplyToString" type="button">Apply to string</button>
            <button class="btn ghost" id="btnClearSelection" type="button">Clear selection</button>
          </div>

          <div style="margin-top:12px;">
            <label>Primer Seat (in)</label>
            <input id="manPrimerSeat" type="number" step="0.0001" placeholder="e.g. 0.0035"/>
          </div>

          <div style="margin-top:10px;">
            <label>Wind Zero Δ (MOA)</label>
            <input id="manWindZero" type="number" step="0.01" placeholder="e.g. +0.25"/>
          </div>

          <div style="margin-top:10px;">
            <label>Elev Zero Δ (MOA)</label>
            <input id="manElevZero" type="number" step="0.01" placeholder="e.g. -0.10"/>
          </div>

          <div style="margin-top:10px;">
            <label>Wind Call</label>
            <input id="manWindCall" type="text" placeholder="e.g. hold 0.5L, 6–10mph"/>
          </div>

          <div style="margin-top:10px;">
            <label>Notes</label>
            <textarea id="manNotes" rows="6" style="width:100%; resize:vertical;" placeholder="free text (trigger, bag, mirage, condition change, mental note, etc.)"></textarea>
          </div>

          <div class="hint" style="margin-top:10px;">Saved in Export JSON.</div>
          <div class="status" id="manStatus"></div>
        </div>
      </div>


      </div>
    </div>
  </div>

<div class="card tableCard">
        <div class="tableHead">
          <div class="panelTitle" style="margin:0;">
            <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; width:100%;">
              <h2 style="margin:0;" id="shotListTitle">Shot list</h2>
              <div class="row" style="gap:8px; align-items:center;">
                
<select id="layoutPresetSel" class="miniSelect" title="Quick column presets"></select>
<button class="btn small ghost" id="btnApplyLayoutPreset" type="button" title="Apply selected preset">Apply</button>

                <button class="btn small ghost" id="btnCols" type="button" title="Column visibility + saved layouts">Columns</button>
<select id="rowsLimitSel" class="miniSelect" title="Rows shown in All view">
  <option value="200">200</option>
  <option value="500">500</option>
  <option value="1000">1000</option>
  <option value="0">All</option>
</select>
<button class="btn small ghost" id="btnVirtual" type="button" title="Virtual scroll (flat list) for big shot lists">Virtual</button>
                <button class="btn small ghost" id="btnDense" type="button" title="Toggle dense row spacing">Dense</button>
                <button class="btn small ghost" id="btnPreview" type="button" title="Preview changes (what-if) before applying">Preview</button>
                <button class="btn small ghost" id="btnResetView" type="button" title="Reset sort, density, and scroll">Reset</button>
              </div>
            </div>
            <div class="hint">Tip: click a column header to sort; scroll horizontally inside the table to see all Kestrel columns.</div>
          </div>
        </div>
        <div class="previewBar hidden" id="previewBar">
          <div class="previewBar__txt"><b>Preview mode:</b> you can toggle shot states and see updated stats. Apply to keep changes or Cancel to revert.</div>
          <div class="previewBar__btns">
            <button class="btn small" id="btnPreviewApply" type="button">Apply</button>
            <button class="btn small ghost" id="btnPreviewCancel" type="button">Cancel</button>
          </div>
        </div>
        <div class="tableWrap" id="tableWrap">
          <table id="shotTable">
            <thead>
              <tr>
                <th class="sticky c0">Sel</th>
                <th data-col="idx" class="sticky c1" data-sort="idx">#</th>
                <th data-col="block" class="sticky c2" data-sort="block">Block</th>
                <th data-col="state" class="sticky c3" data-sort="state">State</th>
                <th data-col="relTime" data-sort="relTime">Rel time</th>
                <th data-col="tag">Tag</th>
                <th data-col="score" data-sort="score">Score</th>
                <th data-col="vel" data-sort="vel">Vel</th>
                <th data-col="velSrc" data-sort="velSrc">Vel Src</th>
      <th data-col="ampPeak" title="AMP Peak force (from AMP press).">AMP Peak</th>
      <th data-col="ampWork" title="AMP Work/area under force curve (consistency signal).">AMP Work</th>
      <th data-col="ampSigma" title="AMP anomaly score: max(|z|) across Peak/Work/Start metrics.">AMP Δ(σ) <span class="hdrInfo" title="AMP Δ(σ) = max(|z|) across AMP Peak / Work / Start.&#10;Colors: ≤0.7σ node-solid • 0.7–1.3σ normal noise • 1.3–1.9σ eyebrow raise • ≥1.9σ real outlier.&#10;Hover each chip for per-metric z-scores.">ⓘ</span></th>
                <th data-col="dsigma" data-sort="dsigma" title="ΔVel (σ) = (shot velocity − block mean) / block SD (record shots only). Click chip to toggle Exclude.">ΔVel (σ) <span class="hdrInfo" title="ΔVel (σ) = |shot vel − string avg| / string SD using the active velocity source (Garmin if present else SM).&#10;≤0.7σ solid • 0.7–1.3σ normal noise • 1.3–1.9σ eyebrow raise • ≥1.9σ real outlier.">ⓘ</span></th>
                <th data-col="xIn" data-sort="xIn">X (in)</th>
                <th data-col="yIn" data-sort="yIn">Y (in)</th>
                <th data-col="hMoa" data-sort="hMoa">H (MOA)</th>
                <th data-col="vMoa" data-sort="vMoa">V (MOA)</th>
                <th data-col="rMoa" data-sort="rMoa">R (MOA)</th>
                <th data-col="kTime" data-sort="kTime">Kestrel time</th>
                <th data-col="join" data-sort="join">Join</th>
                <th data-col="kdt" data-sort="kdt">Δt (s)</th>
                <th data-col="crosswind" data-sort="crosswind">Crosswind</th>
                <th data-col="headwind" data-sort="headwind">Headwind</th>
                <th data-col="windSpeed" data-sort="windSpeed">Wind spd</th>
                <th data-col="trueDir" data-sort="trueDir">Dir (true)</th>
                <th data-col="temp" data-sort="temp">Temp</th>
                <th data-col="rh" data-sort="rh">RH</th>
                <th data-col="stationP" data-sort="stationP">Station P</th>
                <th data-col="da" data-sort="da">DA</th>
                <th data-col="primerSeat" data-sort="primerSeat">Primer (in)</th>
                <th data-col="windZero" data-sort="windZero">Wind0 Δ</th>
                <th data-col="elevZero" data-sort="elevZero">Elev0 Δ</th>
                <th data-col="windCall" data-sort="windCall">Wind Call</th>
                <th data-col="notes" data-sort="notes">Notes</th>
              </tr>
            </thead>
            <tbody id="shotTbody"></tbody>
          </table>
        </div>
      </div>
    </div>

    

</div>

<script>

(() => {
  // ---------- app metadata (single source of truth) ----------
  const APP = {
    name: 'ShotLedger',
    flavor: 'standalone',
    version: '2.2.2',
    schemaVersion: 2
  };

  // Release build flags
  const SL_BUILD_DATE = '2026-01-03';
  const SL_DEBUG = false;


  function syncAppVersionUI(){
    try{
      const pill = document.querySelector('.suiteHeader__pill');
      if(pill) pill.textContent = 'v' + APP.version;
      document.title = `${APP.name} v${APP.version}`;
    }catch(_e){}
  }
  // ---------- state ----------
  // Phase 1: change awareness
  const dirtyShotIdxs = new Set();
  const dirtyBlocks = new Set();
  const dirtyPairBlocks = new Set();
  const dirtyDistBlocks = new Set();

  // Phase 4: preview mode (what-if)
  let previewActive = false;
  let previewSnapshot = null; // Map shotIdx -> {state, stateSrc}
  
  let smShots = [];   // {idx, block, relTime, tag, score, vel, blockDate}
  let smBlocks = [];  // {label, dateStr, n}
  let kSamples = [];  // {tEpoch, formatted, crosswind, headwind, windSpeed, trueDir, temp, rh, stationP, da}
  let kRange = null;  // {minEpoch,maxEpoch,minStr,maxStr}
  let smFirstDate = null;

  let selectedShots = new Set(); // shot idx
  const chronoPair = new Map(); // block -> {name, start}

  // ---------- Chrono pairing UI heuristics ----------
  function shouldShowChronoControls(){
    // Show manual controls only when needed (mismatched counts or missing files).
    if(!smBlocks || !smBlocks.length) return false;
    if(!gFiles || !gFiles.length) return false;
    if(gFiles.length !== smBlocks.length) return true;

    // If shot counts per block don't match the corresponding Garmin file, allow manual selection.
    // (We still auto-pair by order; this just exposes controls for correction.)
    const groups = groupByBlock();
    for(let i=0;i<smBlocks.length;i++){
      const blk = smBlocks[i].label;
      const list = groups.get(blk) || [];
      const gf = gFiles[i];
      const gcount = (gf && gf.shots) ? gf.shots.length : 0;
      if(gcount && list.length && gcount !== list.length) return true;
    }
    return false;
  }

  
function autoPairChronoSmart(){
  if(!smBlocks || !smBlocks.length) return;
  if(!gFiles || !gFiles.length) return;

  const groups = groupByBlock();
  const used = new Set();

  // Preserve any explicit user pairings, but mark as used.
  for(const [blk, v] of chronoPair.entries()){
    if(v && v.name) used.add(v.name);
  }

  // 1) Try exact shot-count matches (greedy).
  for(const b of smBlocks){
    const blk = b.label;
    const cur = chronoPair.get(blk);
    if(cur && cur.name) continue;

    const scount = (groups.get(blk)||[]).length;
    if(!scount) continue;

    const match = (gFiles||[]).find(g => !used.has(g.name) && ((g.shots&&g.shots.length)||0) === scount);
    if(match){
      chronoPair.set(blk, {name: match.name, start: 1});
      used.add(match.name);
    }
  }

  // 2) Fallback to order when counts line up 1:1.
  if(gFiles.length === smBlocks.length){
    for(let i=0;i<smBlocks.length;i++){
      const blk = smBlocks[i].label;
      const cur = chronoPair.get(blk);
      if(cur && cur.name) continue;
      const gf = gFiles[i];
      if(gf && !used.has(gf.name)){
        chronoPair.set(blk, {name: gf.name, start: 1});
        used.add(gf.name);
      }
    }
  }

  // Refresh pairing UI (SM strings ↔ chrono sources)
  renderPairingPanel();
}

function autoPairChronoByOrder(){
  // Back-compat: keep the old name, but use smarter pairing.
  autoPairChronoSmart();
}


  // ---------- Phase 5.1: geometry (MOA + dispersion) ----------
  let defaultDistYd = 1000;
  const blockDist = new Map(); // block -> distance yd
  let blockAutoDist = new Map(); // block -> ShotMarker-provided distance (auto)
  let geoStats = new Map(); // block -> {distYd, n, horizESmoa, vertESmoa, radialESmoa, mrMoa}

  let gFiles = [];    // [{name, shots:[{idx, vel, timeSec}], startIdx}]
  let ampSession = null; // {name, map: Map(traceNum->obj), stats}
  let undo = null;     // {shotIdx, prevState}
  let bulkStateMode = false;
  let blockStats = new Map();
  
let tableSort = { key: 'idx', dir: 1 }; // Phase 5.4.4

// ---------- Phase 0/4/5: table prefs + column layouts + (optional) virtual All view ----------
const TABLE_PREFS_KEY = 'ShotLedger.tablePrefs';
const TABLE_LAYOUTS_KEY = 'ShotLedger.tableLayouts';

const TABLE_COLS = [
  {key:'sel', label:'Sel', locked:true},
  {key:'idx', label:'#', locked:true},
  {key:'block', label:'Block', locked:true},
  {key:'state', label:'State', locked:true},
  {key:'relTime', label:'Rel time'},
  {key:'tag', label:'Tag'},
  {key:'score', label:'Score'},
  {key:'vel', label:'Vel'},
  {key:'velSrc', label:'Vel Src'},
  {key:'ampPeak', label:'AMP Peak'},
  {key:'ampWork', label:'AMP Work'},
  {key:'ampSigma', label:'AMP Δ(σ)'},
  {key:'dsigma', label:'ΔVel (σ)'},
  {key:'xIn', label:'X (in)'},
  {key:'yIn', label:'Y (in)'},
  {key:'hMoa', label:'H (MOA)'},
  {key:'vMoa', label:'V (MOA)'},
  {key:'rMoa', label:'R (MOA)'},
  {key:'kTime', label:'Kestrel time'},
  {key:'join', label:'Join'},
  {key:'kdt', label:'Δt (s)'},
  {key:'crosswind', label:'Crosswind'},
  {key:'headwind', label:'Headwind'},
  {key:'windSpeed', label:'Wind spd'},
  {key:'trueDir', label:'Dir (true)'},
  {key:'temp', label:'Temp'},
  {key:'rh', label:'RH'},
  {key:'stationP', label:'Station P'},
  {key:'da', label:'DA'},
  {key:'primerSeat', label:'Primer (in)'},
  {key:'windZero', label:'Wind0 Δ'},
  {key:'elevZero', label:'Elev0 Δ'},
  {key:'windCall', label:'Wind Call'},
  {key:'notes', label:'Notes'}
];

const PRESET_LAYOUTS = {
  "Full": TABLE_COLS.map(c=>c.key),

  // Quick presets (surface these in the main toolbar)
  "Essential": ['sel','idx','block','state','vel','velSrc','dsigma','xIn','yIn','hMoa','vMoa','rMoa','join','kTime','kdt','windSpeed','trueDir','temp','da','notes'],
  "Chrono":    ['sel','idx','block','state','vel','velSrc','dsigma','ampPeak','ampWork','ampSigma','join','kTime','kdt','notes'],
  "Wind":      ['sel','idx','block','state','kTime','join','kdt','crosswind','headwind','windSpeed','trueDir','temp','rh','stationP','da','vel','dsigma','notes'],
  "AMP":       ['sel','idx','block','state','vel','velSrc','ampPeak','ampWork','ampSigma','dsigma','notes'],
  "Geometry":  ['sel','idx','block','state','xIn','yIn','hMoa','vMoa','rMoa','vel','dsigma','notes'],

  // Legacy presets (kept for compatibility)
  "Minimal":     ['sel','idx','block','state','vel','dsigma','xIn','yIn','vMoa','join','kdt','windSpeed','temp','da'],
  "Environment": ['sel','idx','block','state','kTime','join','kdt','crosswind','headwind','windSpeed','trueDir','temp','rh','stationP','da','vel','velSrc','notes'],
  "Diagnostics": ['sel','idx','block','state','relTime','tag','score','vel','velSrc','ampPeak','ampWork','ampSigma','dsigma','kTime','join','kdt','temp','da','primerSeat','windZero','elevZero','windCall','notes']
};

let tablePrefs = {
  limit: 200,          // All view safety limit (0 = All)
  useVirtual: false,   // Virtual scroll (flat All view)
  visibleCols: null    // null = Full
};

// ---------- Filters / search ----------
let filterState = {
  q: '',
  block: '',
  hideExcluded: true,
  onlyIssues: false,
  onlySighters: false,
  missingJoin: false
};

function shotHasIssue(sh){
  const st = (sh.state||'RECORD');
  if(st==='EXCLUDE') return true;
  const j = String(sh.j||'').toUpperCase();
  if(j==='MISS' || j==='BAD' || j==='BADMAP') return true;
  if(gFiles && gFiles.length && !sh.gMapped) return true;
  // Δσ flag "eyebrow raise" or worse
  try{
    const f = velFlagForShot(sh);
    if(f && f.az!=null && f.az>=1.3) return true;
  }catch(_e){}
  return false;
}

function passesFilters(sh){
  if(filterState.hideExcluded && (sh.state||'RECORD')==='EXCLUDE') return false;
  if(filterState.onlySighters && (sh.state||'RECORD')!=='SIGHTER') return false;
  if(filterState.missingJoin){
    const j = String(sh.j||'').toUpperCase();
    if(!(j==='MISS' || j==='BAD' || j==='BADMAP')) return false;
  }
  if(filterState.onlyIssues && !shotHasIssue(sh)) return false;
  if(filterState.block){
    if((sh.block||'') !== filterState.block) return false;
  }
  const q = (filterState.q||'').trim().toLowerCase();
  if(q){
    const hay = [
      sh.block, sh.tag, sh.notes, sh.score, sh.relTime,
      sh.gName, sh.velSrc, sh.stateSrc
    ].filter(Boolean).join(' ').toLowerCase();
    if(!hay.includes(q)) return false;
  }
  return true;
}


function loadTablePrefs(){
  try{
    const raw = localStorage.getItem(TABLE_PREFS_KEY);
    if(raw){
      const o = JSON.parse(raw);
      if(o && typeof o==='object'){
        if(Number.isFinite(+o.limit)) tablePrefs.limit = +o.limit;
        if(typeof o.useVirtual==='boolean') tablePrefs.useVirtual = o.useVirtual;
        if(Array.isArray(o.visibleCols)) tablePrefs.visibleCols = o.visibleCols.slice(0);
      }
    }
  }catch(_e){}
  tablePrefs.visibleCols = normalizeVisibleCols(tablePrefs.visibleCols);
}

function saveTablePrefs(){
  try{
    localStorage.setItem(TABLE_PREFS_KEY, JSON.stringify({
      limit: tablePrefs.limit,
      useVirtual: !!tablePrefs.useVirtual,
      visibleCols: tablePrefs.visibleCols
    }));
  }catch(_e){}
}

function loadLayouts(){
  try{
    const raw = localStorage.getItem(TABLE_LAYOUTS_KEY);
    if(raw){
      const o = JSON.parse(raw);
      if(o && typeof o==='object') return o;
    }
  }catch(_e){}
  return {};
}

function saveLayouts(o){
  try{ localStorage.setItem(TABLE_LAYOUTS_KEY, JSON.stringify(o||{})); }catch(_e){}
}

function normalizeVisibleCols(cols){
  const all = TABLE_COLS.map(c=>c.key);
  const locked = TABLE_COLS.filter(c=>c.locked).map(c=>c.key);
  if(!Array.isArray(cols) || !cols.length) cols = all.slice(0);
  const set = new Set(cols.filter(k=>all.includes(k)));
  for(const k of locked) set.add(k);
  return all.filter(k=>set.has(k)); // stable order
}

function getHeaderColIndexMap(){
  const ths = document.querySelectorAll('#shotTable thead th');
  const map = new Map();
  ths.forEach((th, i)=>{
    const k = th.getAttribute('data-col') || th.getAttribute('data-sort') || '';
    if(k) map.set(k, i);
  });
  return {ths, map};
}

function applyColumnVisibility(){
  const {ths} = getHeaderColIndexMap();
  const visible = new Set(normalizeVisibleCols(tablePrefs.visibleCols));
  // header
  ths.forEach(th=>{
    const k = th.getAttribute('data-col') || '';
    const def = TABLE_COLS.find(c=>c.key===k);
    const lock = def && def.locked;
    th.style.display = (lock || visible.has(k)) ? '' : 'none';
  });
  // body rows: hide cells by index. Skip group header/footer rows (single cell).
  const tbody = el('shotTbody');
  if(!tbody) return;
  const rows = tbody.querySelectorAll('tr');
  rows.forEach(tr=>{
    const cells = tr.children;
    if(!cells || cells.length < 5) return;
    for(let i=0;i<ths.length && i<cells.length;i++){
      const k = (ths[i] && ths[i].getAttribute('data-col')) ? ths[i].getAttribute('data-col') : '';
      const def = TABLE_COLS.find(c=>c.key===k);
      const lock = def && def.locked;
      cells[i].style.display = (lock || visible.has(k)) ? '' : 'none';
    }
  });
}


function updateShotListTitle(){
  const h = el('shotListTitle');
  if(!h) return;
  const total = smShots.length || 0;
  const totalFiltered = smShots.filter(passesFilters).length;

  if(activeBlock){
    const nAll = smShots.filter(s=>s.block===activeBlock).length;
    const n = smShots.filter(s=>s.block===activeBlock && passesFilters(s)).length;
    h.textContent = (n!==nAll) ? `Shot list (${n}/${nAll})` : `Shot list (${n})`;
    return;
  }

  const lim = tablePrefs.limit;
  if(lim===0){
    const base = tablePrefs.useVirtual ? `Shot list (all • virtual)` : `Shot list (all)`;
    h.textContent = (totalFiltered!==total) ? `${base} • ${totalFiltered}/${total}` : base;
  }else{
    // In grouped view, the LIMIT applies after grouping; show the user's limit but keep the true filtered count handy.
    const base = `Shot list (first ${lim})`;
    h.textContent = (totalFiltered!==total) ? `${base} • ${totalFiltered}/${total}` : base;
    if(totalFiltered && totalFiltered<=lim) h.textContent = (totalFiltered!==total) ? `Shot list (${totalFiltered}/${total})` : `Shot list (${totalFiltered})`;
  }
}


// Virtual All view (flat list). Keeps the table markup but only renders the visible slice.
let vRAF = 0;
function renderVirtualAllView(tbody, wrap, buildRow, view){
  const rowH = wrap.classList.contains('dense') ? 28 : 34;
  const pad = 10;
  const top = wrap.scrollTop || 0;
  const vh = wrap.clientHeight || 520;
  const start = Math.max(0, Math.floor(top/rowH) - pad);
  const count = Math.ceil(vh/rowH) + pad*2;
  const end = Math.min(view.length, start + count);

  const topPx = start * rowH;
  const botPx = Math.max(0, (view.length - end) * rowH);

  const colCount = document.querySelectorAll('#shotTable thead th').length || 1;
  const out = [];
  if(topPx>0) out.push(`<tr class="vSpacer"><td colspan="${colCount}" style="height:${topPx}px;padding:0;border:0;"></td></tr>`);
  for(let i=start;i<end;i++){
    out.push(buildRow(view[i], (view[i].inBlock!=null ? view[i].inBlock : view[i].idx)));
  }
  if(botPx>0) out.push(`<tr class="vSpacer"><td colspan="${colCount}" style="height:${botPx}px;padding:0;border:0;"></td></tr>`);

  const tmp = document.createElement('tbody');
  tmp.innerHTML = out.join('') || `<tr><td colspan="${colCount}" style="color:rgba(230,238,248,.66); padding:16px;">Load ShotMarker CSV to see shots.</td></tr>`;
  tbody.replaceChildren(...tmp.children);
}

function wireVirtualScroll(){
  const wrap = el('tableWrap');
  if(!wrap) return;
  wrap.addEventListener('scroll', ()=>{
    if(!tablePrefs.useVirtual || activeBlock) return;
    if(tablePrefs.limit!==0) return; // only meaningful in "All"
    if(vRAF) return;
    vRAF = requestAnimationFrame(()=>{
      vRAF = 0;
      try{ renderTable(); }catch(_e){}
    });
  }, {passive:true});
}

// Columns modal (wired lazily because markup is after the script tag)
function openColsModal(){
  const modal = el('colsModal');
  if(!modal) return;
  modal.classList.remove('hidden');

  const grid = el('colsGrid');
  const presetSel = el('colsPresetSel');
  const savedSel = el('colsSavedSel');
  const layouts = loadLayouts();

  // Build selects
  if(presetSel && !presetSel.dataset.wired){
    presetSel.innerHTML = Object.keys(PRESET_LAYOUTS).map(n=>`<option value="${esc(n)}">${esc(n)}</option>`).join('');
    presetSel.dataset.wired = '1';
  }
  if(savedSel){
    const names = Object.keys(layouts||{}).sort((a,b)=>a.localeCompare(b));
    savedSel.innerHTML = `<option value="">(none)</option>` + names.map(n=>`<option value="${esc(n)}">${esc(n)}</option>`).join('');
  }

  // Working copy
  let working = new Set(normalizeVisibleCols(tablePrefs.visibleCols));

  function renderGrid(){
    if(!grid) return;
    grid.innerHTML = '';
    for(const c of TABLE_COLS){
      const item = document.createElement('div');
      item.className = 'colItem' + (c.locked ? ' locked' : '');
      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.checked = working.has(c.key);
      cb.disabled = !!c.locked;
      cb.addEventListener('change', ()=>{
        if(cb.checked) working.add(c.key);
        else working.delete(c.key);
      });
      const lab = document.createElement('b');
      lab.textContent = c.label;
      const k = document.createElement('div');
      k.className = 'hint';
      k.textContent = c.key;
      item.appendChild(cb);
      item.appendChild(lab);
      item.appendChild(k);
      grid.appendChild(item);
    }
  }
  renderGrid();

  const btnApply = el('btnColsApply');
  const btnCancel = el('btnColsCancel');
  const btnClose = el('btnColsClose');
  const btnReset = el('btnColsReset');
  const btnSave = el('btnColsSave');

  const close = ()=> modal.classList.add('hidden');

  if(btnClose && !btnClose.dataset.wired){
    btnClose.addEventListener('click', close);
    btnClose.dataset.wired='1';
  }
  if(btnCancel && !btnCancel.dataset.wired){
    btnCancel.addEventListener('click', close);
    btnCancel.dataset.wired='1';
  }
  if(btnReset && !btnReset.dataset.wired){
    btnReset.addEventListener('click', ()=>{
      working = new Set(PRESET_LAYOUTS.Full);
      renderGrid();
    });
    btnReset.dataset.wired='1';
  }
  if(presetSel && !presetSel.dataset.wired2){
    presetSel.addEventListener('change', ()=>{
      const nm = presetSel.value;
      if(PRESET_LAYOUTS[nm]){
        working = new Set(normalizeVisibleCols(PRESET_LAYOUTS[nm]));
        renderGrid();
      }
    });
    presetSel.dataset.wired2='1';
  }
  if(savedSel && !savedSel.dataset.wired){
    savedSel.addEventListener('change', ()=>{
      const nm = savedSel.value;
      if(nm && layouts[nm] && Array.isArray(layouts[nm])){
        working = new Set(normalizeVisibleCols(layouts[nm]));
        renderGrid();
      }
    });
    savedSel.dataset.wired='1';
  }
  if(btnSave && !btnSave.dataset.wired){
    btnSave.addEventListener('click', ()=>{
      const nm = prompt('Save layout as (name):', 'My layout');
      if(!nm) return;
      const o = loadLayouts();
      o[nm] = normalizeVisibleCols(Array.from(working));
      saveLayouts(o);
      // refresh list
      if(savedSel){
        const names = Object.keys(o||{}).sort((a,b)=>a.localeCompare(b));
        savedSel.innerHTML = `<option value="">(none)</option>` + names.map(n=>`<option value="${esc(n)}">${esc(n)}</option>`).join('');
        savedSel.value = nm;
      }
      toast(`Saved layout: ${nm}`);
    });
    btnSave.dataset.wired='1';
  }
  if(btnApply && !btnApply.dataset.wired){
    btnApply.addEventListener('click', ()=>{
      tablePrefs.visibleCols = normalizeVisibleCols(Array.from(working));
      saveTablePrefs();
      applyColumnVisibility();
      close();
    });
    btnApply.dataset.wired='1';
  }
}

function setupTablePrefsUI(){
  loadTablePrefs();
  const sel = el('rowsLimitSel');
  if(sel){
    sel.value = String(tablePrefs.limit);
    sel.addEventListener('change', ()=>{
      const v = Number(sel.value);
      tablePrefs.limit = Number.isFinite(v) ? v : 200;
      if(tablePrefs.limit===0 && smShots.length>1200) tablePrefs.useVirtual = true; // safety
      saveTablePrefs();
      updateShotListTitle();
      renderTable();
    });
  }
  const btnV = el('btnVirtual');
  if(btnV){
    btnV.classList.toggle('active', !!tablePrefs.useVirtual);
    btnV.addEventListener('click', ()=>{
      tablePrefs.useVirtual = !tablePrefs.useVirtual;
      if(tablePrefs.useVirtual && tablePrefs.limit!==0) tablePrefs.limit = 0; // "virtual" implies all
      saveTablePrefs();
      btnV.classList.toggle('active', !!tablePrefs.useVirtual);
      updateShotListTitle();
      renderTable();
    });
  }
  const btnCols = el('btnCols');
  if(btnCols){
    btnCols.addEventListener('click', openColsModal);
  }
  wireVirtualScroll();
}

setupTablePrefsUI();




  // ---------- Phase 5.4.7: Clear + JSON Import ----------
  function clearAll(){
    smShots = [];
    smBlocks = [];
    activeBlock = null;
    smFirstDate = null;

    // reset distances
    defaultDistYd = 1000;
    blockDist.clear();
    blockAutoDist.clear();
    geoStats = new Map();
    blockStats = new Map();

    // reset kestrel
    kSamples = [];
    kRange = null;
    ampSession = null;
    if(kMeta) kMeta.textContent = 'No file loaded';

    // reset garmin
    gFiles = [];
    undo = null;

    // reset AMP
    ampSession = null;

    // clear file inputs so re-select works
    const fsm = el('fileSM'); if(fsm) fsm.value = '';
    const fk  = el('fileK');  if(fk) fk.value = '';
    const fg  = el('fileG');  if(fg) fg.value = '';
    const fa = el('fileAMP'); if(fa) fa.value = '';
    const fj  = el('fileJSON'); if(fj) fj.value = '';

    // UI resets
    setPills(null, null, null);
    if(importStatus) importStatus.innerHTML = `<span class="hint">Cleared. Import a ShotMarker CSV or JSON to begin.</span>`;
    if(kStatus) kStatus.innerHTML = '';
    if(blocksMeta){ blocksMeta.textContent = 'Rollups, distance, filters'; blocksMeta.title=''; }
    if(el('blockHint')) el('blockHint').textContent = 'Load ShotMarker or JSON to see block rollups.';
    if(el('defaultDist')) el('defaultDist').value = defaultDistYd;

// Phase 0 schema v2: restore table prefs (if present)
try{
  const t = (data.ui && data.ui.table) ? data.ui.table : null;
  if(t){
    if(Number.isFinite(+t.limit)) tablePrefs.limit = +t.limit;
    if(typeof t.useVirtual==='boolean') tablePrefs.useVirtual = t.useVirtual;
    if(Array.isArray(t.visibleCols)) tablePrefs.visibleCols = t.visibleCols.slice(0);
    tablePrefs.visibleCols = normalizeVisibleCols(tablePrefs.visibleCols);
    saveTablePrefs();
    // sync controls if present
    if(el('rowsLimitSel')) el('rowsLimitSel').value = String(tablePrefs.limit);
    if(el('btnVirtual')) el('btnVirtual').classList.toggle('active', !!tablePrefs.useVirtual);
  }
}catch(_e){}

    renderGarminMapping();
    renderBlockRollups();
    renderTable();
    if(el('importStatus')) el('importStatus').innerHTML = `<span class=\"good\">Cleared.</span>`;
  }

  function escA(s){
    return String(s==null?'':s)
      .replace(/&/g,'&amp;')
      .replace(/"/g,'&quot;')
      .replace(/</g,'&lt;')
      .replace(/>/g,'&gt;');
  }

  function renderPairingPanel(){
    const card = el('pairingCard');
    const listEl = el('pairingList');
    const metaEl = el('pairMetaLine');
    if(!card || !listEl) return;

    if(!smBlocks || !smBlocks.length){
      card.style.display = 'none';
      return;
    }
    card.style.display = '';

    const gcount = (gFiles && gFiles.length) ? gFiles.length : 0;
    if(metaEl){
      const base = 'ShotMarker strings → Chrono sources';
      metaEl.textContent = gcount ? `${base} • ${smBlocks.length} strings • ${gcount} chrono files` : base;
    }

    if(!gcount){
      listEl.innerHTML = `<div class="hint">Load chrono/Garmin files to enable pairing.</div>`;
      return;
    }

    const groups = groupByBlock();
    const optHtml = ['<option value="">— Select chrono file —</option>']
      .concat(gFiles.map(g=>`<option value="${escA(g.name)}">${esc(g.name)} (${(g.shots&&g.shots.length)||0})</option>`))
      .join('');

    const rows = [];
    for(let i=0;i<smBlocks.length;i++){
      const blk = smBlocks[i].label;
      const shots = groups.get(blk) || [];
      const total = shots.length;
      let rec=0, sighters=0;
      for(const sh of shots){
        const st = (sh.state||'RECORD');
        if(st==='SIGHTER') sighters++;
        else if(st==='RECORD') rec++;
      }
      const vs = blockStats.get(blk) || computeVelStats(shots);
      const mean = (vs.mean!=null && Number.isFinite(vs.mean)) ? Math.round(vs.mean) : '—';
      const sd = (vs.sd!=null && Number.isFinite(vs.sd)) ? vs.sd.toFixed(1) : '—';
      const es = (vs.es!=null && Number.isFinite(vs.es)) ? Math.round(vs.es) : '—';

      const cur = chronoPair.get(blk);
      const selName = cur && cur.name ? cur.name : '';

      // warn styling if mismatch counts exist
      let warn = '';
      if(selName){
        const gf = gFiles.find(g=>g.name===selName);
        const gshots = gf ? ((gf.shots&&gf.shots.length)||0) : 0;
        if(total && gshots && gshots !== total) warn = ' warn';
      }

      rows.push(`
        <div class="pairRow${warn}">
          <div class="pairLeft">
            <span class="pill">${esc(blk)}</span>
            <div class="pairMeta">
              <span class="chip">shots: ${rec}</span>
              <span class="chip">sighters: ${sighters}</span>
              <span class="chip">avg ${mean}</span>
              <span class="chip">SD ${sd}</span>
              <span class="chip">ES ${es}</span>
            </div>
          </div>
          <div class="pairRight"><div class="pairCtl"><div class="pairCtlLbl">Chrono file</div><select class="sel" data-pair-block="${escA(blk)}">${optHtml}</select></div></div>
        </div>
      `);
    }
    listEl.innerHTML = rows.join('');

    // apply selections + bind changes
    const sels = listEl.querySelectorAll('select[data-pair-block]');
    sels.forEach(sel=>{
      const blk = sel.getAttribute('data-pair-block') || '';
      const cur = chronoPair.get(blk);
      sel.value = (cur && cur.name) ? cur.name : '';

      sel.addEventListener('change', ()=>{
        const name = sel.value || '';
        if(name){
          chronoPair.set(blk, {name, start: 1});
        } else {
          chronoPair.delete(blk);
        }
        const res = smShots.length ? applyGarminToShots() : {matched:0, overrides:0, unmapped:0, extra:0};
        recomputeAndRender();

        const st = el('gStatus');
        if(st){
          st.innerHTML = `<span class="good">Pairings updated.</span> Matched ${res.matched} • Overrides ${res.overrides}`;
        }
      });
    });
  }


function importFromJSON(txt, name){
    const data = JSON.parse(txt);

    if(!data || !Array.isArray(data.shots)){
      throw new Error('Invalid ShotLedger JSON (missing shots[]).');
    }

    // Clear first (but keep rollups collapsed state etc.)
    smShots = [];
    smBlocks = [];
    activeBlock = (data.ui && data.ui.activeBlock) ? data.ui.activeBlock : null;

    // UI defaults
    defaultDistYd = (data.ui && Number.isFinite(+data.ui.defaultDistYd)) ? +data.ui.defaultDistYd : 1000;
    if(el('defaultDist')) el('defaultDist').value = defaultDistYd;

    // Restore per-block chrono pairings (optional)
    chronoPair.clear();
    if(data.ui && Array.isArray(data.ui.chronoPairings)){
      for(const p of data.ui.chronoPairings){
        if(!p || !p.block) continue;
        chronoPair.set(p.block, {name: p.name||'', start: (p.start!=null ? Number(p.start) : 1)});
      }
    }

    // Clear any selection
    selectedShots.clear();
    updateSelPill();

    // Restore distances per block
    blockDist.clear();
    blockAutoDist.clear();
    if(Array.isArray(data.blocks)){
      for(const b of data.blocks){
        if(!b || !b.block) continue;
        const dist = b.distance || {};
        if(dist && Number.isFinite(+dist.manualYd) && +dist.manualYd>0){
          blockDist.set(b.block, +dist.manualYd);
        }
        if(dist && Number.isFinite(+dist.shotMarkerYd) && +dist.shotMarkerYd>0){
          blockAutoDist.set(b.block, +dist.shotMarkerYd);
        }
      }
    }

    // Restore shots
    for(const s of data.shots){
      if(!s) continue;
      const sh = {
        idx: Number(s.idx),
        block: s.block || '(unknown)',
        blockDate: s.blockDate || '',
        relTime: s.relTime || '',
        tag: s.tag || '',
        score: s.score || '',
        vel: (s.velSM!=null ? String(s.velSM) : (s.vel!=null ? String(s.vel) : '')),
        velSM: (s.velSM!=null && Number.isFinite(+s.velSM)) ? +s.velSM : null,
        velActive: (s.velActive!=null && Number.isFinite(+s.velActive)) ? +s.velActive : ((s.velSM!=null && Number.isFinite(+s.velSM)) ? +s.velSM : null),
        velSrc: s.velSrc || 'SM',
        // manual inputs (optional)
        primerSeat: (s.primerSeat!=null && Number.isFinite(+s.primerSeat)) ? +s.primerSeat : null,
        windZero: (s.windZero!=null && Number.isFinite(+s.windZero)) ? +s.windZero : null,
        elevZero: (s.elevZero!=null && Number.isFinite(+s.elevZero)) ? +s.elevZero : null,
        windCall: s.windCall || null,
        notes: s.notes || null,
        // geometry
        xIn: (s.xIn!=null && Number.isFinite(+s.xIn)) ? +s.xIn : null,
        yIn: (s.yIn!=null && Number.isFinite(+s.yIn)) ? +s.yIn : null,
        hMoa: (s.hMoa!=null && Number.isFinite(+s.hMoa)) ? +s.hMoa : null,
        vMoa: (s.vMoa!=null && Number.isFinite(+s.vMoa)) ? +s.vMoa : null,
        rMoa: (s.rMoa!=null && Number.isFinite(+s.rMoa)) ? +s.rMoa : null,
        // AMP (optional)
        ampPeak: (s.ampPeak!=null && Number.isFinite(+s.ampPeak)) ? +s.ampPeak : null,
        ampWork: (s.ampWork!=null && Number.isFinite(+s.ampWork)) ? +s.ampWork : null,
        ampStartPos: (s.ampStartPos!=null && Number.isFinite(+s.ampStartPos)) ? +s.ampStartPos : null,
        ampZ: (s.ampZ!=null && Number.isFinite(+s.ampZ)) ? +s.ampZ : null,
        ampZPeak: (s.ampZPeak!=null && Number.isFinite(+s.ampZPeak)) ? +s.ampZPeak : null,
        ampZWork: (s.ampZWork!=null && Number.isFinite(+s.ampZWork)) ? +s.ampZWork : null,
        ampZStart: (s.ampZStart!=null && Number.isFinite(+s.ampZStart)) ? +s.ampZStart : null,
        // state + provenance
        state: s.state || 'RECORD',
        stateSrc: s.stateSrc || '',
        // kestrel (optional)
        j: s.j || s.join || null,
        kdt: (s.kdt!=null && Number.isFinite(+s.kdt)) ? +s.kdt : (s.dt!=null && Number.isFinite(+s.dt) ? +s.dt : null),
        k: s.k || null
      };
      smShots.push(sh);
    }

    // Rebuild blocks list
    const seen = new Map();
    for(const sh of smShots){
      if(!seen.has(sh.block)) seen.set(sh.block, {label: sh.block, dateStr: sh.blockDate || '', n: 0, distYdAuto: blockAutoDist.get(sh.block) || null});
      seen.get(sh.block).n += 1;
    }
    smBlocks = Array.from(seen.values());

    // Attempt to set first date (for Kestrel date helper)
    smFirstDate = null;
    for(const b of smBlocks){
      const dt = parseSMDateStr(b.dateStr);
      if(dt){ smFirstDate = dt; break; }
    }

    // Pills/status
    setPills(name || 'ShotLedger JSON', (kSamples.length? (kMeta.textContent||'Kestrel loaded') : null),
             (gFiles.length ? gFiles.map(g=>({name:g.name,count:(g.shots?g.shots.length:0)})) : null));
    importStatus.innerHTML = `<span class="good">Imported JSON.</span> <span class="hint">Shots: <b>${smShots.length}</b> • Blocks: <b>${smBlocks.length}</b></span>`;

    // Recompute derived stats to ensure everything is coherent (MOA will be recomputed if coords exist)
    recomputeBlockStats();
    recomputeGeoStats();
    renderBlockRollups();
    renderTable();
  }

  function el(id){ return document.getElementById(id); }

// --- Minimal UI helpers (some builds call these) ---
  function toast(msg){
    try{
      const s = el('importStatus') || el('kStatus') || el('manStatus');
      if(s){
        s.textContent = String(msg ?? '');
      }else{
        if(SL_DEBUG) console.log(msg);
      }
    }catch(_e){
      if(SL_DEBUG) console.log(msg);
    }
  }

  // Central re-render hook used by importers
  function render(){
    try{ renderPairingPanel && renderPairingPanel(); }catch(_e){}
    try{ renderGarminMapping && renderGarminMapping(); }catch(_e){}
    try{ renderBlockRollups && renderBlockRollups(); }catch(_e){}
    try{ renderSummaries && renderSummaries(); }catch(_e){}
    try{ renderTable && renderTable(); }catch(_e){}
  }


// Phase 2: single recompute+render pipeline (keeps UI + stats in sync)
function recomputeAndRender(opts){
  const o = Object.assign({vel:true, geo:true, render:true, stepper:true}, opts||{});
  try{ if(o.vel) recomputeBlockStats(); }catch(_e){}
  try{ if(o.geo) recomputeGeoStats(); }catch(_e){}
  try{ if(o.render) render(); }catch(_e){}
  if(o.stepper){
    try{ updateImportStepper(); }catch(_e){}
    try{ updateImportSummary(); }catch(_e){}
  }
}

function pairingSummary(){
  const total = (smBlocks && smBlocks.length) ? smBlocks.length : 0;
  if(!total) return {total:0, paired:0, unpaired:0, mismatched:0};
  const groups = groupByBlock();
  const byName = new Map((gFiles||[]).map(g=>[g.name, g]));
  let paired=0, mismatched=0;
  for(const b of smBlocks){
    const blk = b.label;
    const pair = chronoPair.get(blk);
    if(!pair || !pair.name) continue;
    paired++;
    const gf = byName.get(pair.name);
    const gcount = gf && gf.shots ? gf.shots.length : 0;
    const scount = (groups.get(blk)||[]).length;
    if(gcount && scount && gcount !== scount) mismatched++;
  }
  const unpaired = Math.max(0, total - paired);
  return {total, paired, unpaired, mismatched};
}

function updateImportStepper(){
  const host = el('importStepper');
  if(!host) return;

  const smOk = !!(smShots && smShots.length);
  const gOk = !!(gFiles && gFiles.length);
  const kOk = !!(kSamples && kSamples.length);
  const aOk = !!(ampSession && (ampSession.n||0));
  const ps = pairingSummary();

  const step1Badge = smOk ? `<span class="badge good">Loaded</span>` : `<span class="badge off">Missing</span>`;
  const step1Msg = smOk ? `Shots: <b>${smShots.length}</b> • Blocks: <b>${smBlocks.length||0}</b>` : `Import a ShotMarker CSV (targets + shots).`;

  let step2Cls = 'off', step2Txt='Optional';
  if(gOk){
    if(ps.unpaired || ps.mismatched){ step2Cls='warn'; step2Txt='Check pairing'; }
    else { step2Cls='good'; step2Txt='Ready'; }
  }
  const step2Badge = `<span class="badge ${step2Cls}">${step2Txt}</span>`;
  const step2Msg = gOk
    ? `Garmin files: <b>${gFiles.length}</b> • Paired: <b>${ps.paired}/${ps.total}</b>${ps.mismatched?` • Mismatch: <b>${ps.mismatched}</b>`:''}`
    : `Load chrono/Garmin CSVs (1 per target) to override velocities.`;

  let step3Cls = (kOk||aOk) ? 'good' : 'off';
  let step3Txt = (kOk||aOk) ? 'Loaded' : 'Optional';
  const step3Badge = `<span class="badge ${step3Cls}">${step3Txt}</span>`;
  const step3Msg = (kOk||aOk)
    ? `${kOk?`Kestrel samples: <b>${kSamples.length}</b>`:'Kestrel not loaded'}${(kOk&&aOk)?' • ':''}${aOk?`AMP traces: <b>${ampSession.n}</b>`:'AMP not loaded'}`
    : `Load Kestrel/AMP if you want per-shot environment / anomalies.`;

  host.innerHTML = `
    <div class="step">
      <div class="left"><div class="t">1) ShotMarker</div><div class="m">${step1Msg}</div></div>
      ${step1Badge}
    </div>
    <div class="step">
      <div class="left"><div class="t">2) Chrono pairing</div><div class="m">${step2Msg}</div></div>
      ${step2Badge}
    </div>
    <div class="step">
      <div class="left"><div class="t">3) Kestrel / AMP</div><div class="m">${step3Msg}</div></div>
      ${step3Badge}
    </div>
  `;
}

function updateImportSummary(){
  const box = el('importSummary');
  if(!box) return;
  const hasAnything = (smShots && smShots.length) || (gFiles && gFiles.length) || (kSamples && kSamples.length) || (ampSession && ampSession.n);
  if(!hasAnything){ box.style.display='none'; box.innerHTML=''; return; }
  const ps = pairingSummary();
  const gTotal = (gFiles||[]).reduce((a,g)=>a+((g.shots&&g.shots.length)||0),0);
  box.style.display='';
  box.innerHTML = `
    <div><b>Detected</b></div>
    <div style="margin-top:6px;">
      ${smShots.length?`• ShotMarker: <b>${smShots.length}</b> shots in <b>${smBlocks.length||0}</b> blocks<br>`:''}
      ${gFiles.length?`• Garmin: <b>${gFiles.length}</b> files • <b>${gTotal}</b> total chrono shots • Paired <b>${ps.paired}/${ps.total}</b>${ps.mismatched?` • Mismatch <b>${ps.mismatched}</b>`:''}<br>`:''}
      ${kSamples.length?`• Kestrel: <b>${kSamples.length}</b> samples${kRange?` • Range ${esc(kRange.minStr)}–${esc(kRange.maxStr)}`:''}<br>`:''}
      ${(ampSession && ampSession.n)?`• AMP: <b>${ampSession.n}</b> traces<br>`:''}
    </div>
  `;
}

  function updateSelPill(){
    const p = el('selCountPill');
    if(p) p.textContent = `Selected: ${selectedShots.size||0}`;
  }

  function manualPayload(){
    const numOrNull = (v)=>{
      if(v==null) return null;
      const s = String(v).trim();
      if(!s) return null;
      const n = Number(s);
      return Number.isFinite(n) ? n : null;
    };
    const strOrNull = (v)=>{
      const s = (v==null) ? '' : String(v).trim();
      return s ? s : null;
    };
    return {
      primerSeat: numOrNull(el('manPrimerSeat') && el('manPrimerSeat').value),
      windZero: numOrNull(el('manWindZero') && el('manWindZero').value),
      elevZero: numOrNull(el('manElevZero') && el('manElevZero').value),
      windCall: strOrNull(el('manWindCall') && el('manWindCall').value),
      notes: strOrNull(el('manNotes') && el('manNotes').value),
      state: strOrNull(el('manStateSel') && el('manStateSel').value)
    };
  }

  function applyManualToShots(shots){
    const p = manualPayload();
    const changed = {n:0};

    // If we're bulk-setting state, do it as a batch so we recompute once and keep Undo useful.
    const doState = (p.state!=null);
    const undoItems = [];
    if(doState) bulkStateMode = true;

    for(const sh of shots){
      if(p.primerSeat!=null) sh.primerSeat = p.primerSeat;
      if(p.windZero!=null) sh.windZero = p.windZero;
      if(p.elevZero!=null) sh.elevZero = p.elevZero;
      if(p.windCall!=null) sh.windCall = p.windCall;
      if(p.notes!=null) sh.notes = p.notes;

      if(doState){
        undoItems.push({shotIdx: sh.idx, prevState:(sh.state||'RECORD'), prevSrc:(sh.stateSrc||'')});
        setShotStateByIdx(sh.idx, p.state, false, 'MANUAL');
      }

      changed.n++;
    }

    if(doState){
      bulkStateMode = false;
      undo = {type:'multiShot', items: undoItems};
      recomputeBlockStats();
      recomputeGeoStats();
      renderBlockRollups();
    }

    return {p, changed:changed.n};
  }

  function applyChronoPairings(){
    if(!smShots.length || !gFiles.length) return {blocks:0, mapped:0, missing:0};
    let blocks=0, mapped=0, missing=0;

    // helper: lookup gFile by name
    const byName = new Map(gFiles.map(g=>[g.name, g]));
    const groups = groupByBlock();

    const showChronoCtl = shouldShowChronoControls();
    for(const [block, list] of groups.entries()){
      const pair = chronoPair.get(block);
      if(!pair || !pair.name) continue;
      const g = byName.get(pair.name);
      if(!g || !g.shots || !g.shots.length){ missing += list.length; continue; }
      blocks++;
      const start = Math.max(1, Number(pair.start||1)) - 1;
      // map in shot index order
      const ordered = [...list].sort((a,b)=>a.idx-b.idx);
      for(let i=0;i<ordered.length;i++){
        const sh = ordered[i];
        const gi = start + i;
        const gs = g.shots[gi];
        const v = gs && Number.isFinite(gs.vel) ? gs.vel : null;
        if(v!=null){
          sh.velG = v;
          sh.velActive = v;
          sh.velSrc = 'GARMIN';
          mapped++;
        } else {
          // fall back to SM
          sh.velG = null;
          sh.velActive = (sh.velSM!=null ? sh.velSM : null);
          sh.velSrc = 'SM';
        }
      }
    }
    recomputeBlockStats();
    renderBlockRollups();
    renderTable();
    return {blocks, mapped, missing};
  }

  const importPills = el('importPills');
  const importStatus = el('importStatus');
  const shotTbody = el('shotTbody');
  const kStatus = el('kStatus');
  const blocksMeta = el('blocksMeta');
  const kMeta = el('kMeta');
  const kBody = el('kBody');
  const kChevron = el('kChevron');
  const rightCol = el('rightCol');
  const gridEl = el('grid');
  const toggleRightBtn = el('toggleRightBtn');
  // ---------- rollup helpers (Tools / Blocks) ----------
  function wireRollup(headerEl, bodyEl, chevronEl, startCollapsed=false){
    if(!headerEl || !bodyEl || !chevronEl) return;
    const set = (collapsed)=>{
      bodyEl.classList.toggle('hidden', collapsed);
      chevronEl.textContent = collapsed ? '▸' : '▾';
      headerEl.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
    };
    set(!!startCollapsed);
    headerEl.addEventListener('click', ()=> set(!bodyEl.classList.contains('hidden')));
  }

  wireRollup(el('toolsHeader'), el('toolsBody'), el('toolsChevron'), true);
  wireRollup(el('pairHeader'), el('pairBody'), el('pairChevron'), true);
  wireRollup(el('blocksHeader'), el('blocksBody'), el('blocksChevron'), true);
  wireRollup(el('manHeader'), el('manBody'), el('manChevron'), true);


  function setPills(smName, kName, gList){
    // gList: array of {name, count} or strings
    importPills.innerHTML = '';
    if(smName){
      const p = document.createElement('div'); p.className='pill';
      p.innerHTML = `<span class="good">ShotMarker</span> <span style="opacity:.8;">•</span> <span style="opacity:.9;white-space:nowrap;max-width:520px;">${esc(smName)}</span>`;
      importPills.appendChild(p);
    }
    if(kName){
      const p = document.createElement('div'); p.className='pill';
      p.innerHTML = `<span class="good">Kestrel</span> <span style="opacity:.8;">•</span> <span style="opacity:.9;white-space:nowrap;max-width:520px;">${esc(kName)}</span>`;
      importPills.appendChild(p);
    }
    const arr = Array.isArray(gList) ? gList : (gList ? [gList] : []);
    for(const gi of arr){
      const name = (typeof gi === 'string') ? gi : (gi && gi.name ? gi.name : '');
      if(!name) continue;
      const count = (typeof gi === 'object' && gi && typeof gi.count==='number') ? gi.count : null;
      const p = document.createElement('div'); p.className='pill';
      p.innerHTML = `<span class="good">Garmin</span> <span style="opacity:.8;">•</span> <span style="opacity:.9;white-space:nowrap;max-width:520px;">${esc(name)}</span>${count!=null ? ` <span style="opacity:.7;">•</span> <span style="opacity:.85;">${count} shots</span>`:''}`;
      importPills.appendChild(p);
    }
    // AMP (optional)
    if(typeof ampSession !== 'undefined' && ampSession && ampSession.n){
      const p = document.createElement('div'); p.className='pill';
      const nm = ampSession.name ? ampSession.name : 'AMP';
      p.innerHTML = `<span class="good">AMP</span> <span style="opacity:.8;">•</span> <span style="opacity:.9;white-space:nowrap;max-width:520px;">${esc(nm)}</span> <span style="opacity:.8;">•</span> <span style="opacity:.9;">${ampSession.n} traces</span>`;
      importPills.appendChild(p);
    }
    try{ updateImportStepper(); }catch(_e){}
    try{ updateImportSummary(); }catch(_e){}
  }

  function esc(s){ return (s||'').replace(/[&<>"]/g, c=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;" }[c])); }

  function formatVel(vActive, vFallback){
    const v = (vActive!=null && Number.isFinite(vActive) && vActive>0) ? vActive : null;
    if(v!=null) return Math.round(v).toString();
    const n = parseFloat(String(vFallback||'').trim());
    return Number.isFinite(n) ? Math.round(n).toString() : esc(vFallback||'');
  }


  function inferStateFromTag(tag){
    const t = String(tag||'').toLowerCase();
    if(/sight/.test(t) || /\bsgt\b/.test(t) || /\bsighter\b/.test(t)) return 'SIGHTER';
    return 'RECORD';
  }

  function stateCell(sh){
    const st = (sh && sh.state) ? sh.state : 'RECORD';
    const a = (st==='RECORD') ? 'active' : '';
    const b = (st==='SIGHTER') ? 'active' : '';
    const c = (st==='EXCLUDE') ? 'active' : '';
    const src = (sh.stateSrc||"");
    const extra = (st==="EXCLUDE" ? (src==="FLAG" ? " (exclude: flag)" : (src ? ` (exclude: ${src.toLowerCase()})` : " (exclude: manual)")) : (st==="SIGHTER" ? (src==="TAG" ? " (sighter: tag)" : (src ? ` (sighter: ${src.toLowerCase()})` : "")) : ""));
    return `<div class="stateCtl" title="Shot state: Record counts in stats; Sighter + Exclude do not.${extra}">
      <button class="sbtn rec ${a}" data-idx="${sh.idx}" data-state="RECORD" type="button">R</button>
      <button class="sbtn sgt ${b}" data-idx="${sh.idx}" data-state="SIGHTER" type="button">S</button>
      <button class="sbtn exc ${c}" data-idx="${sh.idx}" data-state="EXCLUDE" type="button">\u2715</button>
    </div>`;
  }


  
  function ampPill(sh){
    if(!sh) return '';
    const z = sh.ampZ;
    if(z==null || !Number.isFinite(z)) return '';
    const az = Math.abs(z);

    // Determine which metric drove the max anomaly
    const cand = [
      {k:'Peak', z: sh.ampZPeak},
      {k:'Work', z: sh.ampZWork},
      {k:'Start', z: sh.ampZStart},
    ].filter(o => o.z!=null && Number.isFinite(o.z));
    let top = {k:'', z:null};
    for(const o of cand){
      if(top.z==null || Math.abs(o.z) > Math.abs(top.z)) top = o;
    }

    // Match ΔVel chip styling thresholds
    let cls = 'flagchip ok';
    if(az>1.9) cls='flagchip bad';
    else if(az>1.3) cls='flagchip problem';
    else if(az>0.7) cls='flagchip warn';

    const zpk = (sh.ampZPeak!=null && Number.isFinite(sh.ampZPeak)) ? (sh.ampZPeak>=0?'+':'')+sh.ampZPeak.toFixed(2) : '—';
    const zwk = (sh.ampZWork!=null && Number.isFinite(sh.ampZWork)) ? (sh.ampZWork>=0?'+':'')+sh.ampZWork.toFixed(2) : '—';
    const zst = (sh.ampZStart!=null && Number.isFinite(sh.ampZStart)) ? (sh.ampZStart>=0?'+':'')+sh.ampZStart.toFixed(2) : '—';

    const tip = `AMP anomaly = max(|z|) across metrics (this shot). ` +
                `Driver: ${top.k||'—'} (|z|=${az.toFixed(2)}σ)\n` +
                `Peak z=${zpk}σ, Work z=${zwk}σ, Start z=${zst}σ`;
    return `<span class="${cls}" title="${escA(tip)}">${az.toFixed(1)}σ</span>`;
  }

function joinPill(status){
    const s = String(status||'').toUpperCase();
    if(!s) return '';
    let cls = 'muted', label = s;
    if(s==='JOIN'){ cls='ok'; label='JOIN'; }
    else if(s==='MISS'){ cls='warn'; label='MISS'; }
    else if(s==='OUT'){ cls='muted'; label='OUT'; }
    else if(s==='BADMAP' || s==='BAD'){ cls='bad'; label='BAD'; }
    return `<span class="joinpill ${cls}">${esc(label)}</span>`;
  }

  // ---------- utilities ----------
  function parseHMS(s){
    // "19:28:10"
    const m = String(s||'').trim().match(/^(\d{1,2}):(\d{2})(?::(\d{2}))?$/);
    if(!m) return null;
    const hh = +m[1], mm=+m[2], ss=+(m[3]||0);
    if(hh>23||mm>59||ss>59) return null;
    return hh*3600 + mm*60 + ss;
  }
  function parseSMDateStr(dateStr){
    // Supports ShotMarker archive headers like "Sep 25 2025" OR "12/27/2025"
    const s = String(dateStr||'').trim();
    // "Sep 25 2025"
    let m = s.match(/^([A-Za-z]{3})\s+(\d{1,2})\s+(\d{4})$/);
    if(m){
      const mon = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"].indexOf(m[1]);
      if(mon<0) return null;
      const d = +m[2], y=+m[3];
      const dt = new Date(Date.UTC(y, mon, d, 0,0,0));
      return isNaN(dt.getTime()) ? null : dt;
    }
    // "12/27/2025" (MM/DD/YYYY)
    m = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
    if(m){
      const mo = +m[1], d = +m[2], y = +m[3];
      const dt = new Date(Date.UTC(y, mo-1, d, 0,0,0));
      return isNaN(dt.getTime()) ? null : dt;
    }
    return null;
  }

  function parseDistanceYdFromBlockHeader(parts){
    // parts: CSV fields from a block header line, e.g. ["Sep 25 2025","R3","#227 (HWW)","1000yd", ...]
    // ShotMarker exports vary; this tries multiple common patterns.
    const joined = parts.map(p=>String(p||'').trim()).join(' ').replace(/\s+/g,' ').trim();

    // Explicit "####yd" / "#### yd" / "yards"
    let mm = joined.match(/\b(\d{2,4})\s*(yd|yard|yards)\b/i);
    if(mm){
      const n = Number(mm[1]);
      if(Number.isFinite(n) && n>=25 && n<=2500) return n;
    }

    // Explicit meters: "####m"
    mm = joined.match(/\b(\d{2,4})\s*m\b/i);
    if(mm){
      const n = Number(mm[1]);
      if(Number.isFinite(n) && n>=25 && n<=3000){
        return n / 0.9144; // meters -> yards
      }
    }

    // Keyed fields: "Distance", "Range"
    for(let i=0;i<parts.length-1;i++){
      const key = String(parts[i]||'').toLowerCase();
      if(key.includes('distance') || key.includes('range')){
        const val = String(parts[i+1]||'').trim();
        let m2 = val.match(/^(\d{2,4})(?:\s*(yd|yard|yards))?$/i);
        if(m2){
          const n = Number(m2[1]);
          if(Number.isFinite(n) && n>=25 && n<=2500) return n;
        }
        m2 = val.match(/^(\d{2,4})\s*m$/i);
        if(m2){
          const n = Number(m2[1]);
          if(Number.isFinite(n) && n>=25 && n<=3000) return n/0.9144;
        }
      }
    }

    // Fallback: a lone plausible distance token (avoid #227 etc by requiring not preceded by '#')
    const tokens = joined.split(/[^0-9]+/).filter(Boolean).map(Number).filter(n=>Number.isFinite(n));
    // Prefer common match distances if present
    const common = [100,200,300,600,800,900,1000,1200,1400,1760];
    for(const c of common){
      if(tokens.includes(c)) return c;
    }
    // Otherwise pick the largest plausible (often distance is the largest number in header aside from year)
    const filtered = tokens.filter(n=>n>=25 && n<=2500 && n!==2024 && n!==2025 && n!==2026);
    if(filtered.length){
      return Math.max(...filtered);
    }
    return null;
  }

  function dateToISO(d){
    const y = d.getUTCFullYear();
    const m = String(d.getUTCMonth()+1).padStart(2,'0');
    const da = String(d.getUTCDate()).padStart(2,'0');
    return `${y}-${m}-${da}`;
  }
  function epochFromLocal(dateISO, secondsSinceMidnight){
    // Treat as local time (browser). Kestrel timestamps are local formatted as string; we parse them as local too.
    const [y,m,d] = dateISO.split('-').map(Number);
    const base = new Date(y, m-1, d, 0,0,0,0).getTime()/1000;
    return base + secondsSinceMidnight;
  }

  // ---------- ShotMarker archive parser ----------
  function stripBOM(s){ return String(s||'').replace(/^\ufeff+/,''); }

  // ---------- ShotMarker parser (archive OR single-session CSV) ----------
  function parseShotMarkerArchive(text){
    const raw = String(text||'');
    const lines = raw.split(/\r?\n/);

    const blocks = [];
    const shots = [];
    let curBlock = null;
    let inShots = false;
    let shotIdx = 0;

    for(let i=0;i<lines.length;i++){
      const lineRaw = lines[i];
      const line = stripBOM(lineRaw);
      if(!line || !line.trim()) continue;

      const parts = splitCSV(line);

      // Block header: "Sep 25 2025,R3,#227 (HWW),..." OR "12/27/2025,R1,..."
      const p0 = stripBOM(parts[0]||'').trim();
      const p1 = String(parts[1]||'').trim();
      if(parts.length>=2 && parseSMDateStr(p0) && /^R\d+/i.test(p1)){
        const dateStr = p0;
        const round = p1.toUpperCase();
        const label = `${dateStr} ${round}`;
        const distYd = parseDistanceYdFromBlockHeader(parts);
        curBlock = { label, dateStr, n:0, distYdAuto: distYd };
        blocks.push(curBlock);
        inShots = false;
        continue;
      }

      // Header line inside block (ShotMarker variations may have whitespace/quotes/BOM/case)
      const low = line.trimStart().toLowerCase();
      if(curBlock && (low.startsWith(',time,') || low.startsWith('"",time,') || low.startsWith(', time,'))){
        inShots = true;
        continue;
      }

      // Shot rows inside block
      if(curBlock && inShots && low.startsWith(',')){
        const row = splitCSV(line);
        // Expected: ["", time, tags, id, score, temp C, x mm, y mm, v fps, ...]
        const relTime = (row[1]||'').trim();
        if(!relTime || relTime.toLowerCase()==='time' || !/^\d/.test(relTime)) continue;

        const tag = (row[2]||'').trim();
        const score = (row[4]||'').trim();
        const xMm = (row[6]||'').trim();
        const yMm = (row[7]||'').trim();
        const vel = (row[8]||'').trim();

        shotIdx += 1;
        curBlock.n += 1;
        shots.push({ idx: shotIdx, block: curBlock.label, blockDate: curBlock.dateStr, relTime, tag, score, vel, xMm, yMm });
      }
    }

    // Fallback: if archive parsing found nothing, try a single-session CSV layout
    if(!shots.length){
      return parseShotMarkerFlat(raw);
    }
    return { blocks, shots };
  }

  function parseShotMarkerFlat(text){
    const raw = String(text||'');
    const lines = raw.split(/\r?\n/).map(stripBOM);
    let headerRow = null;
    let headerIdx = -1;

    // Find a header line that looks like a normal CSV table (no archive block headers)
    for(let i=0;i<Math.min(lines.length, 80);i++){
      const ln = lines[i];
      if(!ln || !ln.trim()) continue;
      const row = splitCSV(ln).map(x=>String(x||'').replace(/^"|"$/g,'').trim());
      const low = row.map(c=>c.toLowerCase());

      const hasTime = low.some(c=>c==='time' || c.includes('time'));
      const hasX = low.some(c=>c==='x' || c.includes('x (mm)') || (c.includes('x') && c.includes('mm')));
      const hasY = low.some(c=>c==='y' || c.includes('y (mm)') || (c.includes('y') && c.includes('mm')));
      const hasVel = low.some(c=>c.includes('vel') || (c.includes('v') && c.includes('fps')) || c.includes('speed'));
      if(hasTime && hasX && hasY && hasVel){
        headerRow = row;
        headerIdx = i;
        break;
      }
    }

    if(!headerRow){
      return { blocks:[], shots:[] };
    }

    const idxOf = (pred)=>{
      for(let i=0;i<headerRow.length;i++){
        const c = headerRow[i].toLowerCase();
        if(pred(c)) return i;
      }
      return -1;
    };

    const iTime = idxOf(c=>c==='time' || c.includes('time'));
    const iTags = idxOf(c=>c==='tags' || c.includes('tag'));
    const iScore = idxOf(c=>c==='score' || c.includes('points'));
    const iXmm = idxOf(c=>c==='x' || c.includes('x (mm)') || (c.includes('x') && c.includes('mm')));
    const iYmm = idxOf(c=>c==='y' || c.includes('y (mm)') || (c.includes('y') && c.includes('mm')));
    const iVel = idxOf(c=>c.includes('vel') || (c.includes('v') && c.includes('fps')) || c.includes('speed'));

    // Try to infer a date somewhere in the file for labeling
    let dateStr = '';
    for(let i=0;i<Math.min(lines.length, 40);i++){
      const m1 = String(lines[i]||'').match(/\b(\d{1,2}\/\d{1,2}\/\d{4})\b/);
      if(m1){ dateStr = m1[1]; break; }
      const m2 = String(lines[i]||'').match(/\b([A-Za-z]{3}\s+\d{1,2}\s+\d{4})\b/);
      if(m2){ dateStr = m2[1]; break; }
    }
    if(!dateStr) dateStr = 'Session';

    const blockLabel = (dateStr==='Session') ? 'Session R1' : `${dateStr} R1`;
    const blocks = [{label:blockLabel, dateStr:(dateStr==='Session'?'':dateStr), n:0, distYdAuto: null}];

    const shots = [];
    let shotIdx = 0;

    for(let i=headerIdx+1;i<lines.length;i++){
      const ln = lines[i];
      if(!ln || !ln.trim()) continue;
      const row = splitCSV(ln).map(x=>String(x||'').replace(/^"|"$/g,'').trim());
      const relTime = (iTime>=0 ? (row[iTime]||'').trim() : '');
      if(!relTime || relTime.toLowerCase()==='time') continue;

      const xMm = (iXmm>=0 ? (row[iXmm]||'').trim() : '');
      const yMm = (iYmm>=0 ? (row[iYmm]||'').trim() : '');

      // if row is clearly not a data row, skip
      if(!xMm && !yMm && iVel>=0 && !(row[iVel]||'').trim()) continue;

      shotIdx += 1;
      blocks[0].n += 1;
      shots.push({
        idx: shotIdx,
        block: blockLabel,
        blockDate: blocks[0].dateStr,
        relTime,
        tag: (iTags>=0 ? (row[iTags]||'').trim() : ''),
        score: (iScore>=0 ? (row[iScore]||'').trim() : ''),
        vel: (iVel>=0 ? (row[iVel]||'').trim() : ''),
        xMm,
        yMm
      });
    }

    return { blocks, shots };
  }

// Phase 0: ShotMarker import diagnostics (better errors)
function diagnoseShotMarker(text){
  const raw = String(text||'');
  const lines = raw.split(/\r?\n/).map(stripBOM);
  const nonEmptyIdx = [];
  for(let i=0;i<lines.length;i++){
    if(lines[i] && lines[i].trim()) nonEmptyIdx.push(i);
    if(nonEmptyIdx.length>=12) break;
  }
  const samples = nonEmptyIdx.map(i=>({i, line: lines[i]}));
  const required = [
    {k:'time', label:'Time'},
    {k:'x', label:'X (mm)'},
    {k:'y', label:'Y (mm)'},
    {k:'vel', label:'Vel (fps)'}
  ];

  let best = {score:-1, i:-1, cols:[], missing:required.map(r=>r.label)};
  const scanMax = Math.min(lines.length, 120);
  for(let i=0;i<scanMax;i++){
    const ln = lines[i];
    if(!ln || !ln.trim()) continue;
    const row = splitCSV(ln).map(x=>String(x||'').replace(/^"|"$/g,'').trim());
    const low = row.map(c=>c.toLowerCase());
    let score = 0;
    const missing = [];
    for(const r of required){
      if(r.k==='time'){
        if(low.some(c=>c==='time' || c.includes('time'))) score++; else missing.push(r.label);
      }else if(r.k==='x'){
        if(low.some(c=>c==='x' || (c.includes('x') && c.includes('mm')))) score++; else missing.push(r.label);
      }else if(r.k==='y'){
        if(low.some(c=>c==='y' || (c.includes('y') && c.includes('mm')))) score++; else missing.push(r.label);
      }else if(r.k==='vel'){
        if(low.some(c=>c.includes('vel') || (c.includes('v') && c.includes('fps')) || c.includes('speed'))) score++; else missing.push(r.label);
      }
    }
    if(score > best.score){
      best = {score, i, cols: row.slice(0,24), missing};
      if(score===required.length) break;
    }
  }

  return {samples, best};
}

  // Robust CSV splitter for this simple case (handles quoted commas).
  function splitCSV(line){
    const out = [];
    let cur = '';
    let q = false;
    for(let i=0;i<line.length;i++){
      const ch = line[i];
      if(ch === '"'){
        if(q && line[i+1] === '"'){ cur += '"'; i++; }
        else q = !q;
      } else if(ch === ',' && !q){
        out.push(cur); cur='';
      } else {
        cur += ch;
      }
    }
    out.push(cur);
    return out;
  }

  // ---------- Kestrel parser ----------
  function parseKestrel(text){
    const lines = text.split(/\r?\n/).filter(l=>l.trim().length>0);
    // Find header row containing FORMATTED DATE_TIME
    let header = null, start = -1;
    for(let i=0;i<Math.min(lines.length, 50);i++){
      const row = splitCSV(lines[i]);
      if(row[0] && row[0].replace(/"/g,'') === 'FORMATTED DATE_TIME'){
        header = row.map(x=>x.replace(/^"|"$/g,'').trim());
        start = i+2; // skip units row too
        break;
      }
    }
    if(!header) return { samples:[], range:null, error:'Could not find Kestrel header (FORMATTED DATE_TIME).' };

    const col = (name)=> header.indexOf(name);
    const idxTime = col('FORMATTED DATE_TIME');
    const idxTemp = col('Temperature');
    const idxRH   = col('Relative Humidity');
    const idxDA   = col('Density Altitude');
    const idxXW   = col('Crosswind');
    const idxHW   = col('Headwind');
    const idxWS   = col('Wind Speed');
    const idxTrue = col('Compass True Direction');
    const idxSP   = col('Station Pressure');

    const samples = [];
    let minEpoch = Infinity, maxEpoch = -Infinity;
    let minStr = '', maxStr = '';
    for(let i=start;i<lines.length;i++){
      const row = splitCSV(lines[i]).map(x=>x.replace(/^"|"$/g,''));
      if(!row[idxTime] || !/^\d{4}-\d{2}-\d{2}/.test(row[idxTime])) continue;
      const dt = parseKestrelDate(row[idxTime]);
      if(!dt) continue;
      const tEpoch = dt.getTime()/1000;
      const formatted = row[idxTime];
      const s = {
        tEpoch,
        formatted,
        crosswind: safeNum(row[idxXW]),
        headwind: safeNum(row[idxHW]),
        windSpeed: safeNum(row[idxWS]),
        trueDir: safeNum(row[idxTrue]),
        temp: safeNum(row[idxTemp]),
        rh: safeNum(row[idxRH]),
        stationP: safeNum(row[idxSP]),
        da: safeNum(row[idxDA])
      };
      samples.push(s);
      if(tEpoch < minEpoch){ minEpoch=tEpoch; minStr=formatted; }
      if(tEpoch > maxEpoch){ maxEpoch=tEpoch; maxStr=formatted; }
    }
    samples.sort((a,b)=>a.tEpoch-b.tEpoch);
    const range = (samples.length? {minEpoch,maxEpoch,minStr,maxStr}: null);
    return { samples, range, header };
  }

  function safeNum(v){
    const n = parseFloat(String(v||'').trim());
    return Number.isFinite(n) ? n : null;
  }

  function parseKestrelDate(s){
    // "2025-12-27 07:01:05 PM" -> local Date
    const m = String(s||'').trim().match(/^(\d{4})-(\d{2})-(\d{2})\s+(\d{2}):(\d{2}):(\d{2})\s+(AM|PM)$/);
    if(!m) return null;
    let Y=+m[1], M=+m[2], D=+m[3], hh=+m[4], mm=+m[5], ss=+m[6];
    const ap = m[7];
    if(ap==='PM' && hh!==12) hh+=12;
    if(ap==='AM' && hh===12) hh=0;
    return new Date(Y, M-1, D, hh, mm, ss, 0);
  }

  function nearestSample(epoch){
    // binary search in kSamples
    if(!kSamples.length) return {s:null, dt:Infinity};
    let lo=0, hi=kSamples.length-1;
    while(lo<hi){
      const mid = Math.floor((lo+hi)/2);
      if(kSamples[mid].tEpoch < epoch) lo = mid+1;
      else hi = mid;
    }
    let best = kSamples[lo];
    let bestDt = Math.abs(best.tEpoch - epoch);
    if(lo>0){
      const prev = kSamples[lo-1];
      const dt = Math.abs(prev.tEpoch - epoch);
      if(dt < bestDt){ best=prev; bestDt=dt; }
    }
    return {s:best, dt:bestDt};
  }

  function computeShotEpoch(idx){
    const aShot = clampInt(el('aShot').value, 1, smShots.length||1);
    const bShot = clampInt(el('bShot').value, 1, smShots.length||1);
    const aSec = parseHMS(el('aTime').value);
    const bSec = parseHMS(el('bTime').value);
    const dateISO = el('sessionDate').value;
    if(!dateISO || aSec===null || bSec===null || !Number.isFinite(aShot) || !Number.isFinite(bShot) || aShot===bShot) return null;

    const absA = epochFromLocal(dateISO, aSec);
    const absB = epochFromLocal(dateISO, bSec);
    const t = (idx - aShot) / (bShot - aShot);
    return absA + t * (absB - absA);
  }

  function clampInt(v, lo, hi){
    const n = Math.trunc(Number(v));
    if(!Number.isFinite(n)) return lo;
    return Math.max(lo, Math.min(hi, n));
  }

  function clearKestrel(){
    for(const sh of smShots){
      sh.k = null;
      sh.kdt = null;
      sh.j = null;
    }
    renderTable();
    kStatus.innerHTML = `<span class="good">Cleared Kestrel fields.</span>`;
  }

  function applyKestrel(){
    if(!smShots.length){
      kStatus.innerHTML = `<span class="bad">Load ShotMarker first.</span>`;
      return;
    }
    if(!kSamples.length){
      kStatus.innerHTML = `<span class="bad">Load Kestrel CSV first.</span>`;
      return;
    }
    const tol = Number(el('tolSel').value)||10;
    let joined=0, missed=0, badmap=0, outwin=0;

    // date mismatch warning
    const smDate = smFirstDate ? dateToISO(smFirstDate) : null;
    const sessISO = el('sessionDate').value || '';
    const dateMismatch = (smDate && sessISO && smDate !== sessISO);

    // compute predicted range for shots
    const t1 = computeShotEpoch(1);
    const tN = computeShotEpoch(smShots.length);
    let rangeLine = '';
    if(t1 && tN){
      rangeLine = `Predicted shots range: ${new Date(t1*1000).toLocaleString()} \u2192 ${new Date(tN*1000).toLocaleString()}`;
    }

    for(const sh of smShots){
      const epoch = computeShotEpoch(sh.idx);
      const {s, dt} = nearestSample(epoch);

      if(epoch===null){
        sh.k = null; sh.kdt = null; sh.j = 'BADMAP';
        badmap++; continue;
      }

      if(kRange && (epoch < (kRange.minEpoch - tol) || epoch > (kRange.maxEpoch + tol))){
        sh.k = null; sh.kdt = null; sh.j = 'OUT';
        outwin++; continue;
      }

      if(s && dt <= tol){
        sh.k = s; sh.kdt = dt; sh.j = 'JOIN';
        joined++;
      } else {
        sh.k = null; sh.kdt = dt; sh.j = 'MISS';
        missed++;
      }
    }
    renderTable();

    const lines = [];
    lines.push(`<span class="good">Applied Kestrel to shots.</span>`);
    lines.push(`<span class="good">Joined:</span> ${joined}`);
    lines.push(`<span class="warn">Missed (out of tolerance):</span> ${missed}`);
    lines.push(`<span class="warn">Out of window:</span> ${outwin}`);
    lines.push(`<span class="warn">Bad time mapping:</span> ${badmap}`);
    if(rangeLine) lines.push(`<span class="hint">${esc(rangeLine)}</span>`);
    if(kRange) lines.push(`<span class="hint">Kestrel range: ${esc(kRange.minStr)} \u2192 ${esc(kRange.maxStr)}</span>`);
    if(dateMismatch){
      lines.push(`<span class="warn">⚠ Date mismatch: ShotMarker ${esc(smDate)} vs session date ${esc(sessISO)} (this is OK for demo, but real joins need same day/session).</span>`);
    }
    // anchor window warning
    const aSec = parseHMS(el('aTime').value), bSec = parseHMS(el('bTime').value);
    if(kRange && sessISO && aSec!==null && bSec!==null){
      const aE = epochFromLocal(sessISO, aSec);
      const bE = epochFromLocal(sessISO, bSec);
      const minA = Math.min(aE,bE), maxA=Math.max(aE,bE);
      if(maxA < kRange.minEpoch || minA > kRange.maxEpoch){
        lines.push(`<span class="bad">⚠ Anchors do not overlap the Kestrel time window. Either change anchor times or use Auto-fit for demo.</span>`);
      }
    }

    kStatus.innerHTML = lines.join("\n");
  }

  function autoFitAnchors(){
    if(!smShots.length || !kRange){
      kStatus.innerHTML = `<span class="bad">Load ShotMarker + Kestrel first.</span>`;
      return;
    }
    const dateISO = el('sessionDate').value;
    if(!dateISO){
      kStatus.innerHTML = `<span class="bad">Set session date first.</span>`;
      return;
    }
    const min = new Date(kRange.minEpoch*1000);
    const max = new Date(kRange.maxEpoch*1000);
    // set anchors to 60s inside range
    const a = new Date(min.getTime() + 60*1000);
    const b = new Date(max.getTime() - 60*1000);
    const fmt = (d)=> String(d.getHours()).padStart(2,'0')+':'+String(d.getMinutes()).padStart(2,'0')+':'+String(d.getSeconds()).padStart(2,'0');
    el('aShot').value = 1;
    el('bShot').value = smShots.length;
    el('aTime').value = fmt(a);
    el('bTime').value = fmt(b);
    kStatus.innerHTML = `<span class="good">Auto-fit anchors set.</span> Now click <b>Apply</b> to validate join plumbing.`;
  }

  function setDateFromSM(){
    if(!smFirstDate){
      kStatus.innerHTML = `<span class="bad">Load ShotMarker first.</span>`;
      return;
    }
    el('sessionDate').value = dateToISO(smFirstDate);
    kStatus.innerHTML = `<span class="good">Session date set from ShotMarker: ${esc(dateToISO(smFirstDate))}</span>`;
  }

  
  // ---------- Garmin chrono parser ----------
  function parseGarmin(text){
    const lines = text.split(/\r?\n/).filter(l=>String(l).trim().length>0);
    let header = null;
    let start = 0;
    for(let i=0;i<Math.min(lines.length, 60);i++){
      const row = splitCSV(lines[i]).map(x=>String(x||'').replace(/^\ufeff+/,'').trim());
      if(row.length>=2 && row[0]==='#' && row.join(',').toLowerCase().includes('speed')){
        header = row;
        start = i+1;
        break;
      }
    }
    if(!header) return {shots:[], error:'Could not find Garmin header row (expected a column named Speed (FPS)).'};

    const idxIdx = 0;
    const idxSpeed = header.findIndex(h=>String(h).toLowerCase().includes('speed') && String(h).toLowerCase().includes('fps'));
    const idxTime = header.findIndex(h=>String(h).toLowerCase()==='time');

    const shots=[];
    for(let i=start;i<lines.length;i++){
      const row = splitCSV(lines[i]);
      if(!row.length) continue;
      const idx = parseInt(String(row[idxIdx]||'').trim(),10);
      if(!Number.isFinite(idx)) continue;
      const vel = safeNum(row[idxSpeed]);
      const timeSec = (idxTime>=0 ? parseHMS(row[idxTime]) : null);
      shots.push({idx, vel, timeSec});
    }
    shots.sort((a,b)=>a.idx-b.idx);
    return {shots, error:null};
  }

  // ---------- AMP CSV (seating force) ----------
  // AMP exports are "metrics as rows, traces as columns" (Trace 1..N).
  function parseAMP(text){
    const lines = text.split(/\r?\n/).filter(l=>l!=null && l.trim().length);
    if(!lines.length) return { traces:[], error:'Empty AMP file' };

    const header = splitCSV(lines[0]);
    // Expect first col = metric name, then Trace 1..N
    const traceCols = header.slice(1).map(h=>String(h||'').trim());
    const traceNums = traceCols.map(h=>{
      const m = /\b(\d+)\b/.exec(h);
      return m ? parseInt(m[1],10) : null;
    });

    const want = new Set(['Peak Force','Work Done','Starting Pos','Terminal Force']);
    const rowsByMetric = {};
    for(let i=1;i<lines.length;i++){
      const parts = splitCSV(lines[i]);
      if(!parts.length) continue;
      const metric = String(parts[0]||'').trim();
      if(!want.has(metric)) continue;
      rowsByMetric[metric] = parts.slice(1).map(v=>{
        const n = parseFloat(String(v||'').trim());
        return Number.isFinite(n) ? n : null;
      });
    }

    // Build traces
    const traces = [];
    for(let j=0;j<traceNums.length;j++){
      const n = traceNums[j];
      if(!n) continue;
      const t = {
        trace: n,
        peak: rowsByMetric['Peak Force'] ? rowsByMetric['Peak Force'][j] : null,
        work: rowsByMetric['Work Done'] ? rowsByMetric['Work Done'][j] : null,
        startPos: rowsByMetric['Starting Pos'] ? rowsByMetric['Starting Pos'][j] : null,
        term: rowsByMetric['Terminal Force'] ? rowsByMetric['Terminal Force'][j] : null
      };
      // keep if any value exists
      if(t.peak!=null || t.work!=null || t.startPos!=null || t.term!=null) traces.push(t);
    }

    // Stats + z-scores (mean/std)
    function meanStd(arr){
      const xs = arr.filter(v=>v!=null && Number.isFinite(v));
      if(xs.length<2) return {mean:null,std:null};
      const mean = xs.reduce((a,b)=>a+b,0)/xs.length;
      const varr = xs.reduce((a,b)=>a+(b-mean)*(b-mean),0)/xs.length;
      const std = Math.sqrt(varr);
      return {mean,std};
    }
    const ps = meanStd(traces.map(t=>t.peak));
    const ws = meanStd(traces.map(t=>t.work));
    const ss = meanStd(traces.map(t=>t.startPos));

    for(const t of traces){
      t.zPeak = (ps.mean!=null && ps.std>0 && t.peak!=null) ? ((t.peak-ps.mean)/ps.std) : null;
      t.zWork = (ws.mean!=null && ws.std>0 && t.work!=null) ? ((t.work-ws.mean)/ws.std) : null;
      t.zStart = (ss.mean!=null && ss.std>0 && t.startPos!=null) ? ((t.startPos-ss.mean)/ss.std) : null;
      // a single "anomaly score" = max abs z among metrics
      let m = 0;
      for(const z of [t.zPeak, t.zWork, t.zStart]){
        if(z!=null && Number.isFinite(z)) m = Math.max(m, Math.abs(z));
      }
      t.ampZ = (m>0) ? m : null;
    }

    return { traces, stats:{peak:ps, work:ws, startPos:ss}, error:null };
  }

  function applyAMPToShots(){
    // Map AMP trace 1..N onto shot idx 1..N (file order). If your session is 66 rounds,
    // Trace 1 maps to Shot #1, etc.
    if(!ampSession || !ampSession.map) return;
    for(const sh of smShots){
      const tr = ampSession.map.get(sh.idx);
      if(tr){
        sh.ampPeak = tr.peak;
        sh.ampWork = tr.work;
        sh.ampStartPos = tr.startPos;
        sh.ampZ = tr.ampZ;
        sh.ampZPeak = tr.zPeak;
        sh.ampZWork = tr.zWork;
        sh.ampZStart = tr.zStart;
      } else {
        sh.ampPeak = null;
        sh.ampWork = null;
        sh.ampStartPos = null;
        sh.ampZ = null;
      }
    }
  }

  async function importAMPCSV(file){
    const text = await file.text();
    const parsed = parseAMP(text);
    if(parsed.error){
      ampSession = null;
      toast('AMP: ' + parsed.error);
      return;
    }
    const map = new Map();
    for(const t of parsed.traces) map.set(t.trace, t);
    ampSession = { name: file.name, map, stats: parsed.stats, n: parsed.traces.length };
    applyAMPToShots();
    // refresh import pills so AMP shows as a pill like the other sources
    try{
      setPills((smShots && smShots.length ? 'ShotMarker loaded' : null),
               (kSamples && kSamples.length ? (kMeta && kMeta.textContent ? kMeta.textContent : 'Kestrel loaded') : null),
               (gFiles && gFiles.length ? gFiles.map(g=>({name:g.name,count:(g.shots?g.shots.length:0)})) : null));
    }catch(_e){}

    render();
  }

  function fmtAmp(n){
    return (n!=null && Number.isFinite(n)) ? n.toFixed(2) : '';
  }


  function ampValCell(label, val, z){
    if(val==null || !Number.isFinite(val)) return '';
    const zs = (z!=null && Number.isFinite(z)) ? (z>=0?'+':'')+z.toFixed(2)+'σ' : '—';
    const tip = `AMP ${label}: ${val.toFixed(2)} (z=${zs})`;
    return `<span title="${escA(tip)}">${val.toFixed(2)}</span>`;
  }




  function buildGarminMap(){
    const map = new Map(); // key: SM shot idx -> {vel,file,fileIdx}
    for(const gf of gFiles){
      const base = (gf && Number.isFinite(gf.startIdx) && gf.startIdx>0) ? Math.trunc(gf.startIdx) : 1;
      const shots = gf.shots || [];
      for(const s of shots){
        const fileIdx = (s && Number.isFinite(s.idx)) ? Math.trunc(s.idx) : null;
        if(fileIdx==null) continue;
        const smIdx = base + (fileIdx - 1);
        if(!Number.isFinite(smIdx) || smIdx<=0) continue;
        map.set(smIdx, {vel: s.vel, file: gf.name, fileIdx});
      }
    }
    return map;
  }

  function applyGarminToShots(){
    // Apply Garmin velocities by block pairing (one chrono file per ShotMarker target).
    // This avoids needing global "start shot #" alignment when your workflow is 1:1 targets↔chrono.
    let matched = 0, overrides = 0;

    // Preserve SM velocities as baseline
    for(const sh of smShots){
      const smv = parseFloat(String(sh.vel||'').trim());
      const smVelNum = Number.isFinite(smv) ? smv : null;
      sh.velSM = smVelNum;
      sh.vel = smVelNum;
      // active velocity selection: default to ShotMarker until Garmin provides a value
      sh.velActive = smVelNum;
      sh.velSrc = 'SM';

      // coverage / provenance
      sh.gInfo = null;
      sh.gMapped = false;
    }

    if(!smShots.length || !gFiles.length) return {matched:0, overrides:0, unmapped: smShots.length, extra:0};

    // Auto pair by order when files count matches block count and no manual pairing exists.
    autoPairChronoByOrder();

    const gByName = new Map(gFiles.map(g=>[g.name, g]));
    const groups = groupByBlock();

    // Determine block order (prefer ShotMarker-declared order)
    const blockOrder = (smBlocks && smBlocks.length) ? smBlocks.map(b=>b.label) : Array.from(groups.keys());

    for(const blk of blockOrder){
      const list = (groups.get(blk) || []).slice().sort((a,b)=>a.idx-b.idx);
      if(!list.length) continue;

      const pair = chronoPair.get(blk) || {};
      const gf = pair.name ? gByName.get(pair.name) : null;
      if(!gf || !gf.shots || !gf.shots.length) continue;

      const start = (pair.start && Number.isFinite(+pair.start) && +pair.start>0) ? Math.trunc(+pair.start) : 1;
      const base = start - 1;

      for(let i=0;i<list.length;i++){
        const sh = list[i];
        const gs = gf.shots[base + i];
        const gvel = gs && Number.isFinite(gs.vel) ? gs.vel : null;

        if(gvel!=null && gvel>0){
          sh.gInfo = {vel:gvel, file: gf.name, fileIdx: gs.idx};
          sh.gMapped = true;
          matched++;
          if(sh.velSM==null || Math.abs((sh.velSM||0) - gvel) > 0.0001) overrides++;
          sh.vel = gvel;
          sh.velActive = gvel;
          sh.velSrc = 'Garmin';
        }
      }
    }

    const unmapped = Math.max(0, smShots.length - matched);
    return {matched, overrides, unmapped, extra:0};
  }


  // Phase 3 Step 2: block rollups + optional filter
  let activeBlock = null; // null = all
let collapsedBlocks = new Set(); // block label strings collapsed in All view

  function groupByBlock(){
    const map = new Map();
    for(const sh of smShots){
      const key = sh.block || '(unknown)';
      if(!map.has(key)) map.set(key, []);
      map.get(key).push(sh);
    }
    return map;
  }

  function countStates(list){
    let rec=0, sgt=0, exc=0;
    for(const sh of list){
      const st = sh.state || 'RECORD';
      if(st==='EXCLUDE') exc++;
      else if(st==='SIGHTER') sgt++;
      else rec++;
    }
    return {rec, sgt, exc, total:list.length};
  }


  function computeVelStats(list){
    // RECORD shots only; velocities must be finite > 0
    const vals = [];
    for(const sh of list){
      if((sh.state||'RECORD')!=='RECORD') continue;
      const v = (sh.velActive!=null && Number.isFinite(sh.velActive) && sh.velActive>0) ? sh.velActive : null;
      if(v!=null) vals.push(v);
    }
    const n = vals.length;
    if(!n) return {n:0, mean:null, sd:null, es:null, min:null, max:null};
    let sum = 0;
    let mn = Infinity, mx = -Infinity;
    for(const v of vals){ sum += v; if(v<mn) mn=v; if(v>mx) mx=v; }
    const mean = sum / n;
    let sd = null;
    if(n >= 3){
      let ss = 0;
      for(const v of vals){ const d = v-mean; ss += d*d; }
      sd = Math.sqrt(ss / (n-1)); // sample SD
    }
    const es = (n >= 2) ? (mx - mn) : null;
    return {n, mean, sd, es, min: mn, max: mx};
  }

  // ---------- Phase 5.3: wind variability + "wind explains horizontal" ----------
  function computeWindStats(list){
    // RECORD shots only; requires joined Kestrel crosswind
    const w = [];
    const pairs = []; // {x: crosswind, y: hMoa}
    let rec = 0;
    for(const sh of list){
      if((sh.state||'RECORD')!=='RECORD') continue;
      rec++;
      const cw = (sh.k && sh.j==='JOIN' && sh.k.crosswind!=null && Number.isFinite(sh.k.crosswind)) ? sh.k.crosswind : null;
      if(cw==null) continue;
      w.push(cw);
      const hm = (sh.hMoa!=null && Number.isFinite(sh.hMoa)) ? sh.hMoa : null;
      if(hm!=null) pairs.push({x:cw, y:hm});
    }
    const n = w.length;
    if(!n) return {rec, n:0, mean:null, sd:null, min:null, max:null, bracket:null, pairsN:pairs.length, r:null};
    let sum=0, mn=Infinity, mx=-Infinity;
    for(const v of w){ sum+=v; if(v<mn) mn=v; if(v>mx) mx=v; }
    const mean = sum/n;
    let sd=null;
    if(n>=3){
      let ss=0;
      for(const v of w){ const d=v-mean; ss += d*d; }
      sd = Math.sqrt(ss/(n-1)); // sample SD
    }
    const bracket = (n>=2) ? (mx-mn) : null;
    const r = (pairs.length>=10) ? pearson(pairs.map(p=>p.x), pairs.map(p=>p.y)) : null;
    return {rec, n, mean, sd, min:mn, max:mx, bracket, pairsN:pairs.length, r};
  }

  function pearson(xs, ys){
    const n = Math.min(xs.length, ys.length);
    if(n<3) return null;
    let sx=0, sy=0;
    for(let i=0;i<n;i++){ sx+=xs[i]; sy+=ys[i]; }
    const mx=sx/n, my=sy/n;
    let sxx=0, syy=0, sxy=0;
    for(let i=0;i<n;i++){
      const dx = xs[i]-mx, dy=ys[i]-my;
      sxx += dx*dx; syy += dy*dy; sxy += dx*dy;
    }
    if(sxx<=0 || syy<=0) return null;
    return sxy / Math.sqrt(sxx*syy);
  }

  function windInstabilityLabel(ws){
    if(!ws || ws.n===0) return null;
    const sd = ws.sd;
    const br = ws.bracket;
    const sdOk = (sd!=null ? sd : 999);
    const brOk = (br!=null ? br : 999);
    if(sdOk<=1.0 && brOk<=3.0) return {lvl:'OK', icon:'✅', title:'Wind stable (SD≤1mph and bracket≤3mph)'};
    if(sdOk<=2.0 && brOk<=6.0) return {lvl:'VAR', icon:'⚠', title:'Wind variable (SD 1–2mph or bracket 3–6mph)'};
    return {lvl:'WILD', icon:'🚨', title:'Wind wild (SD>2mph or bracket>6mph)'};
  }

  function windExplainLabel(r){
    if(r==null || !Number.isFinite(r)) return null;
    const a = Math.abs(r);
    if(a < 0.25) return {txt:'Low', title:`Weak wind→horizontal relationship (r=${r.toFixed(2)})`};
    if(a < 0.50) return {txt:'Med', title:`Moderate wind→horizontal relationship (r=${r.toFixed(2)})`};
    return {txt:'High', title:`Strong wind→horizontal relationship (r=${r.toFixed(2)})`};
  }

  // ---------- Phase 4: block stats + per-shot flags ----------
  function recomputeBlockStats(){
    blockStats = new Map();
    const groups = groupByBlock();
    for(const [block, list] of groups.entries()){
      blockStats.set(block, computeVelStats(list));
    }
  }

  
  function fmtIn(v){
    return (v!=null && Number.isFinite(v)) ? v.toFixed(3) : '';
  }
  function fmtMoa(v){
    return (v!=null && Number.isFinite(v)) ? v.toFixed(2) : '';
  }
  function moaFromIn(inches, distYd){
    if(!(inches!=null && Number.isFinite(inches)) || !(distYd!=null && Number.isFinite(distYd)) || distYd<=0) return null;
    return inches / (1.047 * (distYd/100));
  }

  function distForBlock(block){
    // precedence: user override -> ShotMarker auto -> default
    const v = blockDist.get(block);
    const n = Number(v);
    if(Number.isFinite(n) && n>0) return n;
    const a = blockAutoDist.get(block);
    const an = Number(a);
    if(Number.isFinite(an) && an>0) return an;
    return defaultDistYd;
  }

  function computeGeoStatsForBlock(block, list){
    const distYd = distForBlock(block);
    // RECORD shots only with coords
    const pts = [];
    for(const sh of list){
      if((sh.state||'RECORD')!=='RECORD') continue;
      if(sh.xIn==null || sh.yIn==null) continue;
      pts.push({x: sh.xIn, y: sh.yIn, sh});
    }
    const n = pts.length;
    // Clear per-shot MOA for this block first (so toggles reflow correctly)
    for(const sh of list){
      sh.hMoa=null; sh.vMoa=null; sh.rMoa=null;
    }
    if(n===0) return {distYd, n:0, horizESmoa:null, vertESmoa:null, radialESmoa:null, mrMoa:null};

    // centroid for MR + per-shot offsets
    let sx=0, sy=0;
    for(const p of pts){ sx+=p.x; sy+=p.y; }
    const cx = sx/n, cy = sy/n;

    // per-shot
    for(const p of pts){
      const dx = p.x - cx;
      const dy = p.y - cy;
      const r = Math.hypot(dx,dy);
      p.sh.hMoa = moaFromIn(Math.abs(dx), distYd);
      p.sh.vMoa = moaFromIn(Math.abs(dy), distYd);
      p.sh.rMoa = moaFromIn(r, distYd);
    }

    // axis ES using raw coords (centroid shift doesn't change spread)
    let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
    for(const p of pts){
      if(p.x<minX) minX=p.x; if(p.x>maxX) maxX=p.x;
      if(p.y<minY) minY=p.y; if(p.y>maxY) maxY=p.y;
    }
    const horizESin = (maxX-minX);
    const vertESin = (maxY-minY);

    // radial ES = max pairwise distance (O(n^2) but n<=~60)
    let maxD = 0;
    for(let i=0;i<n;i++){
      for(let j=i+1;j<n;j++){
        const dx = pts[i].x-pts[j].x;
        const dy = pts[i].y-pts[j].y;
        const d = Math.hypot(dx,dy);
        if(d>maxD) maxD=d;
      }
    }

    // mean radius about centroid
    let mrSum=0;
    for(const p of pts){
      const dx=p.x-cx, dy=p.y-cy;
      mrSum += Math.hypot(dx,dy);
    }
    const mrIn = mrSum/n;

    return {
      distYd, n,
      horizESmoa: moaFromIn(horizESin, distYd),
      vertESmoa: moaFromIn(vertESin, distYd),
      radialESmoa: moaFromIn(maxD, distYd),
      mrMoa: moaFromIn(mrIn, distYd)
    };
  }

  function recomputeGeoStats(){
    geoStats = new Map();
    const groups = groupByBlock();
    for(const [block, list] of groups.entries()){
      geoStats.set(block, computeGeoStatsForBlock(block, list));
    }
  }

function velFlagForShot(sh){
    const st = (sh.state||'RECORD');
    if(st !== 'RECORD') return {level:'off', text:'', why:'Non-record shot'};
    const v = (sh.velActive!=null && Number.isFinite(sh.velActive) && sh.velActive>0) ? sh.velActive : null;
    if(v==null) return {level:'off', text:'', why:'Missing velocity'};

    const vs = blockStats.get(sh.block) || computeVelStats(smShots.filter(s=>s.block===sh.block));
    const sd = (vs && Number.isFinite(vs.sd) && vs.sd>0) ? vs.sd : null;
    if(sd==null) return {level:'off', text:'', why:'Need ≥3 record velocities in block (to compute SD)'};

    const z = (v - vs.mean) / sd;
    const az = Math.abs(z);

    // thresholds (match tooltip + AMP): <=0.7 OK; 0.7–1.3 Warn; 1.3–1.9 Problem; >1.9 Red
    let level='ok';
    if(az > 1.9) level='bad';
    else if(az > 1.3) level='problem';
    else if(az > 0.7) level='warn';

    const text = `${az.toFixed(1)}σ`;
    return {level, text, z, az};
  }

  function flagCell(sh){
    const f = velFlagForShot(sh);
    if(!f.text) return `<span class="flagchip off" title="${esc(f.why || 'No Δσ available.')}">—</span>`;
    const desc = (f.az<=0.1) ? 'basically on the node'
      : (f.az<=0.7) ? 'normal noise'
      : (f.az<=1.3) ? 'eyebrow raise'
      : 'real outlier (candidate for exclusion)';
    const title =
`Δ${f.text} — ${desc}

Δ0.1σ = basically on the node

Δ0.7σ = normal noise

Δ1.3σ = eyebrow raise

Δ1.9σ = real outlier (candidate for exclusion)

Click to toggle EXCLUDE.`;
    return `<span class="flagchip ${esc(f.level)}" title="${esc(title)}" data-flag-shot="${sh.idx}">${esc(f.text)}</span>`;
  }

  function setShotStateByIdx(shotIdx, newState, pushUndo=true, src='MANUAL'){
    const sh = smShots.find(s=>s.idx===shotIdx);
    if(!sh) return;
    const prev = sh.state || 'RECORD';
    const prevSrc = sh.stateSrc || '';
    if(prev === newState && prevSrc === (src||'')) return;

    if(pushUndo) undo = {type:'shot', shotIdx, prevState: prev, prevSrc};

    sh.state = newState;

    // Track why this shot is in its current state (helps explain "exclude by flag" vs manual, etc.)
    // src values: 'FLAG', 'MANUAL', 'TAG', '' (default)
    if(newState === 'EXCLUDE'){
      sh.stateSrc = (src||'MANUAL');
    } else if(newState === 'SIGHTER'){
      sh.stateSrc = (src||'MANUAL');
    } else {
      sh.stateSrc = '';

    // Phase 1: change awareness (manual edits only)
    // Phase 4: during Preview, we defer dirty marking until Apply.
    if(!previewActive && (src||'')==='MANUAL'){
      dirtyShotIdxs.add(sh.idx);
      if(sh.block) dirtyBlocks.add(sh.block);
    }

    }

    if(bulkStateMode) return;

    const p4 = el('importStatus');
    if(p4){
      const srcTxt = (newState==='EXCLUDE' ? (sh.stateSrc||'') : '');
      p4.innerHTML = `<span class="hint">Stats updated after state change.</span>`;
    }

    recomputeBlockStats();
    recomputeGeoStats();
    renderBlockRollups();
    renderTable();
  }

  function undoLast(){
    if(!undo) return;

    // Phase 5.4.5: undo supports either shot state changes or Garmin mapping edits.
    if(undo.type === 'garminMap'){
      const prevStarts = Array.isArray(undo.prevStarts) ? undo.prevStarts : [];
      for(let i=0;i<gFiles.length;i++){
        if(prevStarts[i]!=null) gFiles[i].startIdx = prevStarts[i];
      }
      undo = null;
      const res = smShots.length ? applyGarminToShots() : {matched:0, overrides:0, unmapped:0, extra:0};

    // If per-target pairings exist, apply them now
    applyChronoPairings();
      recomputeBlockStats();
      renderBlockRollups();
      renderTable();
      renderGarminMapping();
      el('importStatus').innerHTML = `<span class="good">Undid Garmin mapping change.</span> <span class="hint">Matched: ${res.matched} • Unmapped: ${res.unmapped}</span>`;
      return;
    }

    // Bulk shot state undo
    if(undo.type === 'multiShot'){
      const items = Array.isArray(undo.items) ? undo.items : [];
      undo = null;
      for(const it of items){
        if(!it) continue;
        setShotStateByIdx(it.shotIdx, it.prevState, false, it.prevSrc||'');
      }
      el('importStatus').innerHTML = `<span class="good">Undid bulk change.</span>`;
      return;
    }

    // Default: undo a shot state change
    const {shotIdx, prevState, prevSrc} = undo;
    undo = null;
    setShotStateByIdx(shotIdx, prevState, false, prevSrc||'');
    el('importStatus').innerHTML = `<span class="good">Undid last change.</span>`;
  }

  

  // ---------- Phase 4: Preview mode (what-if) ----------
  function beginPreview(){
    if(previewActive || !smShots.length) return;
    previewActive = true;
    previewSnapshot = new Map(smShots.map(sh=>[sh.idx, {state:(sh.state||'RECORD'), stateSrc:(sh.stateSrc||'')}]));
    const bar = el('previewBar');
    if(bar) bar.classList.remove('hidden');
    const btn = el('btnPreview');
    if(btn){ btn.classList.add('active'); btn.textContent = 'Preview ✓'; }
    renderBlockRollups();
    renderTable();
  }

  function cancelPreview(){
    if(!previewActive || !previewSnapshot) return;
    // restore all shot states
    for(const sh of smShots){
      const prev = previewSnapshot.get(sh.idx);
      if(prev){ sh.state = prev.state; sh.stateSrc = prev.stateSrc; }
    }
    previewActive = false;
    previewSnapshot = null;
    const bar = el('previewBar');
    if(bar) bar.classList.add('hidden');
    const btn = el('btnPreview');
    if(btn){ btn.classList.remove('active'); btn.textContent = 'Preview'; }
    recomputeBlockStats();
    recomputeGeoStats();
    renderBlockRollups();
    renderTable();
  }

  function applyPreview(){
    if(!previewActive || !previewSnapshot) return;
    // mark dirty for changes made during preview
    for(const sh of smShots){
      const prev = previewSnapshot.get(sh.idx);
      if(!prev) continue;
      const curState = (sh.state||'RECORD');
      const curSrc = (sh.stateSrc||'');
      if(prev.state !== curState || prev.stateSrc !== curSrc){
        dirtyShotIdxs.add(sh.idx);
        if(sh.block) dirtyBlocks.add(sh.block);
      }
    }
    previewActive = false;
    previewSnapshot = null;
    const bar = el('previewBar');
    if(bar) bar.classList.add('hidden');
    const btn = el('btnPreview');
    if(btn){ btn.classList.remove('active'); btn.textContent = 'Preview'; }
    renderBlockRollups();
    renderTable();
  }
function resetStatesInActiveBlock(){
    if(!activeBlock){
      el('importStatus').innerHTML = `<span class="warn">Pick a block first (click it in the rollups).</span>`;
      return;
    }
    const list = smShots.filter(s=>s.block===activeBlock);
    let changed = 0;
    for(const sh of list){
      const inferred = (String(sh.tag||'').toLowerCase().includes('sight') ? 'SIGHTER' : 'RECORD');
      if((sh.state||'RECORD') !== inferred){
        sh.state = inferred;
        sh.stateSrc = (inferred==='SIGHTER') ? 'TAG' : '';
        changed++;
      }
    }
    undo = null;
    recomputeBlockStats();
    recomputeGeoStats();
    renderBlockRollups();
    renderTable();
    el('importStatus').innerHTML = `<span class="good">Reset ${changed} shot(s) in block.</span>`;
  }

  function renderGarminMapping(){
    const body = el('garminMapBody');
    if(!body) return;
    if(!gFiles.length){
      body.innerHTML = `<tr><td colspan="3" style="color:rgba(230,238,248,.6); padding:10px;">No Garmin files loaded.</td></tr>`;
      return;
    }
    body.innerHTML = gFiles.map((g,i)=>{
      const n = (g.shots && g.shots.length) ? g.shots.length : 0;
      const start = (g.startIdx!=null ? g.startIdx : 1);
      return `<tr>
        <td style="max-width:240px; overflow:hidden; text-overflow:ellipsis;">${esc(g.name)}</td>
        <td>${n}</td>
        <td><input type="number" min="1" step="1" value="${start}" data-gstart="${i}"/></td>
      </tr>`;
    }).join('');
  }
  function applyGarminMappingFromUI(){
    const body = el('garminMapBody');
    if(!body) return;

    // Phase 5.4.5: allow Undo for mapping edits
    const prevStarts = gFiles.map(g=> (g && Number.isFinite(g.startIdx) && g.startIdx>0) ? Math.trunc(g.startIdx) : 1);

    const inputs = body.querySelectorAll('input[data-gstart]');
    let changed = false;
    for(const inp of inputs){
      const i = Number(inp.getAttribute('data-gstart'));
      const v = Math.trunc(Number(inp.value));
      if(Number.isFinite(i) && gFiles[i]){
        const next = (Number.isFinite(v) && v>0) ? v : 1;
        const cur = (gFiles[i].startIdx!=null ? Math.trunc(gFiles[i].startIdx) : 1);
        if(cur !== next) changed = true;
        gFiles[i].startIdx = next;
      }
    }

    if(changed){
      undo = {type:'garminMap', prevStarts};
    }

    const res = smShots.length ? applyGarminToShots() : {matched:0, overrides:0, unmapped:0, extra:0};
    recomputeBlockStats();
    renderBlockRollups();
    renderTable();
    renderGarminMapping();

    const warn = [];
    if(res.extra>0) warn.push(`<span class="warn">⚠ ${res.extra} Garmin shot(s) map beyond ShotMarker count.</span>`);
    if(res.unmapped>0) warn.push(`<span class="warn">⚠ ${res.unmapped} ShotMarker shot(s) have no Garmin match.</span>`);
    el('importStatus').innerHTML =
      `<span class="good">Applied Garmin mapping.</span> Matched: ${res.matched} • Overrides: ${res.overrides} • Unmapped: ${res.unmapped}` +
      (warn.length ? `<div style="margin-top:6px;">${warn.join(' ')}</div>` : '');
  }


  function downloadBlob(filename, mime, text){
    const blob = new Blob([text], {type:mime});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 1000);
  }

  function exportCSV(){
  if(!smShots.length){
    el('importStatus').innerHTML = `<span class="bad">Load ShotMarker first.</span>`;
    return;
  }
  // Ensure stats are current
  recomputeBlockStats();
  recomputeGeoStats();

  const csvCell = (v)=>{
    if(v===null || v===undefined) return '';
    const s = String(v);
    if(/[",\r\n]/.test(s)) return `"${s.replace(/"/g,'""')}"`;
    return s;
  };

  const cols = [
    '#','Block','Rel time','Tag','State','State Src',
    'Score','Vel','Vel Src',
    'Dist (yd)','Dist Src',
    'X (in)','Y (in)','H (MOA)','V (MOA)','R (MOA)',
    'Block Rad ES (MOA)','Block Vert ES (MOA)','Block Horiz ES (MOA)','Block MR (MOA)',
    'Block N (vel)','Block Mean (vel)','Block SD (vel)','Block ES (vel)',
    'ΔVel (σ)','Δσ Level',
    'Kestrel time','Join','Δt (s)',
    'Crosswind','Headwind','Wind spd','Dir (true)','Temp','RH','Station P','DA'
  ];

  const lines = [cols.map(csvCell).join(',')];

  for(const sh of smShots){
    const vs = blockStats.get(sh.block) || {n:0,mean:null,sd:null,es:null};
    const f = velFlagForShot(sh);
    const k = sh.k;

    const distYd = Math.round(distForBlock(sh.block));
    const distSrc = blockDist.has(sh.block) ? 'MAN' : (blockAutoDist.has(sh.block) ? 'SM' : 'DEF');

    const gs = geoStats.get(sh.block);

    const row = [
      sh.idx,
      sh.block,
      sh.relTime,
      sh.tag||'',
      (sh.state||'RECORD'),
      (sh.stateSrc||''),
      sh.score||'',
      (sh.velActive!=null ? Math.round(sh.velActive) : ''),
      sh.velSrc||'SM',
      distYd,
      distSrc,
      (sh.xIn!=null ? sh.xIn.toFixed(4) : ''),
      (sh.yIn!=null ? sh.yIn.toFixed(4) : ''),
      (sh.hMoa!=null ? sh.hMoa.toFixed(3) : ''),
      (sh.vMoa!=null ? sh.vMoa.toFixed(3) : ''),
      (sh.rMoa!=null ? sh.rMoa.toFixed(3) : ''),
      (gs && gs.radialESmoa!=null ? gs.radialESmoa.toFixed(3) : ''),
      (gs && gs.vertESmoa!=null ? gs.vertESmoa.toFixed(3) : ''),
      (gs && gs.horizESmoa!=null ? gs.horizESmoa.toFixed(3) : ''),
      (gs && gs.mrMoa!=null ? gs.mrMoa.toFixed(3) : ''),
      vs.n||0,
      (vs.mean!=null ? vs.mean.toFixed(2) : ''),
      (vs.sd!=null ? vs.sd.toFixed(2) : ''),
      (vs.es!=null ? vs.es.toFixed(2) : ''),
      (f && f.text ? f.az.toFixed(2) : ''),
      (f && f.text ? String(f.level||'').toUpperCase() : ''),
      (k ? k.formatted : ''),
      (sh.j||''),
      (sh.kdt!=null ? sh.kdt.toFixed(2) : ''),
      (k && k.crosswind!=null ? k.crosswind.toFixed(2) : ''),
      (k && k.headwind!=null ? k.headwind.toFixed(2) : ''),
      (k && k.windSpeed!=null ? k.windSpeed.toFixed(2) : ''),
      (k && k.trueDir!=null ? k.trueDir.toFixed(0) : ''),
      (k && k.temp!=null ? k.temp.toFixed(2) : ''),
      (k && k.rh!=null ? k.rh.toFixed(2) : ''),
      (k && k.stationP!=null ? k.stationP.toFixed(2) : ''),
      (k && k.da!=null ? k.da.toFixed(0) : '')
    ];

    lines.push(row.map(csvCell).join(','));
  }

  downloadBlob(`ShotLedger_v${APP.version}_export.csv`, 'text/csv;charset=utf-8', lines.join('\n'));
  el('importStatus').innerHTML = `<span class="good">Exported CSV (states + MOA + Δσ + distance authority).</span>`;
}

  function exportJSON(){
  if(!smShots.length && !gFiles.length && !kSamples.length){
    el('importStatus').innerHTML = `<span class="bad">Nothing to export yet.</span>`;
    return;
  }

  // Ensure snapshots are current
  recomputeBlockStats();
  recomputeGeoStats();

  // Build per-block snapshot (distance authority + stats)
  const groups = groupByBlock();
  const blocks = [];
  for(const [block, list] of groups.entries()){
    const distYd = distForBlock(block);
    const distSrc = blockDist.has(block) ? 'MAN' : (blockAutoDist.has(block) ? 'SM' : 'DEF');
    const vel = blockStats.get(block) || computeVelStats(list);
    const geo = geoStats.get(block) || computeGeoStatsForBlock(block, list);
    const wind = computeWindStats(list);

    blocks.push({
      block,
      distance: {
        yd: distYd,
        src: distSrc,
        manualYd: (blockDist.has(block) ? Number(blockDist.get(block)) : null),
        shotMarkerYd: (blockAutoDist.has(block) ? Number(blockAutoDist.get(block)) : null),
        defaultYd: defaultDistYd
      },
      velStats: vel,
      geoStats: geo,
      windStats: wind
    });
  }

  const payload = {
    version: APP.version,
    schemaVersion: APP.schemaVersion,
    app: { name: APP.name, flavor: APP.flavor },
    exportedAt: new Date().toISOString(),
    ui: {
      activeBlock: activeBlock || null,
      defaultDistYd: defaultDistYd,
      table: { limit: (tablePrefs?tablePrefs.limit:200), useVirtual: (tablePrefs?!!tablePrefs.useVirtual:false), visibleCols: (tablePrefs?tablePrefs.visibleCols:null) },
      anchors: {
        sessionDate: el('sessionDate') ? el('sessionDate').value : '',
        aShot: el('aShot') ? Number(el('aShot').value) : null,
        aTime: el('aTime') ? el('aTime').value : '',
        bShot: el('bShot') ? Number(el('bShot').value) : null,
        bTime: el('bTime') ? el('bTime').value : '',
        tol: el('tolSel') ? Number(el('tolSel').value) : null
      },
      garminFiles: gFiles.map(g=>({name:g.name, n:(g.shots?g.shots.length:0), startIdx:g.startIdx||1})),
      chronoPairings: Array.from(chronoPair.entries()).map(([block,v])=>({block, name:v.name||'', start:(v.start||1)}))
    },
    blocks,
    shots: smShots.map(s=>{
      const f = velFlagForShot(s);
      const distYd = distForBlock(s.block);
      const distSrc = blockDist.has(s.block) ? 'MAN' : (blockAutoDist.has(s.block) ? 'SM' : 'DEF');
      return {
        idx: s.idx,
        block: s.block,
        relTime: s.relTime,
        tag: s.tag,
        score: s.score,
        // velocity
        velSM: s.velSM,
        velActive: s.velActive,
        velSrc: s.velSrc,
        // state + provenance
        state: (s.state||'RECORD'),
        stateSrc: (s.stateSrc||''),
        // distance used for MOA/stats
        distanceYd: distYd,
        distanceSrc: distSrc,
        // geometry
        xIn: s.xIn,
        yIn: s.yIn,
        hMoa: s.hMoa,
        vMoa: s.vMoa,
        rMoa: s.rMoa,
        // delta-sigma
        deltaSigmaAbs: (f && f.text ? f.az : null),
        deltaSigmaLevel: (f && f.text ? f.level : null),
        // AMP (optional)
        ampPeak: (s.ampPeak!=null && Number.isFinite(+s.ampPeak)) ? +s.ampPeak : null,
        ampWork: (s.ampWork!=null && Number.isFinite(+s.ampWork)) ? +s.ampWork : null,
        ampStartPos: (s.ampStartPos!=null && Number.isFinite(+s.ampStartPos)) ? +s.ampStartPos : null,
        ampZ: (s.ampZ!=null && Number.isFinite(+s.ampZ)) ? +s.ampZ : null,
        ampZPeak: (s.ampZPeak!=null && Number.isFinite(+s.ampZPeak)) ? +s.ampZPeak : null,
        ampZWork: (s.ampZWork!=null && Number.isFinite(+s.ampZWork)) ? +s.ampZWork : null,
        ampZStart: (s.ampZStart!=null && Number.isFinite(+s.ampZStart)) ? +s.ampZStart : null,
        // manual inputs
        primerSeat: (s.primerSeat!=null ? s.primerSeat : null),
        windZero: (s.windZero!=null ? s.windZero : null),
        elevZero: (s.elevZero!=null ? s.elevZero : null),
        windCall: (s.windCall || null),
        notes: (s.notes || null),
        // kestrel join summary
        kestrel: (s.k ? s.k.formatted : null),
        join: s.j || null,
        dt: s.kdt,
        k: (s.k ? s.k : null)
      };
    })
  };

  downloadBlob(`ShotLedger_v${APP.version}_export.json`, 'application/json;charset=utf-8', JSON.stringify(payload, null, 2));
  el('importStatus').innerHTML = `<span class="good">Exported JSON (blocks + shots + distance authority + stats snapshots).</span>`;


}

  function csvCell(v){
    const s = (v==null) ? '' : String(v);
    if(/[",\n\r]/.test(s)) return '"' + s.replace(/"/g,'""') + '"';
    return s;
  }


  
  function geoLine(block){
    const gs = geoStats.get(block);
    if(!gs || !gs.n) return '';
    const parts = [];
    parts.push(` • Dist ${Math.round(gs.distYd)}yd`);
    parts.push(` • Rad ES ${gs.radialESmoa!=null ? gs.radialESmoa.toFixed(2) : '—'}`);
    parts.push(` • V ES ${gs.vertESmoa!=null ? gs.vertESmoa.toFixed(2) : '—'}`);
    parts.push(` • H ES ${gs.horizESmoa!=null ? gs.horizESmoa.toFixed(2) : '—'}`);
    parts.push(` • MR ${gs.mrMoa!=null ? gs.mrMoa.toFixed(2) : '—'}`);
    return parts.join('');
  }

function renderBlockRollups(){
    const roll = el('blockRollups');
    const hint = el('blockHint');
    if(!roll || !hint) return;
    const showChronoCtl = shouldShowChronoControls();
    if(!smShots.length){
      hint.textContent = 'Load ShotMarker to see block rollups.';
      roll.innerHTML = '';
      return;
    }

    const groups = groupByBlock();

    // Mixed-distance hint (based on ShotMarker headers + overrides)
    const distSet = new Set();
    for(const blk of groups.keys()){
      const d = distForBlock(blk);
      if(Number.isFinite(d) && d>0) distSet.add(Math.round(d));
    }
    const distList = [...distSet].sort((a,b)=>a-b);

    const baseHint = activeBlock
      ? `Filtered to: ${activeBlock}`
      : `Showing all blocks (${groups.size}). Click a block to filter the table.`;

    const distHint = (distList.length>1)
      ? ` ⚠ Mixed distances detected: ${distList.join(', ')}yd. (Default distance is only used when a block has no ShotMarker yardage and no manual override.)`
      : '';

    hint.textContent = baseHint + distHint;

    // Ensure geometry is current (state toggles or distance edits)
    recomputeGeoStats();

    const items = [];
    for(const [block, list] of groups.entries()){
      const c = countStates(list);
      const isActive = (activeBlock === block);
      const vs = computeVelStats(list);
      const vLine = (vs.n===0)
        ? 'Vel —'
        : `Vel ${Math.round(vs.mean)} | SD ${vs.sd!=null ? vs.sd.toFixed(1) : '—'} | ES ${vs.es!=null ? Math.round(vs.es) : '—'}`;

      const gs = geoStats.get(block);
      const distYd = (gs && gs.distYd!=null) ? gs.distYd : distForBlock(block);

      // Distance authority: manual override > ShotMarker header > default
      const distSrc = blockDist.has(block) ? 'MAN' : (blockAutoDist.has(block) ? 'SM' : 'DEF');
      const distTag = distSrc==='SM' ? ' (SM)' : (distSrc==='MAN' ? ' (man)' : '');
      const gLine = (gs && gs.n)
        ? `Dist ${Math.round(distYd)}yd${distTag} | Rad ${gs.radialESmoa!=null ? gs.radialESmoa.toFixed(2) : '—'} | V ${gs.vertESmoa!=null ? gs.vertESmoa.toFixed(2) : '—'} | H ${gs.horizESmoa!=null ? gs.horizESmoa.toFixed(2) : '—'} | MR ${gs.mrMoa!=null ? gs.mrMoa.toFixed(2) : '—'}`
        : `Dist ${Math.round(distYd)}yd${distTag}`;

      const ws = computeWindStats(list);
      let wLine = '';
      if(ws && ws.n>0){
        const inst = windInstabilityLabel(ws);
        const exp = windExplainLabel(ws.r);
        const joinPct = ws.rec>0 ? Math.round(100*ws.n/ws.rec) : 0;
        const brTxt = (ws.bracket!=null && Number.isFinite(ws.bracket)) ? `${ws.min.toFixed(1)}–${ws.max.toFixed(1)}` : '—';
        const sdTxt = (ws.sd!=null && Number.isFinite(ws.sd)) ? ws.sd.toFixed(1) : '—';
        const meanTxt = (ws.mean!=null && Number.isFinite(ws.mean)) ? ws.mean.toFixed(1) : '—';

        const instCls = (inst && inst.lvl==='OK') ? 'ok' : ((inst && inst.lvl==='VAR') ? 'warn' : ((inst && inst.lvl==='WILD') ? 'bad' : 'neutral'));

        wLine = `Wind avg ${meanTxt} | SD ${sdTxt} | Br ${brTxt} | ${joinPct}% joined` +
               (inst ? ` <span class="windChip ${instCls}" title="${esc(inst.title)}">${inst.icon}</span>` : '') +
               (exp ? ` <span class="windChip neutral" title="${esc(exp.title)}">Explains H: ${esc(exp.txt)}</span>` : '');
      }

      const countsLine = `${c.total} shots | ${c.rec} record | ${c.sgt} sighters | ${c.exc} excluded`;

      // Join health (record shots only)
      let gJoin = 0, kJoin = 0, aJoin = 0;
      for(const sh of list){
        if((sh.state||'RECORD')!=='RECORD') continue;
        if(sh.gMapped) gJoin++;
        if(sh.j==='JOIN') kJoin++;
        if(sh.ampZ!=null && Number.isFinite(sh.ampZ)) aJoin++;
      }

      {
        const primaryHtml = (gs && gs.n && gs.vertMoa!=null && Number.isFinite(gs.vertMoa))
          ? `<b>Vert (REC): ${gs.vertMoa.toFixed(2)} MOA</b> @ ${Math.round(distYd)}yd`
          : '';
        const isDirty = dirtyBlocks.has(block) || dirtyPairBlocks.has(block) || dirtyDistBlocks.has(block);
        items.push({block, c, isActive, vs, vLine, wLine, gLine, countsLine, primaryHtml, distYd, distSrc, gJoin, kJoin, aJoin, isDirty});
      }
    }

    // preserve original order from smBlocks when possible
    const order = new Map(smBlocks.map((b,i)=>[b.label, i]));
    items.sort((a,b)=>{
      const ai = order.has(a.block) ? order.get(a.block) : 1e9;
      const bi = order.has(b.block) ? order.get(b.block) : 1e9;
      return ai - bi;
    });

    roll.innerHTML = items.map(it=>{
      const sd = it.vs && it.vs.sd!=null ? it.vs.sd : null;
      const es = it.vs && it.vs.es!=null ? it.vs.es : null;
      const warn = (sd!=null && sd>15) || (es!=null && es>40);

      const srcCls = it.distSrc==='SM' ? 'sm' : (it.distSrc==='MAN' ? 'man' : 'def');
      const srcTxt = it.distSrc==='SM' ? 'SM' : (it.distSrc==='MAN' ? 'MAN' : 'DEF');
      const srcTitle = it.distSrc==='SM'
        ? 'Distance from ShotMarker header'
        : (it.distSrc==='MAN' ? 'Manual distance override (double-click to reset)' : 'Default distance');

      // Join health chips (record shots only) — show at-a-glance mapping coverage
      let joinHtml = '';
      if(it.c && it.c.rec){
        const gJoin = it.gJoin||0, kJoin = it.kJoin||0, aJoin = it.aJoin||0;
        const gPct = Math.round(100*gJoin/it.c.rec);
        const kPct = Math.round(100*kJoin/it.c.rec);
        const aPct = Math.round(100*aJoin/it.c.rec);
        const clsFor = (pct)=> (pct>=90 ? 'ok' : (pct>=50 ? 'warn' : 'bad'));
        joinHtml += `<span class="bchip join ${clsFor(gPct)}" title="Garmin joined on record shots">G ${gJoin}/${it.c.rec}</span>`;
        joinHtml += `<span class="bchip join ${clsFor(kPct)}" title="Kestrel joined on record shots">K ${kJoin}/${it.c.rec}</span>`;
        if(typeof ampSession!=='undefined' && ampSession && ampSession.n){
          joinHtml += `<span class="bchip join ${clsFor(aPct)}" title="AMP traces mapped on record shots">A ${aJoin}/${it.c.rec}</span>`;
        }
      }

      return `<div class="blockRow ${it.isActive?'active':''} ${it.isDirty?'dirty':''}" data-block="${esc(it.block)}" title="Click to filter table to this block">
        <div class="l">
          <div class="title">${esc(it.block)}${it.isDirty?`<span class="dirtyDot" title="Changed (manual edit, distance, or pairing)"></span>`:''}<\/div>
          <div class="meta">
            ${it.primaryHtml ? `<div class="metaLine metaPrimary">${it.primaryHtml}</div>` : ``}
            <div class="metaLine metaCounts">${esc(it.countsLine||'')}</div>
            <div class="metaLine metaVel">${esc(it.vLine||'')}</div>
            <div class="metaLine metaGeo">${esc(it.gLine||'')}</div>
            ${it.wLine ? `<div class="metaLine metaWind">${it.wLine}</div>` : ``}
          </div>
        </div>
        <div class="stats">
          <span class="bchip rec">R ${it.c.rec}</span>
          <span class="bchip sgt">S ${it.c.sgt}</span>
          <span class="bchip exc">✕ ${it.c.exc}</span>
          ${joinHtml}
          <div class="chronoCtl ${showChronoCtl ? "" : "hidden"}" title="Pair this ShotMarker target to a chrono file (one file per target).">
            <select class="chronoSel" data-chrono="${esc(it.block)}">
              <option value="">— Chrono —</option>
              ${gFiles.map(g=>`<option value="${esc(g.name)}" ${((chronoPair.get(it.block)||{}).name===g.name)?'selected':''}>${esc(g.name)}</option>`).join('')}
            </select>
            <input class="chronoStart" data-chrono-start="${esc(it.block)}" type="number" min="1" step="1"
                   value="${(chronoPair.get(it.block)&&chronoPair.get(it.block).start)||1}"
                   title="Start shot # within the chrono file (1-based)"/>
          </div>

          ${(it.c.rec<5) ? `<span class="warnChip" title="Low sample: fewer than 5 record shots in this block. Treat stats cautiously.">n<5</span>` : ``}
          ${((it.vs && it.vs.n>0 && (!it.vs.sd || !Number.isFinite(it.vs.sd) || it.vs.sd<=0)) ? `<span class="warnChip" title="SD not available (need ≥3 record velocities). Δσ flags disabled for this block.">SD?</span>` : ``)}
          <span class="distSrc ${srcCls}" title="${esc(srcTitle)}">${esc(srcTxt)}</span>
          <input class="distInput" data-dist="${esc(it.block)}" type="number" min="10" step="1"
                 value="${Math.round(distForBlock(it.block))}"
                 title="Distance (yd) for this block. Change to override; double-click to reset to SM/default."/>
          ${warn ? `<span class="warnChip" title="Heads-up: SD>15 or ES>40 (record shots only)">⚠</span>` : ``}
        </div>
      </div>`;
    }).join('');

    // Manual inputs: refresh string dropdown
    const msel = el('manBlockSel');
    if(msel){
      const opts = [`<option value="">— Select string —</option>`]
        .concat(items.map(it=>`<option value="${esc(it.block)}" ${(msel.value===it.block || activeBlock===it.block)?'selected':''}>${esc(it.block)}</option>`));
      msel.innerHTML = opts.join('');
    }
  }

// ---------- rendering ----------
  function renderTable(){
    const tbody = el('shotTbody');
    if(!tbody) return;

    // Ensure we have a stable per-block shot index (1..N in file order)
    // This supports "sorted 1–22 within each target".
    let need = false;
    for(const sh of smShots){ if(sh && sh.inBlock==null){ need = true; break; } }
    if(need){
      const ctr = new Map();
      for(const sh of smShots){
        const b = sh.block || '';
        const n = (ctr.get(b)||0) + 1;
        ctr.set(b, n);
        sh.inBlock = n;
      }
    }

    const buildRow = (sh, numOverride) => {
      const k = sh.k;
      const tag = sh.tag ? `<span class="tagpill">${esc(sh.tag)}</span>` : '';
      const st = (sh.state||'RECORD');
      const src = (sh.stateSrc||'');
      let trCls = (st==='EXCLUDE') ? (`row-exclude ${src==='FLAG' ? 'row-exclude-flag' : 'row-exclude-manual'}`) : (st==='SIGHTER' ? 'row-sighter' : '');
      if(gFiles.length && !sh.gMapped) trCls += (trCls?' ':'') + 'row-garmiss';
      if(dirtyShotIdxs.has(sh.idx)) trCls += (trCls?' ':'') + 'row-dirty';
      if(previewActive) trCls += (trCls?' ':'') + 'row-preview';

      const num = (numOverride!=null ? numOverride : (sh.inBlock!=null ? sh.inBlock : sh.idx));

      return `<tr class="${trCls}">
        <td class="sticky c0"><input type="checkbox" class="rowSel" data-sel="${sh.idx}" ${selectedShots.has(sh.idx)?"checked":""}></td>
        <td class="sticky c1">${num}</td>
        <td class="sticky c2">${esc(sh.block||'')}</td>
        <td class="sticky c3">${stateCell(sh)}</td>
        <td>${esc(sh.relTime||'')}</td>
        <td>${tag}</td>
        <td>${esc(sh.score||'')}</td>
        <td>${formatVel(sh.velActive, sh.vel)}</td>
        <td>${esc(sh.velSrc||'SM')}</td>
        <td>${ampValCell('Peak', sh.ampPeak, sh.ampZPeak)}</td>
        <td>${ampValCell('Work', sh.ampWork, sh.ampZWork)}</td>
        <td>${ampPill(sh)}</td>
        <td>${flagCell(sh)}</td>
        <td>${fmtIn(sh.xIn)}</td>
        <td>${fmtIn(sh.yIn)}</td>
        <td>${fmtMoa(sh.hMoa)}</td>
        <td>${fmtMoa(sh.vMoa)}</td>
        <td>${fmtMoa(sh.rMoa)}</td>
        <td>${k ? esc(k.formatted) : ''}</td>
        <td>${joinPill(sh.j)}</td>
        <td>${(sh.kdt!=null && Number.isFinite(sh.kdt)) ? sh.kdt.toFixed(1) : ''}</td>
        <td>${k && k.crosswind!=null ? k.crosswind.toFixed(1) : ''}</td>
        <td>${k && k.headwind!=null ? k.headwind.toFixed(1) : ''}</td>
        <td>${k && k.windSpeed!=null ? k.windSpeed.toFixed(1) : ''}</td>
        <td>${k && k.trueDir!=null ? k.trueDir.toFixed(0) : ''}</td>
        <td>${k && k.temp!=null ? k.temp.toFixed(1) : ''}</td>
        <td>${k && k.rh!=null ? k.rh.toFixed(1) : ''}</td>
        <td>${k && k.stationP!=null ? k.stationP.toFixed(2) : ''}</td>
        <td>${k && k.da!=null ? k.da.toFixed(0) : ''}</td>
        <td>${fmtIn(sh.primerSeat)}</td>
        <td>${fmtMoa(sh.windZero)}</td>
        <td>${fmtMoa(sh.elevZero)}</td>
        <td>${esc(sh.windCall||'')}</td>
        <td>${esc(sh.notes||'')}</td>
      </tr>`;
    };


// Virtual All view (flat list) – only when not filtered to a block.
if(!activeBlock && tablePrefs && tablePrefs.useVirtual && (tablePrefs.limit===0) && el('tableWrap')){
  const view = [...smShots].filter(passesFilters).sort((a,b)=>{
    const ab = String(a.block||''); const bb = String(b.block||'');
    if(ab!==bb) return ab.localeCompare(bb);
    return (a.inBlock||0) - (b.inBlock||0);
  });
  const wrap = el('tableWrap');
  renderVirtualAllView(tbody, wrap, buildRow, view);
  updateSelPill();
  updateSortIndicators();
  applyColumnVisibility();
  updateShotListTitle();
  return;
}

    // Active block view keeps sorting behavior (click headers)
    if(activeBlock){
      let view = smShots.filter(s=>s.block===activeBlock && passesFilters(s));

      const key = tableSort && tableSort.key ? tableSort.key : null;
      const dir = (tableSort && tableSort.dir) ? tableSort.dir : 1;

      function sortVal(sh, k){
        const st = (sh.state||'RECORD');
        if(k==='idx') return sh.inBlock!=null ? sh.inBlock : sh.idx;
        if(k==='block') return String(sh.block||'');
        if(k==='state') return st;
        if(k==='relTime') return String(sh.relTime||'');
        if(k==='score') return String(sh.score||'');
        if(k==='vel') return (sh.velActive!=null && Number.isFinite(sh.velActive)) ? sh.velActive : null;
        if(k==='velSrc') return String(sh.velSrc||'');
        if(k==='dsigma'){
          const f = velFlagForShot(sh);
          return (f && Number.isFinite(f.az)) ? f.az : null;
        }
        if(k==='xIn') return (sh.xIn!=null && Number.isFinite(sh.xIn)) ? sh.xIn : null;
        if(k==='yIn') return (sh.yIn!=null && Number.isFinite(sh.yIn)) ? sh.yIn : null;
        if(k==='hMoa') return (sh.hMoa!=null && Number.isFinite(sh.hMoa)) ? sh.hMoa : null;
        if(k==='vMoa') return (sh.vMoa!=null && Number.isFinite(sh.vMoa)) ? sh.vMoa : null;
        if(k==='rMoa') return (sh.rMoa!=null && Number.isFinite(sh.rMoa)) ? sh.rMoa : null;
        if(k==='kTime') return sh.k ? String(sh.k.formatted||'') : '';
        if(k==='join') return String(sh.j||'');
        if(k==='kdt') return (sh.kdt!=null && Number.isFinite(sh.kdt)) ? sh.kdt : null;
        if(k==='crosswind') return (sh.k && sh.k.crosswind!=null) ? sh.k.crosswind : null;
        if(k==='headwind') return (sh.k && sh.k.headwind!=null) ? sh.k.headwind : null;
        if(k==='windSpeed') return (sh.k && sh.k.windSpeed!=null) ? sh.k.windSpeed : null;
        if(k==='trueDir') return (sh.k && sh.k.trueDir!=null) ? sh.k.trueDir : null;
        if(k==='temp') return (sh.k && sh.k.temp!=null) ? sh.k.temp : null;
        if(k==='rh') return (sh.k && sh.k.rh!=null) ? sh.k.rh : null;
        if(k==='stationP') return (sh.k && sh.k.stationP!=null) ? sh.k.stationP : null;
        if(k==='da') return (sh.k && sh.k.da!=null) ? sh.k.da : null;
        if(k==='primerSeat') return (sh.primerSeat!=null && Number.isFinite(sh.primerSeat)) ? sh.primerSeat : null;
        if(k==='windZero') return (sh.windZero!=null && Number.isFinite(sh.windZero)) ? sh.windZero : null;
        if(k==='elevZero') return (sh.elevZero!=null && Number.isFinite(sh.elevZero)) ? sh.elevZero : null;
        if(k==='windCall') return String(sh.windCall||'');
        if(k==='notes') return String(sh.notes||'');
        return null;
      }

      if(key){
        view = [...view].sort((a,b)=>{
          const va = sortVal(a,key);
          const vb = sortVal(b,key);

          if(va==null && vb==null) return 0;
          if(va==null) return 1;
          if(vb==null) return -1;

          if(typeof va==='number' && typeof vb==='number') return dir*(va-vb);
          return dir*String(va).localeCompare(String(vb));
        });
      } else {
        // default: 1..22 within block
        view = [...view].sort((a,b)=> (a.inBlock||0) - (b.inBlock||0));
      }

      const rows = view.slice(0,200).map(sh=> buildRow(sh)).join('');
      // Avoid Chrome "stuck paint" artifacts from rewriting tbody.innerHTML inside a scroll container.
// Build into a detached <tbody> and then replaceChildren() to force a clean DOM swap.
const tmpTbody = document.createElement('tbody');
tmpTbody.innerHTML = rows || `<tr><td colspan="31" style="color:rgba(230,238,248,.6); padding:16px;">Load ShotMarker CSV to see shots.</td></tr>`;
tbody.replaceChildren(...tmpTbody.children);
// Nuke any selection/focus paint that can leave column seams behind
try{ if(document.activeElement) document.activeElement.blur(); }catch(e){}
try{ const sel = window.getSelection && window.getSelection(); if(sel && sel.removeAllRanges) sel.removeAllRanges(); }catch(e){}
      updateSelPill();
      updateSortIndicators();
      return;
    }

    // ----- All shots view: group by target (block) with rollups -----
    const colCount = document.querySelectorAll('#shotTable thead th').length || 1;

    // Order blocks as they appeared in ShotMarker (smBlocks), fall back to grouped keys
    const order = (smBlocks && smBlocks.length) ? smBlocks.map(b=>b.label) : Array.from(groupByBlock().keys());
    const groups = groupByBlock();

    const out = [];
    let shown = 0;
    const LIMIT = (tablePrefs && Number.isFinite(+tablePrefs.limit) && +tablePrefs.limit>0) ? +tablePrefs.limit : Infinity;

    for(const block of order){
      const list0 = (groups.get(block)||[]).filter(passesFilters);
      if(!list0 || !list0.length) continue;

      const list = [...list0].sort((a,b)=> (a.inBlock||0) - (b.inBlock||0));

      // header counts
      let nRec=0, nSgt=0, nExc=0;
      for(const sh of list){
        const st = (sh.state||'RECORD');
        if(st==='SIGHTER') nSgt++;
        else if(st==='EXCLUDE') nExc++;
        else nRec++;
      }
      const dist = distForBlock(block);
      const distTxt = (dist!=null && Number.isFinite(dist) && dist>0) ? ` • ${Math.round(dist)}yd` : '';
      const caret = collapsedBlocks.has(block) ? '▶' : '▼';

      out.push(`<tr class="tGroupHeader" data-block="${esc(block)}">
        <td colspan="${colCount}">
          <span class="tCaret">${caret}</span>
          <span class="tTitle">${esc(block)}</span>
          <span class="tMeta">${list.length} shots • <span class="good">R</span> ${nRec} • <span class="warn">S</span> ${nSgt} • <span class="bad">X</span> ${nExc}${distTxt}</span>
        </td>
      </tr>`);

      if(collapsedBlocks.has(block)) continue;

      for(const sh of list){
        if(shown >= LIMIT){
          out.push(`<tr class="tGroupFooter"><td colspan="${colCount}" class="hint" style="padding:14px;">Showing first ${LIMIT} rows in All view. Use Blocks to drill into a single target.</td></tr>`);
          break;
        }
        shown++;
        out.push(buildRow(sh, sh.inBlock!=null ? sh.inBlock : sh.idx));
      }
      if(shown >= LIMIT) break;
    }

    tbody.innerHTML = out.join('') || `<tr><td colspan="${colCount}" style="color:rgba(230,238,248,.6); padding:16px;">Load ShotMarker CSV to see shots.</td></tr>`;
    updateSelPill();

    // Phase 4: Preview controls
    const btnPrev = el('btnPreview');
    const btnPrevApply = el('btnPreviewApply');
    const btnPrevCancel = el('btnPreviewCancel');
    if(btnPrev){
      btnPrev.addEventListener('click', ()=>{
        if(previewActive) cancelPreview();
        else beginPreview();
      });
    }
    if(btnPrevApply){ btnPrevApply.addEventListener('click', applyPreview); }
    if(btnPrevCancel){ btnPrevCancel.addEventListener('click', cancelPreview); }

    updateSortIndicators();
    applyColumnVisibility();
    updateShotListTitle();
  }


  function renderSummaries(){
    const btxt = smBlocks.slice(0,5).map((b,i)=>`${i+1}. ${b.label} — ${b.n} shots`).join("\n");
    const metaLine = smBlocks.length ? `${smBlocks.length} blocks • ${smShots.length} shots` : `Rollups, distance, filters`;
    if(blocksMeta){
      blocksMeta.textContent = metaLine;
      if(smBlocks.length){
        blocksMeta.title = `Blocks found: ${smBlocks.length}
Total shots (incl. sighters): ${smShots.length}
First 5 blocks:
${btxt}`;
      } else {
        blocksMeta.title = '';
      }
    }
  }


  // Phase 3 Step 1: state toggle delegation
  shotTbody.addEventListener('click', (e)=>{

    // Group header toggle in All view
    const hdr = e.target && e.target.closest ? e.target.closest('tr.tGroupHeader[data-block]') : null;
    if(hdr && !activeBlock){
      const block = hdr.getAttribute('data-block') || '';
      if(block){
        if(collapsedBlocks.has(block)) collapsedBlocks.delete(block);
        else collapsedBlocks.add(block);
        renderTable();
      }
      return;
    }

    // Phase 3 Step 1: state toggle delegation
    const btn = e.target && e.target.closest ? e.target.closest('button[data-idx][data-state]') : null;
    if(!btn) return;
    const idx = parseInt(btn.getAttribute('data-idx')||'', 10);
    const st = btn.getAttribute('data-state')||'RECORD';
    const src = (st==='EXCLUDE') ? 'MANUAL' : 'MANUAL';
    setShotStateByIdx(idx, st, true, src);
  });


  // ---------- UI wiring ----------


const collapseAllBtn = el('collapseAllBlocksBtn');
if(collapseAllBtn) collapseAllBtn.addEventListener('click', ()=>{
  collapsedBlocks = new Set((smBlocks||[]).map(b=>b.label));
  renderBlockRollups();
});

const expandAllBtn = el('expandAllBlocksBtn');
if(expandAllBtn) expandAllBtn.addEventListener('click', ()=>{
  collapsedBlocks = new Set();
  renderBlockRollups();
});

  el('clearBlockFilterBtn').addEventListener('click', ()=>{
    activeBlock = null;
    renderTable();
    renderBlockRollups();
  });

  el('blockRollups').addEventListener('click', (e)=>{
    const inp = e.target && e.target.closest ? e.target.closest('input.distInput[data-dist]') : null;
    if(inp){
      const blk = inp.getAttribute('data-dist');
      const n = Number(inp.value);
      if(blk && Number.isFinite(n) && n>0){
        blockDist.set(blk, n);
        dirtyDistBlocks.add(blk);
        dirtyBlocks.add(blk);
        recomputeGeoStats();
        renderBlockRollups();
        renderTable();
      }
      return;
    }
    const row = e.target && e.target.closest ? e.target.closest('.blockRow[data-block]') : null;
    if(!row) return;
    const block = row.getAttribute('data-block');
    activeBlock = (activeBlock === block) ? null : block;
    renderTable();
    renderBlockRollups();
  });

  el('blockRollups').addEventListener('change', (e)=>{
    // Chrono pairing dropdown
    const sel = e.target && e.target.closest ? e.target.closest('select.chronoSel[data-chrono]') : null;
    if(sel){
      const blk = sel.getAttribute('data-chrono');
      const name = sel.value || '';
      const cur = chronoPair.get(blk) || {name:'', start:1};
      cur.name = name;
      chronoPair.set(blk, cur);
      dirtyPairBlocks.add(blk);
      dirtyBlocks.add(blk);
      applyChronoPairings();
      return;
    }

    // Chrono start shot #
    const cs = e.target && e.target.closest ? e.target.closest('input.chronoStart[data-chrono-start]') : null;
    if(cs){
      const blk = cs.getAttribute('data-chrono-start');
      const start = Math.max(1, Number(cs.value||1));
      const cur = chronoPair.get(blk) || {name:'', start:1};
      cur.start = start;
      chronoPair.set(blk, cur);
      dirtyPairBlocks.add(blk);
      dirtyBlocks.add(blk);
      applyChronoPairings();
      return;
    }

    // Distance override
    const inp = e.target && e.target.closest ? e.target.closest('input.distInput[data-dist]') : null;
    if(!inp) return;
    const blk = inp.getAttribute('data-dist');
    const n = Number(inp.value);
    if(blk && Number.isFinite(n) && n>0){
      blockDist.set(blk, n);
      recomputeGeoStats();
      renderBlockRollups();
      renderTable();
    }
  });

  // Phase 5.4.1: double-click distance box to clear manual override (revert to SM header / default)
  el('blockRollups').addEventListener('dblclick', (e)=>{
    const inp = e.target && e.target.closest ? e.target.closest('input.distInput[data-dist]') : null;
    if(!inp) return;
    const blk = inp.getAttribute('data-dist');
    if(!blk) return;
    if(blockDist.has(blk)){
      blockDist.delete(blk);
      recomputeGeoStats();
      renderBlockRollups();
      renderTable();
      el('importStatus').innerHTML = `<span class="hint">Distance override cleared for ${esc(blk)}.</span>`;
    } else {
      // if no manual override, a double-click is a no-op (but feels responsive)
      el('importStatus').innerHTML = `<span class="hint">No manual distance override set for ${esc(blk)}.</span>`;
    }
  });




  el('btnSM').addEventListener('click', ()=>el('fileSM').click());
  el('btnK').addEventListener('click', ()=>el('fileK').click());
  el('btnG').addEventListener('click', ()=>el('fileG').click());
    el('btnAMP').addEventListener('click', ()=>el('fileAMP').click());
    el('btnAMPClear').addEventListener('click', ()=>{
    ampSession = null;
    if(smShots && smShots.length){
      for(const sh of smShots){
        sh.ampPeak = null;
        sh.ampWork = null;
        sh.ampStartPos = null;
        sh.ampZ = null;
      }
    }
    const fa = el('fileAMP');
    if(fa) fa.value = '';
    recomputeBlockStats();
    renderBlockRollups();
    renderTable();
    toast('AMP cleared');
  });
el('fileSM').addEventListener('change', async (e)=>{
    const f = e.target.files && e.target.files[0];
    if(!f) return;
    const text = await f.text();
    const {blocks, shots} = parseShotMarkerArchive(text);
    smBlocks = blocks;
    smShots = shots;
    // capture any auto distance from ShotMarker headers
    blockAutoDist = new Map();
    for(const b of smBlocks){
      if(b && b.label){
        const n = Number(b.distYdAuto);
        if(Number.isFinite(n) && n>0) blockAutoDist.set(b.label, n);
      }
    }
    // If user hasn't changed default distance yet, and ShotMarker provides one, seed the default distance.
    const defInput = el('defaultDist');
    if(defInput){
      const cur = Number(defInput.value);
      if(!(Number.isFinite(cur) && cur>0) && blockAutoDist.size){
        defInput.value = String(Math.round([...blockAutoDist.values()][0]));
      }
    }

    for(const sh of smShots){
      const smv = parseFloat(String(sh.vel||'').trim());
      sh.velSM = Number.isFinite(smv) ? smv : null;
      sh.velActive = sh.velSM;
      sh.xMmNum = safeNum(sh.xMm);
      sh.yMmNum = safeNum(sh.yMm);
      sh.xIn = (sh.xMmNum!=null) ? (sh.xMmNum/25.4) : null;
      sh.yIn = (sh.yMmNum!=null) ? (sh.yMmNum/25.4) : null;
      sh.hMoa = null; sh.vMoa=null; sh.rMoa=null;
      sh.velSrc = 'SM';
      sh.state = inferStateFromTag(sh.tag);
      sh.stateSrc = (sh.state==='SIGHTER') ? 'TAG' : '';
      sh.k = null; sh.kdt = null; sh.j = null;
    }
    smFirstDate = (blocks.length ? parseSMDateStr(blocks[0].dateStr) : null);
    if(gFiles.length){ applyGarminToShots(); applyChronoPairings(); }

    importStatus.innerHTML = '';
    if(!smShots.length){
  const diag = diagnoseShotMarker(text);
  const sLines = (diag.samples||[]).map(o=>`<div style="margin-top:6px;"><span class="hint">L${o.i+1}:</span> <code style="white-space:normal; overflow-wrap:anywhere;">${esc(String(o.line||'').slice(0,220))}</code></div>`).join('');
  const best = diag.best || {score:-1,i:-1,cols:[],missing:[]};
  const cols = (best.cols && best.cols.length) ? best.cols.map(c=>`<span class="tagpill" style="margin-right:6px; margin-top:6px; display:inline-flex;">${esc(c)}</span>`).join('') : '';
  const missing = (best.missing && best.missing.length) ? best.missing.map(esc).join(', ') : 'unknown';
  importStatus.innerHTML = `<span class="bad">ShotMarker parse: 0 shots found.</span>
    <div class="hint" style="margin-top:6px;">Expected a ShotMarker session CSV with columns like <b>Time</b>, <b>X(mm)</b>, <b>Y(mm)</b>, and <b>Vel (fps)</b>. Here’s what I can see:</div>
    <div class="hint" style="margin-top:8px;"><b>Best header candidate:</b> line ${best.i>=0 ? (best.i+1) : '—'} • matched ${best.score}/4 • missing: <span class="warn">${missing}</span></div>
    <div style="margin-top:8px;">${cols || `<span class="hint">(No header row detected in the first ~120 lines.)</span>`}</div>
    <div class="hint" style="margin-top:10px;"><b>Sample lines:</b>${sLines}</div>`;
} else {
      importStatus.innerHTML = `<span class="good">ShotMarker OK:</span> ${blocks.length} blocks • ${shots.length} shots flattened.`;
      renderTable();
      renderSummaries();
      renderBlockRollups();
      // default session date to today if empty
      if(!el('sessionDate').value){
        const now = new Date();
        el('sessionDate').value = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-${String(now.getDate()).padStart(2,'0')}`;
      }
    }
    setPills(f.name, (kSamples.length? (kMeta.textContent||'Kestrel loaded') : null), (gFiles.length ? gFiles.map(g=>({name:g.name,count:(g.shots?g.shots.length:0)})) : null));
  });

  el('fileK').addEventListener('change', async (e)=>{
    const f = e.target.files && e.target.files[0];
    if(!f) return;
    const text = await f.text();
    const parsed = parseKestrel(text);
    kSamples = parsed.samples;
    kRange = parsed.range;
    if(parsed.error){
      kMeta.textContent = 'Parse error';
      kStatus.innerHTML = `<span class="bad">${esc(parsed.error)}</span>`;
    } else {
      kMeta.textContent = `${f.name} • ${kSamples.length} samples`;
      kStatus.innerHTML = kRange
        ? `<span class="good">Kestrel OK:</span> ${kSamples.length} samples\n<span class="hint">Kestrel range: ${esc(kRange.minStr)} \u2192 ${esc(kRange.maxStr)}</span>`
        : `<span class="warn">Kestrel loaded but no samples detected.</span>`;
    }
    // update pills
    setPills((smShots.length? 'ShotMarker loaded' : null), f.name, (gFiles.length ? gFiles.map(g=>({name:g.name,count:(g.shots?g.shots.length:0)})) : null));
  });
  el('fileG').addEventListener('change', async (e)=>{
    const files = Array.from(e.target.files || []);
    if(!files.length) return;

    const added = [];
    const errs = [];

    // default sequential starts: append after existing Garmin total
    const existingTotal = gFiles.reduce((acc,g)=>acc + ((g.shots&&g.shots.length)||0), 0);

    let running = existingTotal;

    for(const f of files){
      try{
        const txt = await f.text();
        const parsed = parseGarmin(txt);
        if(parsed.error){
          errs.push(`${f.name}: ${parsed.error}`);
          continue;
        }
        const shots = parsed.shots || [];
        const startIdx = running + 1;
        running += shots.length;

        gFiles.push({name:f.name, shots, startIdx});
        added.push({name:f.name, count: shots.length, startIdx});
      } catch(err){
        errs.push(`${f.name}: ${String(err&&err.message ? err.message : err)}`);
      }
    }

    // allow re-adding the same file name if needed
    e.target.value = '';

    // Apply to current ShotMarker (if loaded)
    const res = smShots.length ? applyGarminToShots() : {matched:0, overrides:0, unmapped:0, extra:0};

    const totalFiles = gFiles.length;
    const totalShots = gFiles.reduce((acc,g)=>acc + ((g.shots&&g.shots.length)||0), 0);

    const lines = [];
    if(errs.length){
      lines.push(`<span class="bad">Garmin issues:</span> ${errs.map(esc).join(' • ')}`);
    }
    if(added.length){
      lines.push(`<span class="good">Garmin added:</span> ${added.map(a=>`${esc(a.name)} (${a.count}) `).join(' • ')}`);
    }
    if(totalFiles){
      lines.push(`<span class="good">Garmin total:</span> ${totalFiles} file(s) • ${totalShots} chrono shots`);
    } else {
      lines.push(`<span class="hint">No Garmin data loaded.</span>`);
    }

    if(smShots.length && totalShots){
      lines.push(`<span class="hint">Matched by mapping: ${res.matched} • Overrides used: ${res.overrides} • Unmapped: ${res.unmapped}</span>`);
      if(totalShots < smShots.length){
        lines.push(`<span class="warn">⚠ Garmin chrono shots (${totalShots}) &lt; ShotMarker shots (${smShots.length}). Some shots will remain SM velocity.</span>`);
      }
      if(res.extra>0){
        lines.push(`<span class="warn">⚠ ${res.extra} Garmin shot(s) map beyond the ShotMarker shot count (check start shot #).</span>`);
      }
    } else if(totalShots && !smShots.length){
      lines.push(`<span class="hint">Load ShotMarker to apply velocities.</span>`);
    }

    importStatus.innerHTML = lines.join("\n");

    setPills((smShots.length? 'ShotMarker loaded' : null), (kSamples.length? (kMeta.textContent||'Kestrel loaded') : null),
             (gFiles.length ? gFiles.map(g=>({name:g.name,count:(g.shots?g.shots.length:0)})) : null));
    renderGarminMapping();
    recomputeBlockStats();
    renderBlockRollups();
    renderTable();
  });

  el('fileAMP').addEventListener('change', async (e)=>{
    const f = e.target.files && e.target.files[0];
    if(!f) return;
    try{
      await importAMPCSV(f);
    }catch(err){
      console.error(err);
      toast('AMP import failed');
    }
  });


  el('btnGClear').addEventListener('click', ()=>{
    gFiles = [];
    if(smShots.length){
      // reset to ShotMarker velocities only
      for(const sh of smShots){
        sh.velActive = sh.velSM;
        sh.velSrc = 'SM';
      }
    }
    importStatus.innerHTML = `<span class="hint">Garmin cleared.</span>`;
    setPills((smShots.length? 'ShotMarker loaded' : null), (kSamples.length? (kMeta.textContent||'Kestrel loaded') : null), null);
    renderGarminMapping();
    recomputeBlockStats();
    renderBlockRollups();
    renderTable();
  });




  
  // ---------- Phase 5.4.7: UX guardrails ----------
  function validateKestrelAnchors(){
    const dateISO = (el('sessionDate').value||'').trim();
    const aShot = clampInt(el('aShot').value, 1, smShots.length||1);
    const bShot = clampInt(el('bShot').value, 1, smShots.length||1);
    const aSec = parseHMS(el('aTime').value);
    const bSec = parseHMS(el('bTime').value);
    if(!smShots.length) return {ok:false, msg:'Load ShotMarker first.'};
    if(!kSamples.length) return {ok:false, msg:'Load Kestrel CSV first.'};
    if(!dateISO) return {ok:false, msg:'Set session date.'};
    if(aSec===null || bSec===null) return {ok:false, msg:'Anchor times must be HH:MM:SS.'};
    if(aShot===bShot) return {ok:false, msg:'Anchor A and B shot # must be different.'};
    return {ok:true, msg:''};
  }

  function updateKestrelApplyGuard(){
    const btn = el('applyBtn');
    if(!btn) return;
    const v = validateKestrelAnchors();
    btn.disabled = !v.ok;
    btn.style.opacity = v.ok ? '1' : '.55';
    btn.style.cursor = v.ok ? 'pointer' : 'not-allowed';
    // Show a quiet helper line when disabled (don’t overwrite real status messages)
    const helperId = 'kGuardHelp';
    let help = document.getElementById(helperId);
    if(!help){
      help = document.createElement('div');
      help.id = helperId;
      help.className = 'hint';
      help.style.marginTop = '8px';
      const kbtns = btn.closest('.kbtns');
      if(kbtns) kbtns.insertAdjacentElement('afterend', help);
    }
    if(help){
      help.textContent = v.ok ? '' : ('Apply is disabled: ' + v.msg);
    }
  }

  el('applyBtn').addEventListener('click', applyKestrel);
  el('clearBtn').addEventListener('click', clearKestrel);
  el('autofitBtn').addEventListener('click', autoFitAnchors);
  el('dateFromSMBtn').addEventListener('click', setDateFromSM);
  // Update Apply guard when anchor inputs change
  ['sessionDate','aShot','bShot','aTime','bTime','tolSel','joinMode','alignMode'].forEach(id=>{
    const n = el(id);
    if(n) n.addEventListener('input', updateKestrelApplyGuard);
    if(n) n.addEventListener('change', updateKestrelApplyGuard);
  });


  el('kHeader').addEventListener('click', ()=>{
    const hide = !kBody.classList.contains('hidden');
    kBody.classList.toggle('hidden', hide);
    kChevron.textContent = hide ? '▸' : '▾';
  });

    // Phase 4 buttons
  if(el('btnUndo')) el('btnUndo').addEventListener('click', undoLast);
  if(el('btnExportCSV')) el('btnExportCSV').addEventListener('click', exportCSV);
  if(el('btnExportJSON')) el('btnExportJSON').addEventListener('click', exportJSON);
  if(el('btnImportJSON')) el('btnImportJSON').addEventListener('click', ()=> el('fileJSON').click());
  if(el('fileJSON')) el('fileJSON').addEventListener('change', async (e)=>{
    const f = e.target.files && e.target.files[0];
    if(!f) return;
    try{
      const txt = await f.text();
      importFromJSON(txt, f.name || 'import.json');
      const _st = el('importStatus') || el('importStatus') || el('status');
      if(_st) _st.innerHTML = `<span class="good">Imported JSON.</span>`;
    }catch(err){
      console.error(err);
      const _st2 = el('importStatus') || el('importStatus') || el('status');
      if(_st2) _st2.innerHTML = `<span class="bad">JSON import failed: ${esc(String(err && err.message ? err.message : err))}</span>`;
    }finally{
      // allow re-importing same file
      e.target.value = '';
    }
  });
  if(el('btnClearAll')) el('btnClearAll').addEventListener('click', clearAll);

  if(el('btnApplyGarminMap')) el('btnApplyGarminMap').addEventListener('click', applyGarminMappingFromUI);
  if(el('btnResetBlockStates')) el('btnResetBlockStates').addEventListener('click', resetStatesInActiveBlock);

  // Click flag chip to exclude shot quickly (and track provenance)
  document.addEventListener('click', (ev)=>{
    const t = ev.target;
    if(!(t instanceof HTMLElement)) return;
    const sid = t.getAttribute('data-flag-shot');
    if(!sid) return;
    const shotIdx = parseInt(sid, 10);
    if(!Number.isFinite(shotIdx)) return;
    const sh = smShots.find(s=>s.idx===shotIdx);
    if(!sh) return;

    // Toggle EXCLUDE by flag:
    // - If already excluded *by flag*, clicking again returns to RECORD.
    // - If excluded manually, a click converts it to "flag exclude" (undo restores).
    const cur = sh.state || 'RECORD';
    const curSrc = sh.stateSrc || '';
    const next = (cur==='EXCLUDE' && curSrc==='FLAG') ? 'RECORD' : 'EXCLUDE';
    const nextSrc = (next==='EXCLUDE') ? 'FLAG' : '';

    setShotStateByIdx(shotIdx, next, true, nextSrc);
    el('importStatus').innerHTML = `<span class="good">Shot #${shotIdx} → ${next}${(next==='EXCLUDE') ? ' (flag)' : ''}</span>`;
  });

  toggleRightBtn.addEventListener('click', ()=>{
    const hidden = rightCol.classList.toggle('hidden');
    gridEl.classList.toggle('fullWidth', hidden);
    toggleRightBtn.textContent = hidden ? 'Show Kestrel panel' : 'Hide Kestrel panel';
  });

  // init session date to today
  const now = new Date();
  el('sessionDate').value = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-${String(now.getDate()).padStart(2,'0')}`;
  renderTable();
  renderSummaries();
  // Phase 5.1 default distance
  const dd = el('defaultDist');
  if(dd){
    dd.value = String(defaultDistYd);
    dd.addEventListener('change', ()=>{
      const n = Number(dd.value);
      if(Number.isFinite(n) && n>0){
        defaultDistYd = n;
        recomputeGeoStats();
        renderBlockRollups();
        renderTable();
      }
    });
  }


  // ---------- Phase 5.4.4: table ergonomics (sticky cols, dense toggle, sorting) ----------
  function updateSortIndicators(){
    const ths = document.querySelectorAll('#shotTable thead th[data-sort]');
    ths.forEach(th=>{
      th.classList.remove('sort-asc','sort-desc');
      const k = th.getAttribute('data-sort');
      if(tableSort && tableSort.key===k){
        th.classList.add(tableSort.dir===1 ? 'sort-asc' : 'sort-desc');
      }
    });
  }

  function setupTableErgonomics(){
    const ths = document.querySelectorAll('#shotTable thead th[data-sort]');
    ths.forEach(th=>{
      th.addEventListener('click', ()=>{
        const k = th.getAttribute('data-sort');
        if(!k) return;
        if(tableSort.key===k) tableSort.dir = -tableSort.dir;
        else { tableSort.key = k; tableSort.dir = 1; }
        renderTable();
        updateSortIndicators();
      });
    });

    const btnDense = el('btnDense');
    const wrap = el('tableWrap');
    if(btnDense && wrap){
      btnDense.addEventListener('click', ()=>{
        wrap.classList.toggle('dense');
        const on = wrap.classList.contains('dense');
        btnDense.classList.toggle('active', on);
        btnDense.textContent = on ? 'Normal' : 'Dense';
      });
    }

    const btnReset = el('btnResetView');
    if(btnReset && wrap){
      btnReset.addEventListener('click', ()=>{
        // Reset sorting + density + scroll to sane defaults
        tableSort = { key: 'idx', dir: 1 };
        wrap.classList.remove('dense');
        const on = wrap.classList.contains('dense');
        btnDense.classList.toggle('active', on);
        btnDense.textContent = on ? 'Normal' : 'Dense';

        // Clear block filter (defaults to showing all)
        activeBlock = null;

        // Phase 1: reset expanded/collapsed groups + selection
        collapsedBlocks = new Set();
        selectedShots.clear();
        updateSelPill();

        // If Preview is active, cancel it
        if(previewActive) cancelPreview();

        // updateBlockActiveUI() not needed; renderBlockRollups() refreshes active state
        renderBlockRollups();

        // Reset table view
        renderTable();
        updateSortIndicators();
        try{ wrap.scrollLeft = 0; wrap.scrollTop = 0; }catch(e){}
      });
    }

    updateSortIndicators();
  }

  setupTableErgonomics();

  // Phase 3: Help modal
  // NOTE: modal markup sits AFTER the script tag in this single-file HTML,
  // so the element may not exist when this code runs. We bind lazily at click-time.
  {
    const btnHelp = el('btnHelp');
    const btnFilterHelp = el('btnFilterHelp');
    let modal = null;
    let wired = false;

    const ensure = ()=> (modal || (modal = el('helpModal')));
    const close = ()=>{ const m = ensure(); if(m) m.classList.add('hidden'); };

    const wireOnce = ()=>{
      if(wired) return;
      const m = ensure();
      if(!m) return;
      wired = true;

      const closeBtn = el('btnHelpClose');
      if(closeBtn) closeBtn.addEventListener('click', close);

      m.addEventListener('click', (e)=>{
        const t = e.target;
        if(t && t.getAttribute && t.getAttribute('data-close')) close();
      });

      document.addEventListener('keydown', (e)=>{
        const mm = ensure();
        if(e.key==='Escape' && mm && !mm.classList.contains('hidden')) close();
      });
    };

    const open = ()=>{
      const m = ensure();
      if(!m) return;
      wireOnce();
      m.classList.remove('hidden');
    };

    if(btnHelp) btnHelp.addEventListener('click', open);
    if(btnFilterHelp) btnFilterHelp.addEventListener('click', ()=>{
      open();
      // Scroll to the Filters section inside Help
      setTimeout(()=>{
        const t = el('helpFilters');
        if(t) t.scrollIntoView({behavior:'smooth', block:'start'});
      }, 0);
    });
}


  // ---------- v2.2.2: presets, filters, reset menu, action strip, shortcuts ----------
  function scrollToEl(elem){
    if(!elem) return;
    try{ elem.scrollIntoView({behavior:'smooth', block:'start'}); }catch(_e){ elem.scrollIntoView(true); }
  }

  function refreshBlockDropdowns(){
    const blocks = (smBlocks && smBlocks.length)
      ? smBlocks.map(b=>b.label)
      : Array.from(new Set((smShots||[]).map(s=>s.block).filter(Boolean)));

    // Manual block select
    const manSel = el('manBlockSel');
    if(manSel){
      const prev = manSel.value || '';
      manSel.innerHTML = `<option value="">(pick a string)</option>` + blocks.map(b=>`<option value="${esc(b)}">${esc(b)}</option>`).join('');
      if(prev && blocks.includes(prev)) manSel.value = prev;
    }

    // Filter block select (also drives Active view for convenience)
    const fSel = el('filterBlockSel');
    if(fSel){
      const prev = fSel.value || '';
      fSel.innerHTML = `<option value="">All blocks</option>` + blocks.map(b=>`<option value="${esc(b)}">${esc(b)}</option>`).join('');
      if(prev && blocks.includes(prev)) fSel.value = prev;
    }
  }

  function refreshPresetSelect(){
    const sel = el('layoutPresetSel');
    if(!sel) return;
    const names = Object.keys(PRESET_LAYOUTS||{}).sort((a,b)=>a.localeCompare(b));
    const prev = sel.value || 'Essential';
    sel.innerHTML = names.map(n=>`<option value="${esc(n)}">${esc(n)}</option>`).join('');
    sel.value = names.includes(prev) ? prev : (names.includes('Essential') ? 'Essential' : (names[0]||''));
  }

  function applyPresetByName(name){
    if(!name || !PRESET_LAYOUTS[name]) return;
    tablePrefs.visibleCols = normalizeVisibleCols(PRESET_LAYOUTS[name]);
    saveTablePrefs();
    renderTable();
    toast(`Preset applied: ${name}`);
  }

  // Preset controls
  {
    const sel = el('layoutPresetSel');
    const btn = el('btnApplyLayoutPreset');
    if(sel && !sel.dataset.wired){
      refreshPresetSelect();
      sel.dataset.wired='1';
    }
    if(btn && !btn.dataset.wired){
      btn.addEventListener('click', ()=>{
        const nm = sel ? sel.value : '';
        applyPresetByName(nm);
      });
      btn.dataset.wired='1';
    }
  }

  // Filter bar wiring
  {
    const q = el('filterSearch');
    const blk = el('filterBlockSel');
    const hx = el('filterHideExcluded');
    const oi = el('filterOnlyIssues');
    const os = el('filterOnlySighters');
    const mj = el('filterMissingJoin');
    const clr = el('btnClearFilters');

    if(hx) hx.checked = !!filterState.hideExcluded;

    const wire = (elx, fn)=>{
      if(!elx || elx.dataset.wired) return;
      elx.addEventListener('input', fn);
      elx.addEventListener('change', fn);
      elx.dataset.wired='1';
    };

    wire(q, ()=>{
      filterState.q = (q && q.value) ? q.value : '';
      renderTable();
    });

    wire(blk, ()=>{
      const v = blk ? blk.value : '';
      // convenience: selecting a block jumps to Active view
      activeBlock = v || null;
      filterState.block = '';
      renderBlockRollups();
      renderTable();
    });

    wire(hx, ()=>{
      filterState.hideExcluded = !!hx.checked;
      renderTable();
    });

    wire(oi, ()=>{
      filterState.onlyIssues = !!oi.checked;
      renderTable();
    });

    wire(os, ()=>{
      filterState.onlySighters = !!os.checked;
      renderTable();
    });

    wire(mj, ()=>{
      filterState.missingJoin = !!mj.checked;
      renderTable();
    });

    if(clr && !clr.dataset.wired){
      clr.addEventListener('click', ()=>{
        filterState.q = '';
        filterState.onlyIssues = false;
        filterState.onlySighters = false;
        filterState.missingJoin = false;
        filterState.hideExcluded = true;
        if(q) q.value = '';
        if(oi) oi.checked = false;
        if(os) os.checked = false;
        if(mj) mj.checked = false;
        if(hx) hx.checked = true;
        if(blk) blk.value = '';
        activeBlock = null;
        renderBlockRollups();
        renderTable();
      });
      clr.dataset.wired='1';
    }
  }

  // Pairing buttons
  {
    const btnA = el('btnAutoPair');
    const btnC = el('btnClearPairings');
    const pill = el('pairingStatusPill');

    if(btnA && !btnA.dataset.wired){
      btnA.addEventListener('click', ()=>{
        if(!smShots.length || !gFiles.length){
          toast('Load ShotMarker + Chrono first');
          return;
        }
        autoPairChronoSmart();
        const res = applyChronoPairings();
        if(pill){
          pill.style.display = '';
          pill.innerHTML = `<b>Pairing</b> • blocks: ${res.blocks} • mapped: ${res.mapped} • missing: ${res.missing}`;
        }
        recomputeBlockStats();
        renderBlockRollups();
        renderTable();
      });
      btnA.dataset.wired='1';
    }

    if(btnC && !btnC.dataset.wired){
      btnC.addEventListener('click', ()=>{
        chronoPair.clear();
        applyChronoPairings();
        if(pill){ pill.style.display='none'; pill.innerHTML=''; }
        renderPairingPanel();
        renderTable();
        toast('Pairings cleared');
      });
      btnC.dataset.wired='1';
    }
  }

  // Bulk state buttons + keyboard shortcuts
  function applyStateToSelected(state, src='MANUAL'){
    if(!selectedShots.size){
      toast('No shots selected');
      return;
    }
    const ids = Array.from(selectedShots);
    const items = [];
    bulkStateMode = true;
    for(const id of ids){
      const sh = smShots.find(s=>s.idx===id);
      if(!sh) continue;
      items.push({shotIdx:id, prevState:(sh.state||'RECORD'), prevSrc:(sh.stateSrc||'')});
      setShotStateByIdx(id, state, false, src);
    }
    bulkStateMode = false;
    undo = {type:'multiShot', items};
    recomputeBlockStats();
    recomputeGeoStats();
    renderBlockRollups();
    renderTable();
    toast(`Set ${ids.length} shot(s) → ${state}`);
  }

  {
    const br = el('btnBulkRecord');
    const bs = el('btnBulkSighter');
    const bx = el('btnBulkExclude');
    if(br && !br.dataset.wired){ br.addEventListener('click', ()=>applyStateToSelected('RECORD','MANUAL')); br.dataset.wired='1'; }
    if(bs && !bs.dataset.wired){ bs.addEventListener('click', ()=>applyStateToSelected('SIGHTER','MANUAL')); bs.dataset.wired='1'; }
    if(bx && !bx.dataset.wired){ bx.addEventListener('click', ()=>applyStateToSelected('EXCLUDE','MANUAL')); bx.dataset.wired='1'; }

    if(!document.body.dataset.hotkeys){
      document.addEventListener('keydown', (e)=>{
        const t = e.target;
        const inInput = t && (t.tagName==='INPUT' || t.tagName==='TEXTAREA' || t.tagName==='SELECT' || t.isContentEditable);
        if(inInput) return;

        if(e.key === '?' || (e.shiftKey && e.key === '/')){
          const b = el('btnHelp'); if(b) b.click();
          e.preventDefault(); return;
        }
        if(e.key === 'Escape'){
          selectedShots.clear();
          updateSelPill();
          renderTable();
          e.preventDefault(); return;
        }
        if(e.key === 'r' || e.key === 'R'){ applyStateToSelected('RECORD','MANUAL'); e.preventDefault(); return; }
        if(e.key === 's' || e.key === 'S'){ applyStateToSelected('SIGHTER','MANUAL'); e.preventDefault(); return; }
        if(e.key === 'x' || e.key === 'X'){ applyStateToSelected('EXCLUDE','MANUAL'); e.preventDefault(); return; }
      });
      document.body.dataset.hotkeys='1';
    }
  }

  // Reset menu modal
  {
    const btn = el('btnResetMenu');
    const modal = el('resetModal');
    const closeBtn = el('btnResetClose');
    const open = ()=>{
      if(!modal) return;
      modal.classList.remove('hidden');
    };
    const close = ()=>{
      if(!modal) return;
      modal.classList.add('hidden');
    };
    if(btn && !btn.dataset.wired){
      btn.addEventListener('click', open);
      btn.dataset.wired='1';
    }
    if(closeBtn && !closeBtn.dataset.wired){
      closeBtn.addEventListener('click', close);
      closeBtn.dataset.wired='1';
    }
    if(modal && !modal.dataset.wired){
      modal.addEventListener('click', (e)=>{
        const t = e.target;
        if(!(t instanceof HTMLElement)) return;
        if(t.getAttribute('data-close')==='1') close();
      });
      modal.dataset.wired='1';
    }
    const rs = el('btnResetSession');
    const rtp = el('btnResetTablePrefs');
    const rl = el('btnResetLayouts');
    const rv = el('btnResetViewFromMenu');

    if(rs && !rs.dataset.wired){
      rs.addEventListener('click', ()=>{
        clearAll();
        close();
        toast('Session cleared');
      });
      rs.dataset.wired='1';
    }
    if(rtp && !rtp.dataset.wired){
      rtp.addEventListener('click', ()=>{
        try{ localStorage.removeItem(TABLE_PREFS_KEY); }catch(_e){}
        loadTablePrefs();
        close();
        renderTable();
        toast('Table prefs reset');
      });
      rtp.dataset.wired='1';
    }
    if(rl && !rl.dataset.wired){
      rl.addEventListener('click', ()=>{
        try{ localStorage.removeItem(TABLE_LAYOUTS_KEY); }catch(_e){}
        close();
        toast('Saved layouts reset');
      });
      rl.dataset.wired='1';
    }
    if(rv && !rv.dataset.wired){
      rv.addEventListener('click', ()=>{
        if(el('btnResetView')) el('btnResetView').click();
        close();
      });
      rv.dataset.wired='1';
    }
  }

  // Next action bar
  function updateNextActionBar(){
    const bar = el('nextActionBar');
    const steps = el('nextActionSteps');
    const msg = el('nextActionMsg');
    const btn = el('btnNextDo');
    if(!bar || !steps || !msg || !btn) return;

    // allow dismiss for this reload
    if(window.__dismissNextAction) { bar.classList.add('hidden'); return; }

    const hasSM = !!(smShots && smShots.length);
    const hasChrono = !!(gFiles && gFiles.length);
    const hasK = !!(kSamples && kSamples.length);
    const hasAMP = !!(ampSession && ampSession.map && ampSession.map.size);

    const todo = [];
    if(!hasSM) todo.push('ShotMarker');
    if(hasSM && !hasChrono) todo.push('Chrono');
    if(hasSM && hasChrono){
      // if any block lacks pairing name, prompt pairing
      const blocks = (smBlocks && smBlocks.length) ? smBlocks.map(b=>b.label) : Array.from(new Set(smShots.map(s=>s.block).filter(Boolean)));
      const need = blocks.some(b=> !(chronoPair.get(b) && chronoPair.get(b).name));
      if(need && shouldShowChronoControls()) todo.push('Pairing');
    }
    // Kestrel/AMP are optional - show as optional hints
    const opt = [];
    if(hasSM && !hasK) opt.push('Kestrel');
    if(hasSM && !hasAMP) opt.push('AMP');

    const chip = (label, cls)=>`<span class="stepChip ${cls}">${esc(label)}</span>`;
    steps.innerHTML =
      chip('ShotMarker', hasSM?'ok':'todo') +
      chip('Chrono', hasChrono?'ok':(hasSM?'todo':'todo')) +
      chip('Pair', (hasSM && hasChrono && !todo.includes('Pairing')) ? 'ok' : ((hasSM && hasChrono) ? 'todo' : 'todo')) +
      chip('Kestrel', hasK?'ok':'warn') +
      chip('AMP', hasAMP?'ok':'warn');

    let action = null;

    if(!hasSM){
      msg.textContent = 'Import ShotMarker CSV to begin.';
      action = ()=>{
        const inp = el('fileSM'); if(inp) inp.click();
        scrollToEl(el('fileSM'));
      };
    }else if(!hasChrono){
      msg.textContent = 'Import Chrono CSVs (one per string), then check pairing.';
      action = ()=>{
        const inp = el('fileG'); if(inp) inp.click();
        scrollToEl(el('fileG'));
      };
    }else if(todo.includes('Pairing')){
      msg.textContent = 'Check pairing: ShotMarker strings ↔ chrono files.';
      action = ()=>{
        // open pairing rollup
        const body = el('pairBody');
        if(body && body.classList.contains('hidden')){
          body.classList.remove('hidden');
          const ch = el('pairChevron'); if(ch) ch.textContent = '▾';
        }
        scrollToEl(el('pairingCard'));
      };
    }else{
      msg.textContent = opt.length ? `Ready. Optional: ${opt.join(' + ')}.` : 'Ready. Review blocks, then export JSON/CSV.';
      action = ()=>{
        // open Tools rollup
        const body = el('toolsBody');
        if(body && body.classList.contains('hidden')){
          body.classList.remove('hidden');
          const ch = el('toolsChevron'); if(ch) ch.textContent = '▾';
        }
        scrollToEl(el('phase4ToolsCard'));
      };
    }

    btn.onclick = action;
    bar.classList.remove('hidden');
  }

  {
    const dismiss = el('btnNextSkip');
    if(dismiss && !dismiss.dataset.wired){
      dismiss.addEventListener('click', ()=>{
        window.__dismissNextAction = true;
        const bar = el('nextActionBar'); if(bar) bar.classList.add('hidden');
      });
      dismiss.dataset.wired='1';
    }
  }

  // Refresh dynamic dropdowns + action strip whenever imports change
  const _origUpdateImportStepper = updateImportStepper;
  updateImportStepper = function(){
    try{ _origUpdateImportStepper(); }catch(_e){}
    try{ refreshBlockDropdowns(); }catch(_e){}
    try{ updateNextActionBar(); }catch(_e){}
    try{ refreshPresetSelect(); }catch(_e){}
  };


  // Manual inputs wiring + shot selection
  {
  const shotTbody = el('shotTbody');
  if(shotTbody){
    shotTbody.addEventListener('change', (e)=>{
      const cb = e.target && e.target.classList && e.target.classList.contains('rowSel') ? e.target : null;
      if(!cb) return;
      const id = Number(cb.getAttribute('data-sel'));
      if(!Number.isFinite(id)) return;
      if(cb.checked) selectedShots.add(id); else selectedShots.delete(id);
      updateSelPill();
    });
  }

  const clearSelBtn = el('btnClearSelection');
  if(clearSelBtn){
    clearSelBtn.addEventListener('click', ()=>{
      selectedShots.clear();
      updateSelPill();
      renderTable();
      const st = el('manStatus');
      if(st) st.innerHTML = `<span class="hint">Selection cleared.</span>`;
    });
  }

  const applySelBtn = el('btnApplySelected');
  if(applySelBtn){
    applySelBtn.addEventListener('click', ()=>{
      if(!selectedShots.size){
        const st = el('manStatus');
        if(st) st.innerHTML = `<span class="bad">No shots selected.</span>`;
        return;
      }
      const picked = smShots.filter(s=>selectedShots.has(s.idx));
      const res = applyManualToShots(picked);
      renderTable();
      const st = el('manStatus');
      if(st) st.innerHTML = `<span class="good">Applied manual fields to ${res.changed} selected shot(s).</span>`;
    });
  }

  const applyStrBtn = el('btnApplyToString');
  if(applyStrBtn){
    applyStrBtn.addEventListener('click', ()=>{
      const blk = el('manBlockSel') ? el('manBlockSel').value : '';
      if(!blk){
        const st = el('manStatus');
        if(st) st.innerHTML = `<span class="bad">Pick a string / block first.</span>`;
        return;
      }
      const picked = smShots.filter(s=>s.block===blk);
      const res = applyManualToShots(picked);
      renderTable();
      const st = el('manStatus');
      if(st) st.innerHTML = `<span class="good">Applied manual fields to ${res.changed} shot(s) in ${esc(blk)}.</span>`;
    });
  }

  updateSelPill();
  }

  try{ updateImportStepper(); }catch(_e){}
  try{ updateImportSummary(); }catch(_e){}
  renderBlockRollups();
})();

  // --- v2.2.2: Blue tooltips (replace native title tooltips) ----------------
  function initBlueTooltips(){
    // Create tooltip element once
    let tip = document.getElementById('slBlueTip');
    if(!tip){
      tip = document.createElement('div');
      tip.id = 'slBlueTip';
      document.body.appendChild(tip);
    }

    const harvest = (root)=>{
      if(!root || !root.querySelectorAll) return;
      root.querySelectorAll('[title]').forEach(n=>{
        if(n.dataset && n.dataset.slTitle) return;
        const t = n.getAttribute('title');
        if(!t) return;
        n.dataset.slTitle = t;
        n.removeAttribute('title'); // suppress native tooltip
      });
    };

    // Harvest existing titles, and keep harvesting dynamically-created nodes
    harvest(document);
    const mo = new MutationObserver((mutations)=>{
      for(const mu of mutations){
        if(mu.type === 'childList'){
          mu.addedNodes && mu.addedNodes.forEach(n=>{
            if(n.nodeType === 1){
              harvest(n);
              // If the node itself has title
              if(n.getAttribute && n.getAttribute('title')){
                const t = n.getAttribute('title');
                if(t){
                  n.dataset.slTitle = t;
                  n.removeAttribute('title');
                }
              }
            }
          });
        }else if(mu.type === 'attributes' && mu.attributeName === 'title'){
          const n = mu.target;
          if(n && n.getAttribute){
            const t = n.getAttribute('title');
            if(t){
              n.dataset.slTitle = t;
              n.removeAttribute('title');
            }
          }
        }
      }
    });
    mo.observe(document.documentElement, {subtree:true, childList:true, attributes:true, attributeFilter:['title']});

    let activeEl = null;
    const getText = (el)=>{
      if(!el) return '';
      // Prefer explicit data-tip, fall back to harvested title text
      return (el.dataset && (el.dataset.tip || el.dataset.slTitle || el.dataset.tooltip)) || '';
    };

    const show = (el, x, y)=>{
      const text = getText(el);
      if(!text) return;
      tip.textContent = text;
      tip.classList.add('show');
      position(x, y);
    };

    const hide = ()=>{
      tip.classList.remove('show');
      activeEl = null;
    };

    const position = (x, y)=>{
      const pad = 10;
      const vw = window.innerWidth, vh = window.innerHeight;
      // start near cursor with offset
      let left = x + 14;
      let top  = y + 14;

      // Measure after content set
      const r = tip.getBoundingClientRect();
      if(left + r.width + pad > vw) left = Math.max(pad, vw - r.width - pad);
      if(top  + r.height + pad > vh) top  = Math.max(pad, y - r.height - 14);
      tip.style.left = left + 'px';
      tip.style.top  = top + 'px';
    };

    document.addEventListener('pointermove', (e)=>{
      if(!activeEl) return;
      position(e.clientX, e.clientY);
    }, {passive:true});

    document.addEventListener('pointerover', (e)=>{
      const el = e.target && e.target.closest && e.target.closest('[data-tip],[data-tooltip],[data-sl-title],[data-slTitle]');
      if(!el) return;
      activeEl = el;
      show(el, e.clientX, e.clientY);
    });

    document.addEventListener('pointerout', (e)=>{
      const related = e.relatedTarget;
      if(activeEl && (!related || !(related.closest && related.closest('[data-tip],[data-tooltip],[data-sl-title],[data-slTitle]')))){
        hide();
      }
    });

    // Keyboard accessibility
    document.addEventListener('focusin', (e)=>{
      const el = e.target && e.target.closest && e.target.closest('[data-tip],[data-tooltip],[data-sl-title],[data-slTitle]');
      if(!el) return;
      activeEl = el;
      const b = el.getBoundingClientRect();
      show(el, Math.round(b.left + b.width/2), Math.round(b.bottom));
    });

    document.addEventListener('focusout', ()=> hide());
    // Hide on scroll so it doesn't drift
    window.addEventListener('scroll', ()=> hide(), {passive:true});
  }

  try{
    if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', initBlueTooltips);
    else initBlueTooltips();
  }catch(_){}

</script>
<div class="modal hidden" id="helpModal" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
  <div class="modal__backdrop" data-close="1"></div>
  <div class="modal__panel card">
    <div class="modal__hdr">
      <div>
        <div class="modal__title" id="helpTitle">ShotLedger — how to use it</div>
        <div class="modal__sub">Built for 1000-yard reality: vertical is king; velocity is context.</div>
      </div>
      <button class="btn small ghost" id="btnHelpClose" type="button" title="Close">Close</button>
    </div>
    <div class="modal__body">
      <div class="modal__section">
        <div class="modal__h">Start here (the happy path)</div>
        <ol>
          <li><b>Import ShotMarker CSV</b> (Export all traces). You should see blocks/strings and shot counts.</li>
          <li><b>Import Chrono CSVs</b> (one file per ShotMarker string). ShotLedger will auto-pair, then you can correct it.</li>
          <li><b>Optional:</b> import Kestrel + AMP for richer diagnostics.</li>
        </ol>
        <div class="hint">Tip: the “Next” bar at the top will point you at the next missing step.</div>
      </div>

      <div class="modal__section">
        <div class="modal__h">Pairing rules (important)</div>
        <ul>
          <li>Pairing is <b>per-string</b>: 1 ShotMarker string ↔ 1 chrono file.</li>
          <li>Mapping is <b>by shot index within the string</b> (1..N). Order matters.</li>
          <li>If counts don’t match, ShotLedger shows a warning and lets you fix pairings manually.</li>
        </ul>
      </div>

      <div class="modal__section">
        <div class="modal__h">Shot states</div>
        <ul>
          <li><b>R (Record)</b>: counts toward stats.</li>
          <li><b>S (Sighter)</b>: shown for context, excluded from record stats.</li>
          <li><b>✕ (Exclude)</b>: removed from record stats.</li>
        </ul>
        <div class="hint">Click ΔVel(σ) chips to toggle <b>Exclude</b> quickly; use Undo if you fat-finger it.</div>
      </div>

      <div class="modal__section">
        <div class="modal__h">How to read issues</div>
        <ul>
          <li><b>Join = MISS/BAD</b>: Kestrel time match didn’t land (or looks wrong).</li>
          <li><b>Row highlight</b>: missing Garmin mapping, preview changes, or dirty edits.</li>
          <li><b>ΔVel (σ)</b>: “eyebrow raise” starts around ~1.3σ; ~1.9σ is a strong candidate for exclusion.</li>
        </ul>
      </div>

      
      <div class="modal__section" id="helpFilters">
        <div class="modal__h">Filters & views</div>
        <ul>
          <li><b>Search</b> matches block name, tag, notes, and numeric fields (like score) where applicable.</li>
          <li><b>Hide excluded</b> removes ✕ rows from the table view (stats already ignore them).</li>
          <li><b>Only issues</b> shows rows that need attention: join misses, missing mappings, or edited/dirty rows.</li>
          <li><b>Missing joins</b> narrows to rows where the Kestrel join did not land (Join = MISS/BAD).</li>
        </ul>
        <div class="hint">Tip: use the column presets (Essential / Chrono / Wind / AMP / Geometry) to quickly change what you’re looking at.</div>
      </div>
<div class="modal__section">
        <div class="modal__h">Shortcuts</div>
        <ul>
          <li><b>?</b> open Help</li>
          <li><b>r</b> / <b>s</b> / <b>x</b> → set selected shots to Record / Sighter / Exclude</li>
          <li><b>Esc</b> clears selection</li>
        </ul>
      </div>

      <div class="modal__section">
        <div class="modal__h">Troubleshooting</div>
        <ul>
          <li>If ShotMarker says “0 shots”, check you exported <b>all traces</b> and that the header row is present.</li>
          <li>If pairing looks wrong, hit <b>Auto-pair</b> then manually override the few offenders.</li>
          <li>If the table feels “stuck”, hit <b>Reset view</b> or try <b>Virtual</b> mode for big datasets.</li>
        </ul>
      </div>

      <div class="modal__section">
        <div class="modal__h">What ShotLedger intentionally does NOT do</div>
        <ul>
          <li>No auto-cleaning / auto-exclusions.</li>
          <li>No single “magic score.” You stay in control.</li>
        </ul>
      </div>
    </div></div>
  </div>
</div>

<!-- Columns & Layouts Modal (Phase 0) -->
<div class="modal hidden" id="colsModal" role="dialog" aria-modal="true">
  <div class="modalCard" style="max-width:920px;">
    <div class="modalHead">
      <div>
        <b>Columns & Layouts</b>
        <div class="hint">Hide/unhide columns, pick presets, and save layouts (stored in this browser).</div>
      </div>
      <button class="btn small ghost" id="btnColsClose" type="button">Close</button>
    </div>
    <div class="modalBody">
      <div class="row" style="gap:10px; align-items:center; flex-wrap:wrap;">
        <span class="hint">Preset</span>
        <select id="colsPresetSel" class="miniSelect"></select>
        <span class="hint">Saved</span>
        <select id="colsSavedSel" class="miniSelect"></select>
        <button class="btn small" id="btnColsSave" type="button">Save as…</button>
        <button class="btn small ghost" id="btnColsReset" type="button">Reset to Full</button>
      </div>
      <div class="colsGrid" id="colsGrid"></div>
    </div>
    <div class="modalFoot">
      <button class="btn small" id="btnColsApply" type="button">Apply</button>
      <button class="btn small ghost" id="btnColsCancel" type="button">Cancel</button>
    </div>
  </div>
</div>

<div class="modal hidden" id="resetModal" role="dialog" aria-modal="true" aria-labelledby="resetTitle">
  <div class="modal__backdrop" data-close="1"></div>
  <div class="modal__panel card">
    <div class="modal__hdr">
      <div>
        <div class="modal__title" id="resetTitle">Reset</div>
        <div class="modal__sub">Pick what to reset — you won’t lose the HTML file itself, just the loaded session / local preferences.</div>
      </div>
      <button class="btn small ghost" id="btnResetClose" type="button">Close</button>
    </div>
    <div class="modal__body">
      <div class="modal__section">
        <div class="modal__h">Session data</div>
        <div class="row" style="gap:10px; flex-wrap:wrap;">
          <button class="btn" id="btnResetSession" type="button">Clear loaded session</button>
          <div class="hint">Clears loaded ShotMarker / Chrono / AMP / Kestrel data, pairings, edits, and selection.</div>
        </div>
      </div>
      <div class="modal__section">
        <div class="modal__h">Table preferences</div>
        <div class="row" style="gap:10px; flex-wrap:wrap;">
          <button class="btn ghost" id="btnResetTablePrefs" type="button">Reset table prefs</button>
          <button class="btn ghost" id="btnResetLayouts" type="button">Reset saved layouts</button>
          <div class="hint">Resets density, sort, virtual mode, and column visibility/saved layouts stored in this browser.</div>
        </div>
      </div>
      <div class="modal__section">
        <div class="modal__h">Quick</div>
        <div class="row" style="gap:10px; flex-wrap:wrap;">
          <button class="btn small ghost" id="btnResetViewFromMenu" type="button">Reset view (sort/density)</button>
          <span class="hint">Same as the table “Reset” button.</span>
        </div>
      </div>
    </div>
  </div>
</div>

</body>
</html>
